/**
 * Global form handler
 *
 * Use for form validation
 *
 * @author jrylan
 */

/*
 How to use this code:

 $(function(){
    var test = new Base.FormHandler.extend({
        selector: $('.form'),

        restURL: "blah",

        // If you provide a `submit` callback, it's boolean return value will
        // determine if the ajax validation request should be should be processed.
        submit: function() {
            if (doSomething) {
                return true;
            }
            return false;
        },

        inputs: [
            {
                id: "text1",
                validateUrl: "foo1.php",
                validateOn: "blur",
                validate: function() {
                    this.ajaxValidation();
                }
            }
        ]
    });
});
*/

(function() {
    /*
     * Setup the view
     */
    var view = Base.View.extend({
        initialize: function() {
            this.$error = this.$el.find(".alert-message");
            this.$errorMsg = this.$error.find("p");
        },

        showTopLevelErrors: function(collection) {
            if (!this.$error || collection.submitted !== true) {
                return;
            }

            if (collection.formErrors) {
                this.$errorMsg.html( collection.formErrors.join("<br>") );
            } else {
                this.$errorMsg.html( this.$errorMsg.data("original") );
            }

            this.$error.removeClass("hide");
        },

        hideTopLevelErrors: function() {
            this.$error.addClass("hide");
        },

        toggleStatus: function(model) {
            var status = model.get("status");

            if (status == "success") {
                model.$wrap.removeClass("error").addClass("success");
            }
            else if (status == "error" || status == "error-soft") {
                model.$wrap.removeClass("success").addClass("error");
            }
            else {
                model.$wrap.removeClass("success").removeClass("error");
            }
        },

        setErrorMessage: function(model) {
            var errors = model.get("errors");

            if (typeof errors != "string") {
                errors = errors.join("<br>");
            }

            model.$wrap.find(".s-error").html(errors);
        },

        setActive: function($el) {
            $el.parents(".wrapper-input").addClass("active");
        },

        setInactive: function($el) {
            $el.parents(".wrapper-input").removeClass("active");
        }
    });



    /*
     * Setup the model
     */
    var input = Base.Model.extend({
        defaults: {
            active: false,
            error: false
        },

        initialize: function() {
            var self = this;

            if (this.attributes.type != "radio") {
                this.$el = $("#" + this.id);
                this.$el.data("__id__", this.id);

                this.$wrap = this.$el.parents(".wrapper-input");
                this.type = (this.$el.attr("type") || this.$el[0].tagName).toLowerCase();
                if (this.type == "input") {
                    this.type = "text";
                }

                this.name = (this.$el.attr("name") || this.id);

                if (this.attributes.validateOn) {
                    this.$el.bind(this.attributes.validateOn, function(e){
                        self.set("value", self.getValue());
                        self.inputValidation(e);
                    });
                }

                if (this.get("active")) {
                    self.$el.focus();
                    this.set("active", true);
                }
            } else {
                this.name = this.id;
                this.type = "radio";
                this.$wrap = $("input[name=" + this.name + "]:first").parents(".wrapper-input");
            }

            var val = this.getValue();

            this.set({
                "value": val,
                "initValue": val,
                "lastValue": val
            }, {silent:false});
        },

        ajaxValidation: function() {
            var self = this,
                value = this.getValue(),
                data = {},
                params = {
                    dataType: "json"
                };

            data[this.name] = value;

            if (typeof this.attributes.validationData == "function") {
                extend(data, this.attributes.validationData(this.collection));
            }

            return Sync(this.attributes.validationURL).update(data, params)
                .success(function(data) {
                    if (typeof data._success == "undefined") {
                        return;
                    }

                    if (data._success === true) {
                        self.set("status", "success");
                    } else {
                        if (data._reason && data._reason.length > 0) {
                            var reasons = [];
                            for (var i=0, reason; reason=data._reason[i]; i++) {
                                reasons.push(reason.message);
                            }
                            self.set("errors", reasons);
                        }
                        self.set("status", "error");
                    }
                })
                .error(function() {
                    //alert("error");
                });
        },

        getValue: function(){
            switch(this.type) {
                case "checkbox":
                    return this.$el.is(":checked");
                    break;

                case "radio":
                    return $("input[name=" + this.id + "]:checked").val();
                    break;

                default:
                    var value = this.$el.val();
                    return value ? value : "";
            }
        },

        hasChanged: function() {
            return (this.getValue() != this.get("initValue"));
        },

        inputValidation: function(e) {
            var self = this,
                value = this.getValue();

            if (!value) {
                return;
            }
            if (!this.attributes.validate) {
                this.ajaxValidation();
            } else {
                this.attributes.validate.call(this);
            }
        },

        removeErrorIfNotEmpty: function() {
            if (this.value != "") {
                this.set("status", "success");
            }
        },

        updateInitValue: function() {
            this.set("initValue", this.getValue());
        }
    });


    /*
     * Setup the collection of models
     */
    var inputs = Base.Collection.extend({
        submitted: false,

        model: input,

        initialize: function() {
            this.totalErrors = 0;
        },

        recordStatusChange: function(model) {
            var status = model.get("status"),
                prevStatus = model._previousAttributes.status;

            if (status == "error-soft") {
                return;
            }
            else if (status == "error") {
                this.totalErrors++;
            }
            else if (prevStatus) {
                this.totalErrors--;
            }
        },

        updateInitValues: function() {
            for (var id in this._byId) {
                this.getById(id).updateInitValue();
            }
        }
    });



    Base.FormHandler = Base.Controller.extend({
        method: "update",

        useAjaxFieldValidation: true,

        initialize: function(config) {
            var self = this;

            this.view = new view(this);

            var collection = new inputs(this);

            collection.model.prototype
                .bind("change:status", this.view.toggleStatus)
                .bind("change:status", collection.recordStatusChange, collection)
                .bind("change:errors", this.view.setErrorMessage, this.view);

            this.bindEvents({
                "submit": "_submit",
                "press .submit": "_submit",
                "press .cancel": "cancel",
                "press .alert-message .close": "closeMessage"
            });

            if (this.highlightLabels) {
                $("input,select,textarea", this.$el)
                    .live("focus", function(e){
                        view.prototype.setActive( $(this) );
                    })
                    .live("blur", function(e){
                        view.prototype.setInactive( $(this) );
                    });
            }

            // Changes the provided `inputs` property into an accessible collection
            this.inputs = collection.add(this.inputs, {silent:true});
            if (!this.formData) {
                this.formData = this._formData;
            }

            this.init(config);
        },

        init: function(config) {},

        closeMessage: function() {
            this.view.hideTopLevelErrors();
        },

        _formData: function(options) {
            options = options || {};
            var getAllFields = options.fields != "changed" || false;

            var data = {},
                id,
                model,
                total = 0;

            for (id in this.inputs._byId) {
                model = this.inputs.getById(id);

                if (getAllFields || model.attributes.persist || model.hasChanged()) {
                    data[model.name] = model.getValue();
                    total++;
                }
            }

            $("input[type=hidden]", this.$el).each(function(){
                var $this = $(this);
                data[$this.attr("name")] = $this.val();
            });

            return total ? data : false;
        },

        cancel: function() {
            this.$el[0].reset();
        },

        _submit: function() {
            if (this.inputs.totalErrors > 0 && this.useAjaxFieldValidation) {
                return;
            }
            var formData = this.formData();

            if (!formData) {
                return false;
            }

            if (this.submit) {
                if (this.submit(formData)) {
                    this.ajaxSubmit(formData);
                }
            } else {
                this.ajaxSubmit(formData);
            }
        },

        ajaxSubmit: function(formData) {
            var self = this;

            if (this._submitInProcess) {
                return;
            }

            this._submitInProcess = true;
            this.inputs.submitted = true;
            this.inputs.formErrors = false;

            return self.sync[self.method](formData)
                .success(function(data, textStatus, jqXHR) {
                    if (SU.Captcha.isRequired(data)) {
                        self._submitInProcess = false;
                        self.inputs.submitted = false;
                        SU.Captcha.show(function(){
                            self.ajaxSubmit(formData);
                        });
                        return;
                    }

                    self._submitInProcess = false;
                    if (data._success === true && self.success) {
                        self.inputs.updateInitValues();
                        self.success(data, textStatus, jqXHR);
                    }
                    else if (self.failure) {
                        self.failure(data, textStatus, jqXHR);
                    }
                    else {
                        self.inputs.totalErrors = 0;

                        if (data._reason) {
                            if (Utils.isArray(data._reason)) {
                                var reasons = [];
                                for (var i=0, reason; reason=data._reason[i]; i++) {
                                    if (reason.meta && reason.meta.field) {
                                        var model = self.inputs.getById(reason.meta.field);
                                    }
                                    if (model) {
                                        model.set("status", "error");
                                        model.set("errors", reason.message);
                                    } else {
                                        reasons[reasons.length] = reason.message;
                                    }
                                }
                                self.inputs.formErrors = reasons;
                                self.view.showTopLevelErrors(self.inputs);
                            }
                        }
                    }
                })
                .error(function(jqXHR, textStatus, errorThrown) {
                    self._submitInProcess = false;
                    if (self.error) {
                        self.error(jqXHR, textStatus, errorThrown);
                    }
                });
        }
    });
}).call(this);
/*

How to use this code:

NAMESPACE.Modal = new Base.Modal(OPTIONS_OBJECT);

1. Load content for a specific selector on the page:
NAMESPACE.Modal.load("#some-content").open();

2. Load content from a specific URL
NAMESPACE.Modal.loadURL("http://www.google.com/").open();

3. Load content from a specific URL in an iframe:
NAMESPACE.Modal.loadURL("http://www.google.com/", {iframe:true}).open();

4. Set the HTML content directly:
NAMESPACE.Modal.set("<h1>Blah</h1>").open();

5. When calling the `open` method, you can pass a configuration object:
"ready" - Function to execute when the content has been set

"close:before" - Function to execute when the user tries to close the modal. Must return a boolean value -- returing `true` will close the modal.

"close:after" - Callback function to execute when the modal has closed.

"close:overlay" - Boolean to denote if the user should be able to click on the overlay to close the modal.

Sample config:
{
    "ready": function() {
        console.log("Your content is ready");
    },
    "close:before": function(){
        return confirm("Are you sure you want to close this?");
    },
    "close:after": function(){
        alert("you closed the modal!");
    },
    "close:overlay": false
}

*/


(function() {
    /*
     * Setup the view
     */
    var _view = Base.View.extend({
        initialize: function() {
            this.$content = this.$el.find(".modal-content");
        },


        load: function(selector) {
            this.ready = false;

            if (selector) {
                var $selector = selector instanceof $ ? selector : $(selector);
                this.$content.html( $selector.html() );
            }

            this.measureHeight().positionContent();
        },

        loadURL: function(url, settings) {
            this.ready = false;
            var view = this;

            if (settings.wrapperClass) {
                this.$content.addClass(settings.wrapperClass);
            }

            if (settings.iframe) {
                this.$content.html("<iframe src=" + url + " frameborder=0 class=modal-iframe>");
                this.$content.find("iframe").bind("load", function(){
                    view.measureHeight().positionContent();
                });
            } else {
                $.get(url, function(response){
                    view.set(response);
                    view.measureHeight().positionContent();
                });
            }
        },


        set: function(str) {
            this.ready = false;
            this.$content.html(str);
            this.measureHeight().positionContent();
        },

        measureHeight: function() {
            // The display property of the element has to be set to something other than `block` in order to measure it's height.
            this.$el.css({"visibility":"hidden", "display":"block"});
            var _height = "" + this.$content.height();
            this._height = _height;
            this.$el.css({"visibility":"", "display":""});
            return this;
        },

        positionContent: function() {
            var modalHeight = this._height,
                windowHeight = $win.height(),
                topOffet;

            if (modalHeight < windowHeight) {
                this.$el.css("position", "fixed");
                topOffset = Math.ceil( (windowHeight - modalHeight) / 2) - ( (20 / modalHeight) * 100);
            } else {
                this.$el.css("position", "absolute");
                topOffset = Math.ceil( $win.scrollTop() + 25 );
            }

            this.$el.css("top", topOffset);
            this.ready = true;
            this.trigger("ready");

            return this;
        },


        changeStatus: function(model) {
            if ("open" == model.get("status")) {
                this.$overlay.addClass("modal-open");
                this.$el.addClass("modal-open");
            } else {
                this.$overlay.removeClass("modal-open");
                this.$el.removeClass("modal-open");
            }
        },

        toggleCloseButton: function(status) {
            if (status) {
                this.$el.addClass("modal-hide-close");
            } else {
                this.$el.removeClass("modal-hide-close");
            }
        },

        insertOverlay: function() {
            $body.append("<div id=modal-overlay class=modal-overlay><!--  --></div>");
        },

        insertModal: function() {
            $body.append('' +
                '<div id=modal class=modal-container>' +
                    '<div class=modal>' +
                        '<div class=modal-content><!--  --></div>' +
                        '<a href=# class="btn-modal-close modal-close" title="close">&times;</a>' +
                    '</div>' +
                '</div>');
        }
    });



    /*
     * Setup the controller
     */
    Base.Modal = Base.Controller.extend({
        initialize: function(config) {
            this._config = config || {};

            /*
             * Setup the model
             */
            this.model = new Base.Model({
                "status": "closed",
                "ready": false
            });

            return this;
        },

        // On demand init
        _initialize: function() {
            if (this._initialized) {
                return this;
            }

            this._initialized = true;

            var self = this,
                $overlay,
                $modal;

            $overlay = this.overlay ? $(this.overlay) : null;

            if (!$overlay) {
                $overlay = $("#modal-overlay");

                if (!$overlay.length) {
                    _view.prototype.insertOverlay();
                    $overlay = $("#modal-overlay");
                }
            }

            $modal = this.modal ? $(this.modal) : null;
            if (!$modal) {
                $modal = $("#modal");

                if (!$modal.length) {
                    _view.prototype.insertModal();
                    $modal = $("#modal");
                }
            }

            this.$el = $modal;


            this.view = new _view(this);
            this.view.$overlay = $overlay;

            this.model.bind("change:status", this.view.changeStatus, this.view);

            this.bindEvents(this.model, {
                "press .btn-modal-close": "closeButton"
            });

            $win.resize(function(){
                self.view.positionContent();
            });

            this.init();

            return this;
        },

        init: function(){},

        load: function(selector) {
            this._initialize().view.load(selector);
            return this;
        },

        loadURL: function(url, config) {
            var settings = {iframe:false};
            extend(settings, config);

            this._initialize().view.loadURL(url, settings);
            return this;
        },

        set: function(str) {
            this._initialize().view.set(str);
            return this;
        },

        close: function() {
            if ( this.isOpen() ) {
                this.model.set("status", "closed");

                if (this._config["close:after"]) {
                    this._config["close:after"]();
                }
            }

            return this;
        },

        closeButton: function() {
            if (this._config["close:before"]) {
                if (this._config["close:before"]()) {
                    this.close();
                }
            } else {
                this.close();
            }
        },

        open: function(config) {
            var self = this;

            var settings = {
                "close:overlay": true
            };

            this._initialize();

            config = config || {};

            extend(settings, config);
            extend(this._config, settings);


            if (!Browser.supports("touch")) {
                this.view.$overlay.unbind("click.modal");
                this.$el.unbind("click.modal");

                if (this._config["close:overlay"]) {
                    this.view.$overlay.bind("click.modal", function(){
                        self.close();
                    });
                }
            }

            if (this._config["close:hide"] === true) {
                this.view.toggleCloseButton(true);
            } else {
                this.view.toggleCloseButton(false);
            }

            this.model.set("status", "open");
            if (this._config["ready"]) {
                this._config["ready"]();
            }

            return this;
        },

        isOpen: function() {
            return "open" == this.model.get("status");
        }
    });
}).call(this);
/**
 * login js
 *
 * js for ajax login
 *
 * @author jrylan, haroun,  mdavid
 */
(function(){
    SU.Login = Base.FormHandler.extend({
        selector: "#login-form",

        method: "create",

        restURL: "/login",

        submit: function(values) {
            var hasErrors = false;

            var fields = [
                "user",
                "pass",
                "nativeSubmit"
            ];

            values.nativeSubmit = '0';

            for (var i=0,name; name=fields[i]; i++) {
                if (!values[name]) {
                    this.inputs.getById(name).set({status: "error-soft"});
                    hasErrors = true;
                }
            }

            return !(hasErrors);
        },

        success: function(response) {
            window.location = response.url;
        },

        error: function() {
            window.location.reload();
        },

        inputs: [
            {
                id:"user",
                active:true,
                validateOn: "blur",
                validate: function() {
                    return this.removeErrorIfNotEmpty();
                }
            },
            {
                id:"pass",
                validateOn: "blur",
                validate: function() {
                    return this.removeErrorIfNotEmpty();
                }
            },
            {
                id:"remember"
            }
        ]
    });

    SU.addInit("mLogin", function(config) {
        new SU.Login(config);
    });
}).call(this);
(function(){
    SU.Logout = Base.Controller.extend({
        restURL: "/logout",

        initialize: function(data) {
            this.sync.set(data);
            this.bindEvents({
                "press .logout" : "execute"
            });
        },

        execute: function() {
            return this.sync.del({"_action": "logout"})
                .success(function(response) {
                    if (response._success) {
                        window.location = "https://www.stumbleupon.com/logged-out";
                    }
                });
        }
    });

    SU.addInit("mLogout", function(data){
        new SU.Logout(data);
    });
}).call(this);
(function(){
    SU.addInit("avatarDebug", function() {
        $('.thumb').each(function(index, el)
            {
                if ($(el).find('img').width() > 0)
                {
                    var img = $(el).find('img');
                    $(el).find('.size').html($(img).width()+'x'+$(img).height());
                }
                else
                {
                    $(el).find('img').load(function(img) {
                        $(el).find('.size').html($(this).width()+'x'+$(this).height());
                    });
                }
            }
        );
    });
}).call(this);
(function(){
    // XSS token, gets set from the web.tpl
    var _token;
    var _viewtoken;

    var Stumble = Base.Model.extend({
        defaults: {
            "isliked": 0
        }
    });

    var Stumbles = Base.Collection.extend({
        model: Stumble
    });

    var View = Base.View.extend({
        initialize: function() {
            this.$stumbles = this.$el.find(".stumbles");
            this.$content = this.$el.find(".l-content-primary");
            this.$filter = this.$el.find(".stumbles-filter");
        },

        filterViewUpdated: function(filter) {
            if (filter.get("view") == "list") {
                this.$stumbles.removeClass("s-stumbles-grid").addClass("s-stumbles-list");
                this.$filter.removeClass("s-grid").addClass("s-list");
            } else {
                this.$stumbles.removeClass("s-stumbles-list").addClass("s-stumbles-grid");
                this.$filter.removeClass("s-list").addClass("s-grid");
            }
        }
    });

    var routePatterns = {
        "likes": "stumbler/(:username)",
        "interests": "stumbler/(:username)/interests",
        "comments": "stumbler/(:username)/comments",
        "history": "stumbler/(:username)/history",
        "interest": "interest/(:interest)",
        "channel": "channel/(:channel)",
        "shares": "shares",
        "url": "content/(:publicid)",
        "url_likes": "content/(:publicid)/likes"
    };

    var Router = Base.Router.extend({
        pagination: true,
        defaults: {
            "show": "all"
        }
    });


    SU.Stumbles = Base.Controller.extend({
        initialize: function(config) {
            var self = this;
            this.$el = $(config.pushTarget || config.selector);
            this.view = new View(this);
            this.stumbles = new Stumbles(this);
            this.stumbles.model.prototype.bind("change:isliked", this.statusChange);
            this.filter = new Base.Model({
                "view": config.view,
                "show": "all",
                "category": ""
            });

            this.filter
                .bind("change:view", this.view.filterViewUpdated, this.view)
                .bind("change:view", this.userUpdateViewSettings, this)
                .bind("change:show", this.filterShowUpdated, this)
                .bind("change:category", this.filterCategoryUpdated, this);


            this.bindEvents({
                "change .stumbles-filter #filter-show": "filterChangeShow",
                "change .stumbles-filter #filter-category": "filterChangeCategory",
                "press .stumble-view-toggle a": "filterChangeView",
                "press .e-stumbles .stumble-acts-info": "info"
            });

            this.bindEvents(this.stumbles, {
                "click .e-stumbles .stumble-acts-stumble": "stumble",
                "click .e-stumbles .stumble-unlike": "unlike",
                "click .e-stumbles .stumble-acts-share": "share",
                "click .e-stumbles .comment-controls a": "commentControls"
            });

            this.$el.on('click', ".e-stumbles .stumble-item", function(e) {
                // Don't stumble if the click target was an anchor or button
                if ( $(e.target).closest('a, .wrapper-comment, button').length ) {
                    return;
                }

                var $this = $(this),
                    id = $this.data("id"),
                    model,
                    $parent = null,
                    data = null;


                if (!id) {
                    $parent = $this.parents(".stumble-item");
                    id = $parent.data("id");
                    data = $parent.data();
                } else {
                    data = $this.data();
                }


                model = self.stumbles.getById(id);
                if (!model) {
                    self.stumbles.add(data);
                    model = self.stumbles.getById(data.id);
                }

                self.stumble(model, e);
            });

            if (config.pagination) {
                this.route = new Router(this, routePatterns[config.route]);
                this.route.bind("ready", function(){
                    self.stumbles.reset();
                });
            }
        },

        commentControls: function(model, e) {
            e.stopPropagation();
            var $targ = $(e.target),
                $commentRoot = $targ.parent();
                action = $targ.data('action'),
                commentId = $commentRoot.data('commentid'),
                comment = $commentRoot.siblings('.comment').html(),
                commentTruncated = $commentRoot.data('comment'),
                tags = $commentRoot.data('tags');

            // helpers
            function displaySection(section) {
                $('#wrapper-edit > section, .modal-content > section').css('display', 'none');
                $('.' + section).css('display', 'block');
            }

            function formSubmit($el) {
               $.ajax({
                   url:$el.attr('action'),
                   type: "POST",
                   dataType: "json",
                   data: $el.serialize(),
                   success: function( r ){
                       if( r._success ){
                           cancel();
                           window.location.reload();
                       }
                   }
               });
            };

            function cancel() {
                SU.Modal.close();
            };

            function switchMode($el, e) {
                displaySection($el.data('action'));
            };

            function setCaret(field, index) {
                if (field.setSelectionRange) {
                    field.setSelectionRange(index, index);
                } else if (field.createTextRange) {
                    var range = field.createTextRange();
                    range.collapse = true;
                    range.moveEnd('character', index);
                    range.moveStart('character', index);
                    range.select();
                }
            };

            // set modal content and show
            $('#comment-target').html(commentTruncated);
            $('#your-comment').html(comment);
            $('#your-tags').html(tags);
            $('#commentid-add').val(commentId);
            $('#commentid-delete').val(commentId);
            displaySection(action);

            if (!this._modalEvents) {
                this._modalEvents = true;
                SU.Modal.bindEvents({
                    "submit form": formSubmit,
                    "click .cancel": cancel,
                    "click .switch-mode": switchMode
                });
            }

            SU.Modal.load("#wrapper-edit").open({
                ready:function() {
                    var index = comment.length,
                        $field;
                    if (action == 'comment-edit') {
                        $field = SU.Modal.$el.find('textarea').first();
                        $field.focus();
                        setCaret($field[0], index);
                    }
                }
            });
        },

        unlike: function(model, e) {
            e.stopPropagation();
            model.set("isliked", false);
        },

        statusChange: function(model) {
            Sync("/su/api/action").update({
                "_token": _token,
                "action": "simple-rate",
                "src": "website",
                "rating": ( model.get("isliked") ? 1 : -1 ),
                "pid": model.get("id")
            }).success(function(){
                model.$el.addClass("s-stumble-unliked");
            });
        },

        share: function(model, e) {
            e.stopPropagation();
            SU.Modal.loadURL("/su/overlay/share/?pid=" + model.get("id") + "&src=website", {iframe:true, wrapperClass: "share-panel-modal"}).open();
        },

        stumble: function(model, e) {
            e.stopPropagation();

            SU.ToolbarAction.stumble(model.toJSON());
        },

        info: function($el, e) {
            e.stopPropagation();
            // Log some analytics stuff here
            window.location = $el.attr("href");
        },

        filterChangeView: function($el) {
            this.filter.set("view", $el.data("view"));
        },

        userUpdateViewSettings: function(filter) {
            // update the user's preference
            var data, tokenObj = {};
            tokenObj[_viewtoken.name] = _viewtoken.token;
            data = extend(
                { "view": filter.get("view") },
                tokenObj
            );

            Sync("/changeview").update(data);
        },

        filterChangeShow: function($el) {
            this.filter.set("show", $el.val());
        },

        filterChangeCategory: function($el) {
            this.filter.set("category", $el.val());
        },

        filterShowUpdated: function(filter) {
            this.route.navigate( filter.get("show") );
        },

        filterCategoryUpdated: function(filter) {
            this.route.navigate( filter.get("category") );
        }
    });

    SU.addInit("mStumbles", function(config){
        new SU.Stumbles(config);
    });

    SU.addInit("setStumbleToken", function(token){
        _token = token;
    });

    SU.addInit("setViewToken", function(token){
        _viewtoken = token;
    });
}).call(this);
(function(){
    SU.addInit("mCardModal", function(config){
        $('#content').on('click','.user-detail', function(e){
            e.preventDefault();
            // SU.Modal is instantiated by webtb
            SU.Modal.load("#"+$(e.target).data('contentid')).open();
        });
    });
}).call(this);
(function(){
    var _followingInit = false;

    var FollowStatus = Base.Model.extend({
        initialize: function() {
            var curStatus = this.get("status"),
                newStatus = false;

            if (curStatus == 1) {
                newStatus = "follow"
            }
            else if (!curStatus) {
                newStatus = "unfollow";
            }

            if (newStatus) {
                this.set("status", newStatus, {silent:true});
            }
        },


        buildRequestURL: function() {
            return "/follow/" + this.get("type");
        },

        getData: function() {
            var data,
                tokenObj = {};

            switch (this.get("type")) {
                case "stumbler":
                    tokenObj[this._config.tokenName] = this._config.tokens.stumbler;
                    data = extend(
                        {"userid":this.get("id"), "status":this.get("pending-status")},
                        tokenObj
                    );
                    break;

                case "interest":
                    tokenObj[this._config.tokenName] = this._config.tokens.interest;
                    data = extend(
                        {"interest":this.get("id"), "status":this.get("pending-status")},
                        tokenObj
                    );
                    break;

                case "channel":
                    tokenObj[this._config.tokenName] = this._config.tokens.channel;
                    data = extend(
                        {"channel":this.get("id"), "status":this.get("pending-status")},
                        tokenObj
                    );
                    break;
            }

            return data;
        },

        save: function() {
            var sync = Sync( this.buildRequestURL() ),
                requestMethod = "create";

            if (this.get("pending-status") == "unfollow") {
                requestMethod = "update";
            }

            return sync[requestMethod]( this.getData() );
        }
    });

    var FollowEntities = Base.Collection.extend({
        model: FollowStatus
    });


    var FollowView = Base.View.extend({
        toggleStatus: function(model) {
            var elementIsButton = model.$el.hasClass("button-follow"),
                classToRemove,
                classToAdd;

            if (model.get("status") == "follow") {
                classToRemove = "follow";
                classToAdd = "following";
            } else {
                classToRemove = "following";
                classToAdd = "follow";
            }

            if (!elementIsButton) {
                model.$el.find(".button-follow").removeClass(classToRemove).addClass(classToAdd);
            } else {
                model.$el.removeClass(classToRemove).addClass(classToAdd);
            }
        }
    });


    SU.Following = Base.Controller.extend({
        initialize: function(config) {
            config = config || {};
            this.$el = $("#content");
            this.view = new FollowView(this);
            this.collection = new FollowEntities(this);
            this.collection.model.prototype
                .bind("change:pending-status", this.statusChanged, this)
                .bind("change:status", this.view.toggleStatus);
            this.collection.model.prototype._config = config;

            this.bindEvents(this.collection, {
                "press .button-follow.follow": "follow",
                "press .button-follow.following": "unfollow"
            });
        },

        follow: function(model) {
            model.set("pending-status", "follow");
        },

        unfollow: function(model) {
            model.set("pending-status", "unfollow");
        },

        statusChanged: function(model) {
            var self = this;


            model.save()
                .success(function(data, textStatus, jqXHR) {
                    if (SU.Captcha.isRequired(data)) {
                        SU.Captcha.show(function(){
                            self.statusChanged(model);
                        });
                        return;
                    }

                    if (data._success === true) {
                        model.set("status", model.get("pending-status"));
                        // If we have new interests, then update the toolbar
                        if (data.interests)
                            SU.ToolbarAction.updateTopics(data.interests);
                    } else {
                        model.set("pending-status", "", {silent:true});
                        if (data._error != "") {
                            alert(data._reason[0].message);
                        }
                    }
                })
                .error(function(jqXHR, textStatus, errorThrown){
                    model.set("pending-status", "", {silent:true});

                    if (errorThrown == "Unauthorized") {
                        self.unauthorizedRequest({
                            source: "follow_" + model.get("type"),
                            id: model.get("id")
                        });
                    }
                });
        }
    });

    SU.addInit("mFollow", function(config){
        if (!_followingInit) {
            new SU.Following(config);
            _followingInit = true;
        }
    });
}).call(this);
(function(){
    var Router = Base.Router.extend({
        pattern: "stumbler/(:username)/connections/?(:show)?",
        pagination: true
    });

    SU.Connections = Base.Controller.extend({
        initialize: function(config) {
            this.$el = $("#content");
            this.view = new Base.View(this);
            this.route = new Router(this);

            this.filter = new Base.Model({
                "show": "all"
            });

            this.filter.bind("change:show", this.filterShowUpdated, this);

            this.bindEvents({
                "change .stumbles-filter select": "filterChangeShow"
            });
        },

        filterChangeShow: function($el) {
            this.filter.set("show", $el.val());
        },

        filterShowUpdated: function(filter) {
            this.route.navigate( filter.get("show") );
        }
    });

    SU.addInit("mConnections", function(config){
        new SU.Connections(config);
    });
}).call(this);(function(){
    SU.addInit("mStumbleButton", function(){
        $body.delegate(".stumble-button", press, function(e){
            e.preventDefault();
            SU.ToolbarAction.stumble( $(this).data() );
        });
    });
}).call(this);(function(){
/**
 * State Model
 */
var state = Base.Model.extend({
    defaults: {
        "keyword": "",
        "typed-keyword": "",
        "index": -1
    },

    getTypedKeyword: function() {
        var typedKeyword = this.get("typed-keyword") || ""; // Always needs to at least return an empty string;
        // Remove tabs, spaces, line breaks and trim
        return typedKeyword.replace( /[\s\n\r\t]+/g, " " ).replace(/^\s*([\S\s]*?)\s*$/, "$1");
    }
});


/**
 * Result model
 */
var result = Base.Model.extend({
    idAttribute: "index",

    defaults: {
        label: null,
        matchesInput: false
    },

    getKeyword: function() {
        return this.get("label");
    }
});


/**
 * Results Collection
 */
var results = Base.Collection.extend({
    model: result,

    getByIndex: function(index) {
        var model = this.models[index];
        return model ? model : false;
    },

    /**
     * Get the keyword from the specified index offset
     *
     * @param index
     */
    getKeywordFromIndex: function(index) {
        var model = this.getByIndex(index);

        return model ? model.getKeyword() : false;
    }
});


/**
 * Cache Collection
 */
var CacheIndex = function(config){
    this._keywords = [];
    this._resultsByKeyword = {};
    this._keywordIndexPositions = {};
    this._keywordAdded = {};
    this._limit = config.limit || 50;
    this._expires = config.expires || 3600000; // Milliseconds: 1 hour default, use 0 to disable
    this._total = 0;
    return this;
};

extend(CacheIndex.prototype, {
    addResults: function(keyword, results) {
        this._keywords.push(keyword);
        this._resultsByKeyword[keyword] = results;
        this._keywordIndexPositions[keyword] = this._total++; // Assign the index value and update the total after
        this._keywordAdded[keyword] = (new Date).getTime();

        if (this._total > this._limit) {
            this.purgeOldResults();
        }

        return this;
    },

    get: function(keyword) {
        var results = this._resultsByKeyword[keyword];

        if (!results) {
            return false;
        }

        if (this._expires > 0) {
            var curTime = (new Date).getTime();

            if ((curTime - this._keywordAdded[keyword]) >= this._expires) {
                this.remove(keyword);
                return false;
            }
        }

        return results;
    },

    remove: function(keyword) {
        var index = this._keywordIndexPositions[keyword];
        this._keywords.splice(index, 1);
        delete this._resultsByKeyword[keyword];
        delete this._keywordIndexPositions[keyword];
        delete this._keywordAdded[keyword];
        this._total--;
    },

    purgeOldResults: function() {
        this.remove( this._keywords[0] );
    }
});


var CacheLibrary = {
    createIndex: function(config) {
        if (!this[config.instance]) {
            this[config.instance] = new CacheIndex(config || {});
        }

        return this[config.instance];
    }
};


/**
 * View
 */
var view = Base.View.extend({

    initialize: function() {
        var self = this;

        this.$input = this.$el;

        var placeholderText = this.$input.attr("placeholder");

        if(!Browser.supports("placeholder")) {
            this.$input.val( this.$input.attr("placeholder") ).addClass("ac-placeholder");

            this.$input
                .focus(function() {
                    if (self.$input.val() == placeholderText) {
                        self.$input.val("").removeClass("ac-placeholder");
                    }
                })
                .blur(function() {
                    if (self.$input.val() == "") {
                        self.$input.val(placeholderText).addClass("ac-placeholder");
                    }
                });
        }
    },

    $resultsContent: function() {
        if (!this._resultsContent) {
            this._resultsContent = this.$results.find(".ac-results-content");
            this._initialResultsHTML = this._resultsContent.html();
        }
        return this._resultsContent;
    },

    /**
     * Render results
     */
    renderResults: function(collection) {
        var html = "",
            results = collection.models;


        this.trigger("results:before");


        html += "<ul class='ac-results'>";

        for (var i=0, result; result=results[i]; i++) {
            var heading = result.get("heading");

            if (heading) {
                if (i > 0) {
                    html += '</ul>';
                }

                html += "" +
                    "<h6 class='ac-results-heading'>" + heading + "</h6>" +
                    "<ul class='ac-results'>";
            }

            html += "<li><a href='#' data-index='" + i + "'";

            if (result.get("highlight")) {
                html += " class='s-ac-selected'";
            }

            html += ">" + result.get("matchedText") + "</a></li>";
        }

        html += "</ul>";

        this.$resultsContent().html( this._initialResultsHTML + html);

        if (results.length === 0) {
            this.noResults();
        }

        this.trigger("results:after");
    },

    noResults: function() {
        this.$results.find(".ac-no-results").show();
    },

    keywordChanged: function(state) {
        this.$input.val( state.get("keyword") );
    },


    indexChanged: function(state) {
        var index = state.getInt("index");
        this.$resultsContent().find(".s-ac-selected").attr("class", "");

        if (index > -1) {
            this.$results.find("[data-index=" + index + "]").addClass("s-ac-selected");
        } else {
            state.set("keyword", state.get("typed-keyword"));
        }
    },

    scrollElementIntoView: function() {
        this.$scrollTarget[0].scrollIntoView();
    },

    toggleLoading: function(state) {
        if (state.get("loading")) {
            this.$input.addClass("s-ac-loading");
        } else {
            this.$input.removeClass("s-ac-loading");
        }
    },

    toggleFocus: function(state) {
        if (state.get("focused")) {
            this.$input.focus();
        } else {
            if (!Browser.supports("touch")) {
                state.set("open", false);
            }
        }
    },

    toggleResultsDisplay: function(state) {
        var self = this,
            typedKeyword = state.get("typed-keyword");


        if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }

        if (state.get("open")) {
            this.$results.show();
        } else {

            if (typedKeyword && typedKeyword.length > 1) {
                this._hideTimeout = setTimeout(function(){
                    self.$results.hide();
                }, 400);
            } else {
                self.$results.hide();
            }
        }
    }
});




/**
 * Controller
 */
Base.Autocomplete = Base.Controller.extend({
    _lastRequest: 0,
    _timer: null,

    _settings: {
        "delay": 100,
        "auto_focus": false
    },

    // Base initialize
    initialize: function(config) {
        var self = this;
        extend(this._settings, config);

        this._instanceId = ".autocomplete-" + config.id;

        this.state = new state;
        this.view = new view(this);

        this.results = new results(this);
        this.results.bind("reset", this.view.renderResults, this.view);

        this.cache = CacheLibrary.createIndex({instance:this.cacheId});

        this.state
            .bind("change:keyword", this.view.keywordChanged, this.view)
            .bind("change:typed-keyword", this.typedKeywordChanged, this)
            .bind("change:index", this.view.indexChanged, this.view)
            .bind("change:index", self.indexChanged, this)
            .bind("change:focused", this.view.toggleFocus, this.view)
            .bind("change:open", this.view.toggleResultsDisplay, this.view);

        if (config.showLoadingState !== false) { // Passes if `undefined` or `true`
            this.state.bind("change:loading", this.view.toggleLoading, this.view);
        }

        /*
         * Remove the loading class when the page unloads, otherwise the user could navigate back in their history and
         * the loading icon will still be animating.
         */
        $(window).bind("unload" + this._instanceId, function(){
            try {
                self.state.set("loading", "off");
            } catch(e) {
                // Don't break
            }
        });


        // Scroll a specific target back into view when device orientation changes
        if (this._settings.scrollTargetSelector && Browser.supports("orientationChange")) {
            this.view.$scrollTarget = $(self._settings.scrollTargetSelector);
            this.state.bind("change:orientation", this.view.scrollElementIntoView, this.view);
            window.onorientationchange = function() {
                self.state.trigger("change:orientation");
            };
        }


        this.bindEvents({
            "keyup": "keyInput",
            "blur": "blur"
        });


        this.$results = $(this._settings.resultsSelector);
        // Pass this selector onto the view
        this.view.$results = this.$results;


        this.$results
            .delegate("a", "click", function(e){
                e.preventDefault();
                self.selectResult( $(this).data("index") );
            })
            .delegate("a", "hover", function(e){
                self.setIndex( $(this).data("index") );
            });


        if (this._settings.auto_focus) {
            this.state.set("focused", true);
        }

        this.init(config);
    },

    indexChanged: function(event, data, newIndex) {
        if (newIndex > -1)
            this.state.set("keyword", this.results.getKeywordFromIndex(newIndex));
        else
            this.state.set("keyword", this.state.get("typed-keyword"));
    },

    typedKeywordChanged: function(state) {
        var curVal = state.getTypedKeyword();

        if (curVal && curVal.length > 1) {
            this.queueRequest();
        } else {
            this.state.set("open", false);
            this.results.reset();
        }
    },


    /**
     * Keypress handler
     */
    keyInput: function($this, e) {
        var index = this.state.getInt("index"),
            newIndex = false,
            newKeyword = false,
            lastIndex = this.results.length - 1,
            typedKeyword = this.state.get("typed-keyword") || "";


        lastIndex = lastIndex > -1 ? lastIndex : 0;
        this.state.set("loading", false);

        if (e.which != 13 && e.which != 38 && e.which != 40) {
            var value = $this.val();

            if (value != typedKeyword) {
                this.state.set("typed-keyword", value);
            }
            return;
        }

        if (e.which === 13 /*Enter*/) {
            this.submit();
            return;
        }

        // If there are no results or the list isn't open, don't bother trying to cycle through it.
        if (!this.results.models.length || !this.state.get("open")) {
            return;
        }

        if (e.which === 38 /*Up*/) {
            newIndex = index > -1 ? index - 1 : lastIndex;
        }
        if (e.which === 40 /*Down*/) {
            newIndex = index != lastIndex ? index + 1 : -1;
        }

        if (newIndex !== false)
            this.state.setInt("index", newIndex);
    },


    blur: function() {
        this.state.set("focused", false);
    },


    /**
     * Submit
     */
    submit: function() {
        var index = this.state.getInt("index");

        if (index === -1) {
            var result = this.results.getByIndex(0);
            if (result && result.get("matchesInput") === true) {
               this.state.setInt("index", 0);
                this._resultSelected(0);
            } else {
                this.view.noResults();
            }
        } else {
            // .resultSelected is a method that should exist within the object that extends Base.Autocomplete
            this._resultSelected(index);
        }
    },

    setIndex: function(index) {
        this.state.setInt("index", index);
    },

    /**
     * Select an item from the result list
     */
    selectResult: function(index){
        var model = this.results.getById(index);

        this.state.trigger("change:orientation");
        this.state.set("keyword", model.get("label"));

        this.submit();
    },


    /**
     * Queue a lookup request to the server
     */
    queueRequest: function() {
        var toDelay = this._settings.delay,
            curTime = (new Date).getTime(),
            timeDiff = (curTime - this._lastRequest),
            self = this;

        if (timeDiff < this.delay) {
            toDelay = this.delay - timeDiff;
        }

        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
        }

        this._timer = setTimeout(function(){
            self.sendRequest();
        }, toDelay);
    },



    /**
     * Send the request to the server
     */
    sendRequest: function(){
        var self = this,
            keyword = this.state.getTypedKeyword(),
            cache = this.cache.get(keyword);

        this._lastRequest = (new Date).getTime();

        if (this._requestProcessing) {
            this._requestProcessing.abort();
        }


        if (cache) {
            self.state.setInt("index", -1);
            self._prepareData(cache);
            this._requestProcessing = null;
            return;
        }

        this._requestProcessing = this.sync.create(
            // Data
            {
                "q": keyword,
                "_token": this._settings._token
            },

            // Ajax params
            {
                cache: false,
                success: function(response){
                    self._lastRequest = (new Date).getTime();

                    if (response._success) {
                        self.state.setInt("index", -1);
                        self._prepareData(response.data);
                        self.cache.addResults(keyword, response.data);
                    }
                },
                error: function(){
                    //$todo
                }
            }
        );
    },


    _prepareData: function(data) {
        var hasResults = false,
            results = [],
            index = 0;


        if (!data.categories || data.categories && data.categories.length > 0) {
            this.results.reset();
        }

        /*
         * Create the regex pattern from the user's input
         */
        var pattern = this.state.getTypedKeyword().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");


        for (var c = 0, category; category = data.categories[c]; c++) {
            // Loop through the results under each category
            for (var r = 0, result; result = category.keywords[r]; r++) {
                result.index = index;
                if (r === 0 && category.label != "default") {
                    result.heading = category.label;
                }

                if (result.highlight) {
                    result.matchesInput = true;
                }


                var regexObj = new RegExp(pattern, "ig");
                var replaceWith = regexObj.exec(result.label);
                result.matchedText = result.label.replace(regexObj, "<strong>"+replaceWith+"</strong>");

                results.push(result);
                index++;
            }
        }

        this.results.reset(results);
        this.state.set("open", true);
    },

    _resultSelected: function(index) {
        this.state.set("loading", true);
        this.resultSelected( this.results.getByIndex(index) );
        this.state.set("open", false);
    }
});
}).call(this);
(function(){
    function resultsTemplate(id) {
        return "" +
        "<div class='ac-results-wrap' id='" + id + "'>" +
            "<div class='ac-results-content'>" +
                "<div class='ac-no-results explore-no-results'>" +
                    "<h6>No Results Found.</h6>" +
                    "<p>Please try exploring another interest.</p>" +
                "</div>" +
            "</div>" +
        "</div>";
    }


    function exploreBoxInit(config) {
        config.selector = "#" + config.id;

        var isWebToolbar = (config.id == "tb-explore-box"),
            resultsId = config.id + "-results-wrap";

        config.resultsSelector = "#" + resultsId;


        if (isWebToolbar) {
            $body.append( resultsTemplate(resultsId) );
        } else {
           $(config.selector).after( resultsTemplate(resultsId) );
        }

        var ExploreBox = Base.Autocomplete.extend({
            selector: config.selector,

            cacheId: "ExploreBox",

            restURL: "/autocomplete/keyword",

            init: function() {
                if (isWebToolbar && config.client == 'chromebar') {
                    this.view.bind("results:after", this.openAutoCompleteOverlay);
                    this.state.bind("change:keyword", this.openAutoCompleteOverlay);
                }
            },

            openAutoCompleteOverlay: function()
            {
                if ($(config.resultsSelector + ' .ac-results-content ul'))
                    var w = $(config.resultsSelector + ' .ac-results-content ul').width();
                else
                    var w = $(config.resultsSelector + ' .ac-results-content').width();

                SU.WebToolbar.overlayManager.openOverlay('keyword-autocomplete', {
                    data: "<div id='" + resultsId + "'>" + $(config.resultsSelector).html() + "</div>",
                    type: 'floating',
                    anchorElement: $('#' + config.id),
                    size: {width: w, height: $(config.resultsSelector).height()},
                    closeOthers: ['floating', 'notification'],
                    refresh: true
                })
            },

            resultSelected: function(model) {
                var data = model.toJSON();
                var mode = {};
                mode.contextual = data.label;

                // TODO: remove this, because the server should send the correct data
                if (data.mode == 'topic')
                {
                    mode.mode = 'topic';
                    mode.topic = data.topicid;
                }
                else
                {
                    mode.mode = 'tag';
                    mode.q = data.label;
                }
                SU.ToolbarAction.stumble(mode);
            }
        });

        SU.ExploreBox = new ExploreBox(config);
    }

    SU.addInit("mExploreBox", function(config){
        // config.scrollTargetSelector = '.explore-interests h2';
        exploreBoxInit(config);
    });

    SU.addInit("mExploreBoxWebToolbar", function(config){
        exploreBoxInit(config);
    });
}).call(this);(function(){
    var Router = Base.Router.extend({
        pattern: "stumbler/(:username)/channels/?(:show)?",
        pagination: true
    });

    SU.Channels = Base.Controller.extend({
        initialize: function(config) {
            this.$el = $("#content");
            this.view = new Base.View(this);
            this.route = new Router(this);

            this.filter = new Base.Model({
                "show": "all"
            });

            this.filter.bind("change:show", this.filterShowUpdated, this);

            this.bindEvents({
                "change .stumbles-filter select": "filterChangeShow"
            });
        },

        filterChangeShow: function($el) {
            this.filter.set("show", $el.val());
        },

        filterShowUpdated: function(filter) {
            this.route.navigate( filter.get("show") );
        }
    });

    SU.addInit("mChannels", function(config){
        new SU.Channels(config);
    });
}).call(this);(function(){
    SU.flagModal = new Base.Modal();
    SU.FlagItem = function(config){
        var $flagTrigger = $('#flag-item'),
            flagUrl = null,
            modalClass = config.modalClass || 'flag-stumbler';

        $flagTrigger.click(function(e){
            e.preventDefault();
            flagUrl = $flagTrigger.data('flagitem');
            SU.flagModal.loadURL(flagUrl, {iframe:true, wrapperClass: modalClass}).open();
        });
    };
    SU.addInit("mFlagItem", function(config){
        new SU.FlagItem(config);
    });
}).call(this);
/**
 * ajax content load
 *
 *
 * @author jeichorn
 */
(function(){
    SU.AjaxContentLoader = function(){
        this.$target = null;
        this.ajaxData = {};
        this.url = '';
    };
    SU.AjaxContentLoader.prototype = {
        setData : function(data){
            this.$target = $(data.target);
            this.url = data.url;
            this.ajaxData._token = data._token;
            this.ajaxData._nohead = "true";
            this.ajaxCall();
        },
        insert : function(content){
            this.$target.html(content);
        },
        showLoader : function(){
            var markup = '<div class="wrapper-loading"></div>';
            this.$target.append(markup).addClass('s-loading');
        },
        hideLoader : function(){
            this.$target.addClass('s-load-complete').removeClass('s-loading').find('.wrapper-loading').remove();
        },
        ajaxCall : function(){
            var self=this;
            self.showLoader();
            $.ajax({
                url: this.url,
                type: "GET",
                dataType: "html",
                data: self.ajaxData,

                complete: function() {
                    self.hideLoader();
                //called when complete
                },

                success: function(r) {
                    self.insert(r);
                },

                error: function() {
                }
            });
       }

    };
    SU.addInit("mAjaxContentLoader", function(configs) {
        var ajaxContentLoader;
        for(var i=0, ii=configs.length; i<ii; i++){
            ajaxContentLoader = new SU.AjaxContentLoader();
            ajaxContentLoader.setData(configs[i]);
        }
    });
}).call(this);
