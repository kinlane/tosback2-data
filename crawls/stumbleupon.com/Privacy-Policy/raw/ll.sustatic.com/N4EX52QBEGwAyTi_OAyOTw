/**
 * Global form handler
 *
 * Use for form validation
 *
 * @author jrylan
 */

/*
 How to use this code:

 $(function(){
    var test = new Base.FormHandler.extend({
        selector: $('.form'),

        restURL: "blah",

        // If you provide a `submit` callback, it's boolean return value will
        // determine if the ajax validation request should be should be processed.
        submit: function() {
            if (doSomething) {
                return true;
            }
            return false;
        },

        inputs: [
            {
                id: "text1",
                validateUrl: "foo1.php",
                validateOn: "blur",
                validate: function() {
                    this.ajaxValidation();
                }
            }
        ]
    });
});
*/

(function() {
    /*
     * Setup the view
     */
    var view = Base.View.extend({
        initialize: function() {
            this.$error = this.$el.find(".alert-message");
            this.$errorMsg = this.$error.find("p");
        },

        showTopLevelErrors: function(collection) {
            if (!this.$error || collection.submitted !== true) {
                return;
            }

            if (collection.formErrors) {
                this.$errorMsg.html( collection.formErrors.join("<br>") );
            } else {
                this.$errorMsg.html( this.$errorMsg.data("original") );
            }

            this.$error.removeClass("hide");
        },

        hideTopLevelErrors: function() {
            this.$error.addClass("hide");
        },

        toggleStatus: function(model) {
            var status = model.get("status");

            if (status == "success") {
                model.$wrap.removeClass("error").addClass("success");
            }
            else if (status == "error" || status == "error-soft") {
                model.$wrap.removeClass("success").addClass("error");
            }
            else {
                model.$wrap.removeClass("success").removeClass("error");
            }
        },

        setErrorMessage: function(model) {
            var errors = model.get("errors");

            if (typeof errors != "string") {
                errors = errors.join("<br>");
            }

            model.$wrap.find(".s-error").html(errors);
        },

        setActive: function($el) {
            $el.parents(".wrapper-input").addClass("active");
        },

        setInactive: function($el) {
            $el.parents(".wrapper-input").removeClass("active");
        }
    });



    /*
     * Setup the model
     */
    var input = Base.Model.extend({
        defaults: {
            active: false,
            error: false
        },

        initialize: function() {
            var self = this;

            if (this.attributes.type != "radio") {
                this.$el = $("#" + this.id);
                this.$el.data("__id__", this.id);

                this.$wrap = this.$el.parents(".wrapper-input");
                this.type = (this.$el.attr("type") || this.$el[0].tagName).toLowerCase();
                if (this.type == "input") {
                    this.type = "text";
                }

                this.name = (this.$el.attr("name") || this.id);

                if (this.attributes.validateOn) {
                    this.$el.bind(this.attributes.validateOn, function(e){
                        self.set("value", self.getValue());
                        self.inputValidation(e);
                    });
                }

                if (this.get("active")) {
                    self.$el.focus();
                    this.set("active", true);
                }
            } else {
                this.name = this.id;
                this.type = "radio";
                this.$wrap = $("input[name=" + this.name + "]:first").parents(".wrapper-input");
            }

            var val = this.getValue();

            this.set({
                "value": val,
                "initValue": val,
                "lastValue": val
            }, {silent:false});
        },

        ajaxValidation: function() {
            var self = this,
                value = this.getValue(),
                data = {},
                params = {
                    dataType: "json"
                };

            data[this.name] = value;

            if (typeof this.attributes.validationData == "function") {
                extend(data, this.attributes.validationData(this.collection));
            }

            return Sync(this.attributes.validationURL).update(data, params)
                .success(function(data) {
                    if (typeof data._success == "undefined") {
                        return;
                    }

                    if (data._success === true) {
                        self.set("status", "success");
                    } else {
                        if (data._reason && data._reason.length > 0) {
                            var reasons = [];
                            for (var i=0, reason; reason=data._reason[i]; i++) {
                                reasons.push(reason.message);
                            }
                            self.set("errors", reasons);
                        }
                        self.set("status", "error");
                    }
                })
                .error(function() {
                    //alert("error");
                });
        },

        getValue: function(){
            switch(this.type) {
                case "checkbox":
                    return this.$el.is(":checked");
                    break;

                case "radio":
                    return $("input[name=" + this.id + "]:checked").val();
                    break;

                default:
                    var value = this.$el.val();
                    return value ? value : "";
            }
        },

        hasChanged: function() {
            return (this.getValue() != this.get("initValue"));
        },

        inputValidation: function(e) {
            var self = this,
                value = this.getValue();

            if (!value) {
                return;
            }
            if (!this.attributes.validate) {
                this.ajaxValidation();
            } else {
                this.attributes.validate.call(this);
            }
        },

        removeErrorIfNotEmpty: function() {
            if (this.value != "") {
                this.set("status", "success");
            }
        },

        updateInitValue: function() {
            this.set("initValue", this.getValue());
        }
    });


    /*
     * Setup the collection of models
     */
    var inputs = Base.Collection.extend({
        submitted: false,

        model: input,

        initialize: function() {
            this.totalErrors = 0;
        },

        recordStatusChange: function(model) {
            var status = model.get("status"),
                prevStatus = model._previousAttributes.status;

            if (status == "error-soft") {
                return;
            }
            else if (status == "error") {
                this.totalErrors++;
            }
            else if (prevStatus) {
                this.totalErrors--;
            }
        },

        updateInitValues: function() {
            for (var id in this._byId) {
                this.getById(id).updateInitValue();
            }
        }
    });



    Base.FormHandler = Base.Controller.extend({
        method: "update",

        useAjaxFieldValidation: true,

        initialize: function(config) {
            var self = this;

            this.view = new view(this);

            var collection = new inputs(this);

            collection.model.prototype
                .bind("change:status", this.view.toggleStatus)
                .bind("change:status", collection.recordStatusChange, collection)
                .bind("change:errors", this.view.setErrorMessage, this.view);

            this.bindEvents({
                "submit": "_submit",
                "press .submit": "_submit",
                "press .cancel": "cancel",
                "press .alert-message .close": "closeMessage"
            });

            if (this.highlightLabels) {
                $("input,select,textarea", this.$el)
                    .live("focus", function(e){
                        view.prototype.setActive( $(this) );
                    })
                    .live("blur", function(e){
                        view.prototype.setInactive( $(this) );
                    });
            }

            // Changes the provided `inputs` property into an accessible collection
            this.inputs = collection.add(this.inputs, {silent:true});
            if (!this.formData) {
                this.formData = this._formData;
            }

            this.init(config);
        },

        init: function(config) {},

        closeMessage: function() {
            this.view.hideTopLevelErrors();
        },

        _formData: function(options) {
            options = options || {};
            var getAllFields = options.fields != "changed" || false;

            var data = {},
                id,
                model,
                total = 0;

            for (id in this.inputs._byId) {
                model = this.inputs.getById(id);

                if (getAllFields || model.attributes.persist || model.hasChanged()) {
                    data[model.name] = model.getValue();
                    total++;
                }
            }

            $("input[type=hidden]", this.$el).each(function(){
                var $this = $(this);
                data[$this.attr("name")] = $this.val();
            });

            return total ? data : false;
        },

        cancel: function() {
            this.$el[0].reset();
        },

        _submit: function() {
            var formData = this.formData();

            if (!formData) {
                return false;
            }

            if (this.submit) {
                if (this.submit(formData)) {
                    this.ajaxSubmit(formData);
                }
            } else {
                this.ajaxSubmit(formData);
            }
        },

        ajaxSubmit: function(formData) {
            var self = this;

            if (this._submitInProcess) {
                return;
            }

            this._submitInProcess = true;
            this.inputs.submitted = true;
            this.inputs.formErrors = false;

            return self.sync[self.method](formData)
                .success(function(data, textStatus, jqXHR) {
                    if (SU.Captcha.isRequired(data)) {
                        self._submitInProcess = false;
                        self.inputs.submitted = false;
                        SU.Captcha.show(function(){
                            self.ajaxSubmit(formData);
                        });
                        return;
                    }

                    self._submitInProcess = false;
                    if (data._success === true && self.success) {
                        self.inputs.updateInitValues();
                        self.success(data, textStatus, jqXHR);
                    }
                    else if (self.failure) {
                        self.failure(data, textStatus, jqXHR);
                    }
                    else {
                        self.inputs.totalErrors = 0;

                        if (data._reason) {
                            if (Utils.isArray(data._reason)) {
                                var reasons = [];
                                for (var i=0, reason; reason=data._reason[i]; i++) {
                                    if (reason.meta && reason.meta.field) {
                                        var model = self.inputs.getById(reason.meta.field);
                                    }
                                    if (model) {
                                        model.set("status", "error");
                                        model.set("errors", reason.message);
                                    } else {
                                        reasons[reasons.length] = reason.message;
                                    }
                                }
                                self.inputs.formErrors = reasons;
                                self.view.showTopLevelErrors(self.inputs);
                            }
                        }
                    }
                })
                .error(function(jqXHR, textStatus, errorThrown) {
                    self._submitInProcess = false;
                    if (self.error) {
                        self.error(jqXHR, textStatus, errorThrown);
                    }
                });
        }
    });
}).call(this);/*

How to use this code:

NAMESPACE.Modal = new Base.Modal(OPTIONS_OBJECT);

1. Load content for a specific selector on the page:
NAMESPACE.Modal.load("#some-content").open();

2. Load content from a specific URL
NAMESPACE.Modal.loadURL("http://www.google.com/").open();

3. Load content from a specific URL in an iframe:
NAMESPACE.Modal.loadURL("http://www.google.com/", {iframe:true}).open();

4. Set the HTML content directly:
NAMESPACE.Modal.set("<h1>Blah</h1>").open();

5. When calling the `open` method, you can pass a configuration object:
"ready" - Function to execute when the content has been set

"close:before" - Function to execute when the user tries to close the modal. Must return a boolean value -- returing `true` will close the modal.

"close:after" - Callback function to execute when the modal has closed.

"close:overlay" - Boolean to denote if the user should be able to click on the overlay to close the modal.

Sample config:
{
    "ready": function() {
        console.log("Your content is ready");
    },
    "close:before": function(){
        return confirm("Are you sure you want to close this?");
    },
    "close:after": function(){
        alert("you closed the modal!");
    },
    "close:overlay": false
}

*/


(function() {
    "use strict";
    /*
     * Setup the view
     */
    var _view = Base.View.extend({
        initialize: function() {
            this.$content = this.$el.find(".modal-content");
        },


        load: function(selector) {
            this.ready = false;

            if (selector) {
                var $selector = selector instanceof $ ? selector : $(selector);
                this.$content.html( $selector.html() );
            }

            this.measureHeight().positionContent();
        },

        loadURL: function(url, settings) {
            this.ready = false;
            var view = this,
                $iframe;

            if (settings.wrapperClass) {
                this.$content.addClass(settings.wrapperClass);
            }

            if (settings.iframe) {
                this.$content.html("<iframe src=" + url + " frameborder=0 class=modal-iframe>");
                $iframe = this.$content.find("iframe");
                view.measureHeight().positionContent();
                view.insertLoading(settings.loadingMessage);
                $iframe.bind("load", function(){
                    view.measureHeight().positionContent();
                    view.removeLoading();
                });
            } else {
                $.get(url, function(response){
                    view.set(response);
                    view.measureHeight().positionContent();
                });
            }
        },


        set: function(str) {
            this.ready = false;
            this.$content.html(str);
            this.measureHeight().positionContent();
        },

        measureHeight: function() {
            // The display property of the element has to be set to something other than `block` in order to measure it's height.
            this.$el.css({"visibility":"hidden", "display":"block"});
            var _height = "" + this.$content.height();
            this._height = _height;
            this.$el.css({"visibility":"", "display":""});
            return this;
        },

        positionContent: function() {
            var modalHeight = this._height,
                windowHeight = $win.height(),
                topOffset;

            if (modalHeight < windowHeight) {
                this.$el.css("position", "fixed");
                topOffset = Math.ceil( (windowHeight - modalHeight) / 2) - ( (20 / modalHeight) * 100);
            } else {
                this.$el.css("position", "absolute");
                topOffset = Math.ceil( $win.scrollTop() + 25 );
            }

            this.$el.css("top", topOffset);
            this.ready = true;
            this.trigger("ready");

            return this;
        },


        changeStatus: function(model) {
            if ("open" == model.get("status")) {
                this.$overlay.addClass("modal-open");
                this.$el.addClass("modal-open");
            } else {
                this.$overlay.removeClass("modal-open");
                this.$el.removeClass("modal-open");
            }
        },

        toggleCloseButton: function(status) {
            if (status) {
                this.$el.addClass("modal-hide-close");
            } else {
                this.$el.removeClass("modal-hide-close");
            }
        },

        insertOverlay: function() {
            $body.append("<div id=modal-overlay class=modal-overlay><!--  --></div>");
        },

        insertLoading: function(loadingMessage) {
            var $loaderDiv,
                topOffset,
                $loader;
            $body.append("<div id=modal-loader class=modal-loader><!--  --></div>");
            $loaderDiv = $body.find('#modal-loader');
            if(Handlebars && Handlebars.templates.loader) {
                $loaderDiv.append(Handlebars.templates.loader({message: loadingMessage}));
                new Spinner({
                    color: "#6D6E71",
                    hwaccel: true
                }).spin($loaderDiv.find(".loader")[0]);
            }
            $loader = $body.find('.loader');
            topOffset = Math.ceil( ($win.height() - $loader.height()) / 2);
            $loaderDiv.css('top', topOffset);
        },

        removeLoading: function() {
            var $loaderDiv = $body.find('#modal-loader');
            $loaderDiv.remove();
        },

        insertModal: function() {
            $body.append('' +
                '<div id=modal class=modal-container>' +
                    '<div class=modal>' +
                        '<div class=modal-content><!--  --></div>' +
                        '<a href=# class="btn-modal-close modal-close" title="close">&times;</a>' +
                    '</div>' +
                '</div>');
        }
    });



    /*
     * Setup the controller
     */
    Base.Modal = Base.Controller.extend({
        initialize: function(config) {
            this._config = config || {};

            /*
             * Setup the model
             */
            this.model = new Base.Model({
                "status": "closed",
                "ready": false
            });

            return this;
        },

        // On demand init
        _initialize: function() {
            if (this._initialized) {
                return this;
            }

            this._initialized = true;

            var self = this,
                $overlay,
                $modal;

            $overlay = this.overlay ? $(this.overlay) : null;

            if (!$overlay) {
                $overlay = $("#modal-overlay");

                if (!$overlay.length) {
                    _view.prototype.insertOverlay();
                    $overlay = $("#modal-overlay");
                }
            }

            $modal = this.modal ? $(this.modal) : null;
            if (!$modal) {
                $modal = $("#modal");

                if (!$modal.length) {
                    _view.prototype.insertModal();
                    $modal = $("#modal");
                }
            }

            this.$el = $modal;


            this.view = new _view(this);
            this.view.$overlay = $overlay;

            this.model.bind("change:status", this.view.changeStatus, this.view);

            this.bindEvents(this.model, {
                "press .btn-modal-close": "closeButton"
            });

            $win.resize(function(){
                self.view.positionContent();
            });

            this.init();

            return this;
        },

        init: function(){},

        load: function(selector) {
            this._initialize().view.load(selector);
            return this;
        },

        loadURL: function(url, config) {
            var settings = {iframe:false};
            extend(settings, config);

            this._initialize().view.loadURL(url, settings);
            return this;
        },

        set: function(str) {
            this._initialize().view.set(str);
            return this;
        },

        close: function() {
            if ( this.isOpen() ) {
                this.model.set("status", "closed");

                if (this._config["close:after"]) {
                    this._config["close:after"]();
                }

                this.view.removeLoading();
            }

            return this;
        },

        closeButton: function() {
            if (this._config["close:before"]) {
                if (this._config["close:before"]()) {
                    this.close();
                }
            } else {
                this.close();
            }
        },

        open: function(config) {
            var self = this;

            var settings = {
                "close:overlay": true
            };

            this._initialize();

            config = config || {};

            extend(settings, config);
            extend(this._config, settings);


            if (!Browser.supports("touch")) {
                this.view.$overlay.unbind("click.modal");
                this.$el.unbind("click.modal");

                if (this._config["close:overlay"]) {
                    this.view.$overlay.bind("click.modal", function(){
                        self.close();
                    });
                }
            }

            if (this._config["close:hide"] === true) {
                this.view.toggleCloseButton(true);
            } else {
                this.view.toggleCloseButton(false);
            }

            this.model.set("status", "open");
            if (this._config["ready"]) {
                this._config["ready"]();
            }

            return this;
        },

        isOpen: function() {
            return "open" == this.model.get("status");
        }
    });
}).call(this);/**
 * login js
 *
 * js for ajax login
 *
 * @author jrylan, haroun,  mdavid
 */
(function(){
    SU.Login = Base.FormHandler.extend({
        selector: "#login-form",

        method: "create",

        restURL: "/login",

        submit: function(values) {
            var hasErrors = false;

            var fields = [
                "user",
                "pass",
                "nativeSubmit"
            ];

            values.nativeSubmit = '0';

            for (var i=0,name; name=fields[i]; i++) {
                if (!values[name]) {
                    this.inputs.getById(name).set({status: "error-soft"});
                    hasErrors = true;
                }
            }

            return !(hasErrors);
        },

        success: function(response) {
            window.location = response.url;
        },

        error: function() {
            window.location.reload();
        },

        inputs: [
            {
                id:"user",
                active:true,
                validateOn: "blur",
                validate: function() {
                    return this.removeErrorIfNotEmpty();
                }
            },
            {
                id:"pass",
                validateOn: "blur",
                validate: function() {
                    return this.removeErrorIfNotEmpty();
                }
            },
            {
                id:"remember"
            }
        ]
    });

    SU.addInit("mLogin", function(config) {
        new SU.Login(config);
    });
}).call(this);(function(){
    
    SU.Logout = Base.Controller.extend({
        restURL: "/logout",

        initialize: function(data) {
            this.sync.set(data);
            this.bindEvents({
                "click .logout" : "execute"
            });
        },


        execute: function() {
            // Clear sessionStorage and localStorage
            if (window.sessionStorage) {
                window.sessionStorage.clear();
                window.localStorage.clear();
            }
            // If there's an extension then tell it to log out as well
            if (typeof(suExtensionApi) != "undefined" && suExtensionApi.message)
                suExtensionApi.message.postMessage({ id: 1 }, "msgLogout");
            return this.sync.del({"_action": "logout"})
                .success(function(response) {
                    if (response._success) {
                        window.location = "/logged-out";
                    }
                });
        }
    });

    SU.addInit("mLogout", function(data){
        new SU.Logout(data);
    });
}).call(this);(function(){
    SU.addInit("avatarDebug", function() {
        $('.thumb').each(function(index, el)
            {
                if ($(el).find('img').width() > 0)
                {
                    var img = $(el).find('img');
                    $(el).find('.size').html($(img).width()+'x'+$(img).height());
                }
                else
                {
                    $(el).find('img').load(function(img) {
                        $(el).find('.size').html($(this).width()+'x'+$(this).height());
                    });
                }
            }
        );
    });
}).call(this);(function(){
    // XSS token, gets set from the web.tpl
    var _token;
    var _viewtoken;

    var Stumble = Base.Model.extend({
        defaults: {
            "isliked": 0
        }
    });

    var Stumbles = Base.Collection.extend({
        model: Stumble
    });

    var View = Base.View.extend({
        initialize: function() {
            this.$stumbles = this.$el.find(".stumbles");
            this.$content = this.$el.find(".l-content-primary");
            this.$filter = this.$el.find(".stumbles-filter");
        },

        filterViewUpdated: function(filter) {
            if (filter.get("view") == "list") {
                this.$stumbles.removeClass("s-stumbles-grid").addClass("s-stumbles-list");
                this.$filter.removeClass("s-grid").addClass("s-list");
            } else {
                this.$stumbles.removeClass("s-stumbles-list").addClass("s-stumbles-grid");
                this.$filter.removeClass("s-list").addClass("s-grid");
            }
        }
    });

    var routePatterns = {
        "likes": "stumbler/(:username)",
        "interests": "stumbler/(:username)/interests",
        "comments": "stumbler/(:username)/comments",
        "history": "stumbler/(:username)/history",
        "interest": "interest/(:interest)",
        "channel": "channel/(:channel)",
        "shares": "shares",
        "url": "content/(:publicid)",
        "url_likes": "content/(:publicid)/likes"
    };

    var Router = Base.Router.extend({
        pagination: true,
        defaults: {
            "show": "all"
        }
    });


    SU.Stumbles = Base.Controller.extend({
        initialize: function(config) {
            var self = this;
            this.$el = $(config.pushTarget || config.selector);
            this.view = new View(this);
            this.stumbles = new Stumbles(this);
            this.stumbles.model.prototype.bind("change:isliked", this.statusChange);
            this.filter = new Base.Model({
                "view": config.view,
                "show": "all",
                "category": ""
            });

            this.filter
                .bind("change:view", this.view.filterViewUpdated, this.view)
                .bind("change:view", this.userUpdateViewSettings, this)
                .bind("change:show", this.filterShowUpdated, this)
                .bind("change:category", this.filterCategoryUpdated, this);


            this.bindEvents({
                "change .stumbles-filter #filter-show": "filterChangeShow",
                "change .stumbles-filter #filter-category": "filterChangeCategory",
                // legacy event
                "press .stumble-view-toggle a": "filterChangeView",
                "press .e-view-toggle a": "filterChangeView",
                "press .e-stumbles .stumble-acts-info": "info"
            });

            this.bindEvents(this.stumbles, {
                "click .e-stumbles .stumble-acts-stumble": "stumble",
                "click .e-stumbles .stumble-unlike": "unlike",
                "click .e-stumbles .stumble-acts-share": "share",
                "click .e-stumbles .comment-controls a": "commentControls"
            });

            this.$el.on('click', ".e-stumbles .stumble-item", function(e) {
                // Don't stumble if the click target was an anchor or button
                if ( $(e.target).closest('a, .wrapper-comment, button').length ) {
                    return;
                }

                var $this = $(this),
                    id = $this.data("id"),
                    model,
                    $parent = null,
                    data = null;


                if (!id) {
                    $parent = $this.parents(".stumble-item");
                    id = $parent.data("id");
                    data = $parent.data();
                } else {
                    data = $this.data();
                }


                model = self.stumbles.getById(id);
                if (!model) {
                    self.stumbles.add(data);
                    model = self.stumbles.getById(data.id);
                }

                self.stumble(model, e);
            });

            if (config.pagination) {
                this.route = new Router(this, routePatterns[config.route]);
                this.route.bind("ready", function(){
                    self.stumbles.reset();
                    // trigger change:view event after navigation to update view
                    self.filter.trigger("change:view");
                });
            }
        },

        commentControls: function(model, e) {
            e.stopPropagation();
            var $targ = $(e.target),
                $commentRoot = $targ.parent();
                action = $targ.data('action'),
                commentId = $commentRoot.data('commentid'),
                comment = $commentRoot.siblings('.comment').html(),
                commentTruncated = $commentRoot.data('comment'),
                tags = $commentRoot.data('tags');

            // helpers
            function displaySection(section) {
                $('#wrapper-edit > section, .modal-content > section').css('display', 'none');
                $('.' + section).css('display', 'block');
            }

            function formSubmit($el) {
               $.ajax({
                   url:$el.attr('action'),
                   type: "POST",
                   dataType: "json",
                   data: $el.serialize(),
                   success: function( r ){
                       if( r._success ){
                           cancel();
                           window.location.reload();
                       }
                   }
               });
            };

            function cancel() {
                SU.Modal.close();
            };

            function switchMode($el, e) {
                displaySection($el.data('action'));
            };

            function setCaret(field, index) {
                if (field.setSelectionRange) {
                    field.setSelectionRange(index, index);
                } else if (field.createTextRange) {
                    var range = field.createTextRange();
                    range.collapse = true;
                    range.moveEnd('character', index);
                    range.moveStart('character', index);
                    range.select();
                }
            };

            // set modal content and show
            $('#comment-target').html(commentTruncated);
            $('#your-comment').html(comment);
            $('#your-tags').html(tags);
            $('#commentid-add').val(commentId);
            $('#commentid-delete').val(commentId);
            displaySection(action);

            if (!this._modalEvents) {
                this._modalEvents = true;
                SU.Modal.bindEvents({
                    "submit form": formSubmit,
                    "click .cancel": cancel,
                    "click .switch-mode": switchMode
                });
            }

            SU.Modal.load("#wrapper-edit").open({
                ready:function() {
                    var index = comment.length,
                        $field;
                    if (action == 'comment-edit') {
                        $field = SU.Modal.$el.find('textarea').first();
                        $field.focus();
                        setCaret($field[0], index);
                    }
                }
            });
        },

        unlike: function(model, e) {
            e.stopPropagation();
            model.set("isliked", false);
        },

        statusChange: function(model) {
            Sync("/su/api/action").update({
                "_token": _token,
                "action": "simple-rate",
                "src": "website",
                "rating": ( model.get("isliked") ? 1 : -1 ),
                "pid": model.get("id")
            }).success(function(){
                model.$el.addClass("s-stumble-unliked");
            });
        },

        share: function(model, e) {
            e.stopPropagation();
            SU.Modal.loadURL("/su/overlay/share/?pid=" + model.get("id") + "&src=website", {iframe:true, wrapperClass: "share-panel-modal"}).open();
        },

        stumble: function(model, e) {
            e.stopPropagation();
            SU.ToolbarAction.stumble(model.toJSON());
        },

        info: function($el, e) {
            e.stopPropagation();
            // Log some analytics stuff here
            window.location = $el.attr("href");
        },

        filterChangeView: function($el) {
            this.filter.set("view", $el.data("view"));
        },

        userUpdateViewSettings: function(filter) {
            // update the user's preference
            var data, tokenObj = {};
            tokenObj[_viewtoken.name] = _viewtoken.token;
            data = extend(
                { "view": filter.get("view") },
                tokenObj
            );

            Sync("/changeview").update(data);
        },

        filterChangeShow: function($el) {
            this.filter.set("show", $el.val());
        },

        filterChangeCategory: function($el) {
            this.filter.set("category", $el.val());
        },

        filterShowUpdated: function(filter) {
            this.route.navigate( filter.get("show") );
        },

        filterCategoryUpdated: function(filter) {
            this.route.navigate( filter.get("category") );
        }
    });

    SU.addInit("mStumbles", function(config){
        new SU.Stumbles(config);
    });

    SU.addInit("setStumbleToken", function(token){
        _token = token;
    });

    SU.addInit("setViewToken", function(token){
        _viewtoken = token;
    });
}).call(this);(function(){
    SU.addInit("mCardModal", function(config){
        $('#content').on('click','.user-detail', function(e){
            e.preventDefault();
            // SU.Modal is instantiated by webtb
            SU.Modal.load("#"+$(e.target).data('contentid')).open();
        });
    });
}).call(this);(function(){
    var _followingInit = false;

    var FollowStatus = Base.Model.extend({
        initialize: function() {
            var curStatus = this.get("status"),
                newStatus = false;

            if (curStatus === 1) {
                newStatus = "follow";
            } else if (!curStatus) {
                newStatus = "unfollow";
            }

            if (newStatus) {
                this.set("status", newStatus, {silent:true});
            }

        },

        buildRequestURL: function() {
            return "/follow/" + this.get("type");
        },

        getData: function() {
            var data = {},
                type = this.get("type"),
                id = this.get("id");

            if (type === "stumbler") {
                data.userid = id;
            } else {
                data[type] = id;
            }

            data.status = this.get("pending-status");
            data[this._config.tokenName] = this._config.tokens[type];

            return data;
        },

        save: function() {
            var sync = Sync(this.buildRequestURL()),
                requestMethod = "create";

            if (this.get("pending-status") === "unfollow") {
                requestMethod = "update";
            }

            return sync[requestMethod](this.getData());
        }
    });

    var FollowEntities = Base.Collection.extend({
        model: FollowStatus
    });

    var FollowView = Base.View.extend({
        toggleStatus: function(model) {
            var elementIsButton = model.$el.hasClass("button-follow"),
                classToRemove,
                classToAdd;

            if (model.get("status") === "follow") {
                classToRemove = "follow";
                classToAdd = "following";
            } else {
                classToRemove = "following";
                classToAdd = "follow";
            }

            if (!elementIsButton) {
                model.$el
                    .find(".button-follow")
                    .removeClass(classToRemove)
                    .addClass(classToAdd);
            } else {
                model.$el.removeClass(classToRemove).addClass(classToAdd);
            }
        }
    });

    SU.Following = Base.Controller.extend({
        initialize: function(config) {
            config = config || {};
            this.$el = $("#content");
            this.view = new FollowView(this);
            this.collection = new FollowEntities(this);
            this.collection.model.prototype
                .bind("change:pending-status", this.statusChanged, this)
                .bind("change:status", this.view.toggleStatus);
            this.collection.model.prototype._config = config;

            this.bindEvents(this.collection, {
                "press .button-follow.follow": "follow",
                "press .button-follow.following": "unfollow"
            });
        },

        follow: function(model, e) {
            e.stopPropagation();
            // don't allow follow action for unfollowOnly buttons.
            if (model.$el.data().unfollowOnly) {
                return false;
            }

            model.set("pending-status", "follow");
        },

        unfollow: function(model, e) {
            e.stopPropagation();
            model.set("pending-status", "unfollow");
        },

        statusChanged: function(model) {
            var self = this;

            model.save()
                .success(function(data, textStatus, jqXHR) {

                    if (SU.Captcha.isRequired(data)) {
                        SU.Captcha.show(function(){
                            self.statusChanged(model);
                        });
                        return;
                    }

                    if (data._success === true) {
                        model.set("status", model.get("pending-status"));

                        // add disabled class to element when button is
                        // unfollowOnly and user unfollowed. No follow allowed.
                        if (model.get("pending-status") === "unfollow" &&
                                model.$el.data().unfollowOnly) {
                            model.$el.addClass("disabled");
                        }

                        // If we have new interests, then update the toolbar
                        if (data.interests) {
                            SU.ToolbarAction.updateTopics(data.interests);
                        }
                    } else {
                        model.set("pending-status", "", {silent:true});
                    }
                })
                .error(function(jqXHR, textStatus, errorThrown){
                    model.set("pending-status", "", {silent:true});

                    if (errorThrown === "Unauthorized") {
                        self.unauthorizedRequest({
                            source: "follow_" + model.get("type"),
                            id: model.get("id")
                        });
                    }
                });
        }
    });

    SU.addInit("mFollow", function(config){

        if (!_followingInit) {
            new SU.Following(config);
            _followingInit = true;
        }
    });
}).call(this);(function(){
    var Router = Base.Router.extend({
        pattern: "stumbler/(:username)/connections/?(:show)?",
        pagination: true
    });

    SU.Connections = Base.Controller.extend({
        initialize: function(config) {
            var self = this;

            this.$el = $("#content");
            this.view = new Base.View(this);
            this.route = new Router(this);

            this.filter = new Base.Model({
                "show": "all"
            });
            this.filter.bind("change:show", this.filterShowUpdated, this);

            this.bindEvents({
                "change .stumbles-filter select": "filterChangeShow"
            });

            // on route update trigger custom event to let other
            // controllers know pagination happened
            this.route.bind("ready", function(){
                self.$el.trigger("pagination");
            });
        },

        filterChangeShow: function($el) {
            this.filter.set("show", $el.val());
        },

        filterShowUpdated: function(filter) {
            this.route.navigate( filter.get("show") );
        }
    });

    SU.addInit("mConnections", function(config){
        new SU.Connections(config);
    });
}).call(this);(function(){
    SU.addInit("mStumbleButton", function(){
        $body.delegate(".stumble-button", press, function(e){
            e.preventDefault();
            SU.ToolbarAction.stumble( $(this).data() );
        });
    });
}).call(this);(function(){
    "use strict";
    /**
     * State Model
     */
    var state = Base.Model.extend({
        defaults: {
            "keyword": "",
            "typed-keyword": "",
            "index": -1
        },

        getTypedKeyword: function() {
            var typedKeyword = this.get("typed-keyword") || ""; // Always needs to at least return an empty string;
            // Remove tabs, spaces, line breaks and trim
            return typedKeyword.replace( /[\s\n\r\t]+/g, " " ).replace(/^\s*([\S\s]*?)\s*$/, "$1");
        }
    });

    /**
     * Result model
     */
    var result = Base.Model.extend({
        idAttribute: "index",

        defaults: {
            label: null,
            matchesInput: false
        },

        getKeyword: function() {
            return this.get("label");
        }
    });

    /**
     * Results Collection
     */
    var results = Base.Collection.extend({
        model: result,

        getByIndex: function(index) {
            var model = this.models[index];
            return model ? model : false;
        },

        /**
         * Get the keyword from the specified index offset
         *
         * @param index
         */
        getKeywordFromIndex: function(index) {
            var model = this.getByIndex(index);
            return model ? model.getKeyword() : false;
        }

    });

    /**
     * Cache Collection
     */
    var CacheIndex = function(config) {
        this._keywords = [];
        this._resultsByKeyword = {};
        this._keywordIndexPositions = {};
        this._keywordAdded = {};
        this._limit = config.limit || 50;
        this._expires = config.expires || 3600000; // Milliseconds: 1 hour default, use 0 to disable
        this._total = 0;

        return this;

    };

    extend(CacheIndex.prototype, {

        addResults: function(keyword, results) {
            this._keywords.push(keyword);
            this._resultsByKeyword[keyword] = results;
            this._keywordIndexPositions[keyword] = this._total++; // Assign the index value and update the total after
            this._keywordAdded[keyword] = (new Date()).getTime();

            if (this._total > this._limit) {
                this.purgeOldResults();
            }

            return this;

        },

        get: function(keyword) {
            var results = this._resultsByKeyword[keyword],
                curTime;

            if (!results) {
                return false;
            }

            if (this._expires > 0) {
                curTime = (new Date()).getTime();

                if ((curTime - this._keywordAdded[keyword]) >= this._expires) {
                    this.remove(keyword);
                    return false;
                }
            }

            return results;

        },

        remove: function(keyword) {
            var index = this._keywordIndexPositions[keyword];

            this._keywords.splice(index, 1);
            delete this._resultsByKeyword[keyword];
            delete this._keywordIndexPositions[keyword];
            delete this._keywordAdded[keyword];
            this._total--;
        },

        purgeOldResults: function() {
            this.remove( this._keywords[0] );
        }

    });

    var CacheLibrary = {
        createIndex: function(config) {

            if (!this[config.instance]) {
                this[config.instance] = new CacheIndex(config || {});
            }

            return this[config.instance];
        }
    };

    /**
     * View
     */
    var view = Base.View.extend({

        initialize: function() {
            this.$input = this.$el;

            var placeholderText = this.$input.attr("placeholder");

            if(!Browser.supports("placeholder")) {
                this.$input.val( this.$input.attr("placeholder") ).addClass("ac-placeholder");

                this.$input
                    .focus((function() {
                        if (this.$input.val() == placeholderText) {
                            this.$input.val("").removeClass("ac-placeholder");
                        }
                    }).bind(this))
                    .blur((function() {
                        if (this.$input.val() === "") {
                            this.$input.val(placeholderText).addClass("ac-placeholder");
                        }
                    }).bind(this));
            }
        },

        $resultsContent: function() {
            if (!this._resultsContent) {
                this._resultsContent = this.$results.find(".ac-results-content");
                this._initialResultsHTML = this._resultsContent.html();
            }

            return this._resultsContent;

        },

        /**
         * Render results
         */
        renderResults: function(collection) {
            var html = "",
                results = collection.models,
                i,
                ii,
                result,
                heading;

            this.trigger("results:before");
            html += "<ul class='ac-results'>";

            //@fixme
            for (i=0, ii=results.length; i<ii; i++) {

                result = results[i];

                heading = result.get("heading");

                if (heading) {

                    if (i > 0) {
                        html += '</ul>';
                    }

                    html += "" +
                        "<h6 class='ac-results-heading'>" + heading + "</h6>" +
                        "<ul class='ac-results'>";
                }

                html += "<li><a href='#' data-index='" + i + "'";

                if (result.get("highlight")) {
                    html += " class='s-ac-selected'";
                }

                html += ">" + result.get("matchedText") + "</a></li>";

            }

            html += "</ul>";

            this.$resultsContent().html(this._initialResultsHTML + html);

            if (results.length === 0) {
                this.noResults();
            }

            this.trigger("results:after");

        },

        noResults: function() {
            this.$results.find(".ac-no-results").show();
        },

        keywordChanged: function(state) {
            this.$input.val(state.get("keyword"));
        },

        indexChanged: function(state) {
            var index = state.getInt("index");

            this.$resultsContent().find(".s-ac-selected").attr("class", "");

            if (index > -1) {
                this.$results.find("[data-index=" + index + "]").addClass("s-ac-selected");
            } else {
                state.set("keyword", state.get("typed-keyword"));
            }

        },

        scrollElementIntoView: function() {
            this.$scrollTarget[0].scrollIntoView();
        },

        toggleLoading: function(state) {

            if (state.get("loading")) {
                this.$input.addClass("s-ac-loading");
            } else {
                this.$input.removeClass("s-ac-loading");
            }

        },

        toggleFocus: function(state) {

            if (state.get("focused")) {
                this.$input.focus();
            } else {

                if (!Browser.supports("touch")) {
                    state.set("open", false);
                }

            }

        },

        toggleResultsDisplay: function(state) {
            var typedKeyword = state.get("typed-keyword");

            if (this._hideTimeout) {
                clearTimeout(this._hideTimeout);
                this._hideTimeout = null;
            }

            if (state.get("open")) {
                this.$results.show();
            } else {

                if (typedKeyword && typedKeyword.length > 1) {
                    this._hideTimeout = setTimeout((function(){
                        this.$results.hide();
                    }).bind(this), 400);
                } else {
                    this.$results.hide();
                }
            }
        }

    });

    /**
     * Controller
     */
    Base.Autocomplete = Base.Controller.extend({
        _lastRequest: 0,
        _timer: null,

        _settings: {
            "delay": 100,
            "auto_focus": false
        },

        // Base initialize`
        initialize: function(config) {
            extend(this._settings, config);

            this._instanceId = ".autocomplete-" + config.id;

            this.keywordBuffer = [];

            this.state = new state();
            this.view = new view(this);

            this.results = new results(this);
            this.results.bind("reset", this.view.renderResults, this.view);

            this.cache = CacheLibrary.createIndex({instance:this.cacheId});

            this.state
                .bind("change:keyword", this.view.keywordChanged, this.view)
                .bind("change:typed-keyword", this.typedKeywordChanged, this)
                .bind("change:index", this.view.indexChanged, this.view)
                .bind("change:index", this.indexChanged, this)
                .bind("change:focused", this.view.toggleFocus, this.view)
                .bind("change:open", this.view.toggleResultsDisplay, this.view);

            if (config.showLoadingState !== false) { // Passes if `undefined` or `true`
                this.state.bind("change:loading", this.view.toggleLoading, this.view);
            }

            /*
             * Remove the loading class when the page unloads, otherwise the user could navigate back in their history and
             * the loading icon will still be animating.
             */
            $(window).bind("unload" + this._instanceId, (function(){
                try {
                    this.state.set("loading", "off");
                } catch(e) {
                    // Don't break
                }
            }).bind(this));

            // Scroll a specific target back into view when device orientation changes
            if (this._settings.scrollTargetSelector && Browser.supports("orientationChange")) {
                this.view.$scrollTarget = $(this._settings.scrollTargetSelector);
                this.state.bind("change:orientation", this.view.scrollElementIntoView, this.view);
                window.onorientationchange = (function() {
                    this.state.trigger("change:orientation");
                }).bind(this);
            }

            this.bindEvents({
                "keyup": "keyInput",
                "blur": "blur"
            });

            this.$results = $(this._settings.resultsSelector);

            // Pass this selector onto the view
            this.view.$results = this.$results;

            this.$results
                .delegate("a", "click", (function(e){
                    e.preventDefault();
                    this.selectResult($(e.target).data("index"));
                }).bind(this))
                .delegate("a", "hover", (function(e){
                    this.setIndex($(e.target).data("index"));
                }).bind(this));

            if (this._settings.auto_focus) {
                this.state.set("focused", true);
            }

            this.init(config);

        },

        indexChanged: function(event, data, newIndex) {

            if (newIndex > -1) {
                this.state.set("keyword", this.results.getKeywordFromIndex(newIndex));
            } else {
                this.state.set("keyword", this.state.get("typed-keyword"));
            }

        },

        typedKeywordChanged: function(state) {
            var curVal = state.getTypedKeyword();

            if (curVal && curVal.length > 1) {
                this.queueRequest();
            } else {
                this.state.set("open", false);
                this.results.reset();
            }

        },

        /**
         * Keypress handler
         */
        keyInput: function($this, e) {
            var index = this.state.getInt("index"),
                newIndex = false,
                newKeyword = false,
                lastIndex = this.results.length - 1,
                typedKeyword = this.state.get("typed-keyword") || "";

            lastIndex = lastIndex > -1 ? lastIndex : 0;
            this.state.set("loading", false);

            if (e.which != 13 && e.which != 38 && e.which != 40) {
                var value = $this.val();

                if (value != typedKeyword) {
                    this.state.set("typed-keyword", value);
                }
                return;
            }

            if (e.which === 13 /*Enter*/) {

                if (this.keywordBuffer.length === 0) {
                    this.submit();
                } else {
                    this.bind("keyword:done", (function() {

                        if (this.keywordBuffer.length === 0) {
                            this.submit();
                        }

                    }).bind(this));
                }
            }

            // If there are no results or the list isn't open, don't bother trying to cycle through it.
            if (!this.results.models.length || !this.state.get("open")) {
                return;
            }

            if (e.which === 38 /*Up*/) {
                newIndex = index > -1 ? index - 1 : lastIndex;
            }

            if (e.which === 40 /*Down*/) {
                newIndex = index != lastIndex ? index + 1 : -1;
            }

            if (newIndex !== false) {
                this.state.setInt("index", newIndex);
            }
        },

        blur: function() {
            this.state.set("focused", false);
        },

        /**
         * Submit
         */
        submit: function() {
            var index = this.state.getInt("index"),
                result;

            if (index === -1) {
                result = this.results.getByIndex(0);

                if (result && result.get("matchesInput") === true) {
                   this.state.setInt("index", 0);
                    this._resultSelected(0);
                } else {
                    this.view.noResults();
                }

            } else {
                // .resultSelected is a method that should exist within the object that extends Base.Autocomplete
                this._resultSelected(index);
            }

        },

        setIndex: function(index) {
            this.state.setInt("index", index);
        },

        /**
         * Select an item from the result list
         */
        selectResult: function(index){
            var model = this.results.getById(index);

            this.state.trigger("change:orientation");
            this.state.set("keyword", model.get("label"));
            this.submit();
        },

        /**
         * Queue a lookup request to the server
         */
        queueRequest: function() {
            var toDelay = this._settings.delay,
                curTime = (new Date()).getTime(),
                timeDiff = (curTime - this._lastRequest);

            if (timeDiff < this.delay) {
                toDelay = this.delay - timeDiff;
            }

            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }

            this._timer = setTimeout((function(){
                this.sendRequest();
            }).bind(this), toDelay);

        },

        /**
         * Send the request to the server
         */
        sendRequest: function(){
            var keyword = this.state.getTypedKeyword(),
                cache = this.cache.get(keyword);

            this._lastRequest = (new Date()).getTime();

            this.keywordBuffer.push(keyword);

            if (this._requestProcessing) {
                this._requestProcessing.abort();
            }

            if (cache) {
                this.state.setInt("index", -1);
                this._prepareData(cache);
                this._requestProcessing = null;
                this.trigger("keyword:done");
                this.keywordBuffer = this.keywordBuffer.splice(1, this.keywordBuffer.length);

                return;
            }

            this._requestProcessing = this.sync.create(
                // Data
                {
                    "q": keyword,
                    "_token": this._settings._token
                },

                // Ajax params
                {
                    cache: false,

                    success: (function(response){
                        this.keywordBuffer = this.keywordBuffer.splice(1, this.keywordBuffer.length);
                        this._lastRequest = (new Date()).getTime();

                        if (response._success) {
                            this.state.setInt("index", -1);
                            this._prepareData(response.data);
                            this.cache.addResults(keyword, response.data);
                            this.trigger("keyword:done");
                        }

                    }).bind(this),

                    error: (function(){
                        //$todo
                        this.trigger("keyword:done");
                        this.keywordBuffer = this.keywordBuffer.splice(1, this.keywordBuffer.length);
                    }).bind(this)

                }
            );
        },

        _prepareData: function(data) {
            var hasResults = false,
                results = [],
                result,
                index = 0,
                categories = data.categories,
                category,
                pattern = this.state.getTypedKeyword().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"),
                c,
                cc,
                r,
                rr;

            if (!categories || categories && categories.length > 0) {
                this.results.reset();
            }

            for (c=0, cc=categories.length; c<cc; c++) {
                category = categories[c];

                // Loop through the results under each category
                for (r = 0, rr = category.keywords.length; r<rr; r++) {
                    result = category.keywords[r];
                    result.index = index;

                    if (r === 0 && category.label != "default") {
                        result.heading = category.label;
                    }

                    if (result.highlight) {
                        result.matchesInput = true;
                    }

                    var regexObj = new RegExp(pattern, "ig");
                    var replaceWith = regexObj.exec(result.label);

                    result.matchedText = result.label.replace(regexObj, "<strong>"+replaceWith+"</strong>");
                    results.push(result);
                    index++;

                }
            }

            this.results.reset(results);
            this.state.set("open", true);

        },

        _resultSelected: function(index) {
            this.state.set("loading", true);
            this.resultSelected( this.results.getByIndex(index) );
            this.state.set("open", false);
        }

    });
}).call(this);(function(){
    function resultsTemplate(id) {
        return "" +
        "<div class='ac-results-wrap' id='" + id + "'>" +
            "<div class='ac-results-content'>" +
                "<div class='ac-no-results explore-no-results'>" +
                    "<h6>No Results Found.</h6>" +
                    "<p>Please try exploring another interest.</p>" +
                "</div>" +
            "</div>" +
        "</div>";
    }


    function exploreBoxInit(config) {
        config.selector = "#" + config.id;

        var isWebToolbar = (config.id == "tb-explore-box"),
            resultsId = config.id + "-results-wrap";

        config.resultsSelector = "#" + resultsId;


        if (isWebToolbar) {
            $body.append( resultsTemplate(resultsId) );
        } else {
           $(config.selector).after( resultsTemplate(resultsId) );
        }

        var ExploreBox = Base.Autocomplete.extend({
            selector: config.selector,

            cacheId: "ExploreBox",

            restURL: "/autocomplete/keyword",

            init: function() {
                if (isWebToolbar && config.client == 'chromebar') {
                    this.view.bind("results:after", this.openAutoCompleteOverlay);
                    this.state.bind("change:keyword", this.openAutoCompleteOverlay);
                }
            },

            openAutoCompleteOverlay: function()
            {
                if ($(config.resultsSelector + ' .ac-results-content ul'))
                    var w = $(config.resultsSelector + ' .ac-results-content ul').width();
                else
                    var w = $(config.resultsSelector + ' .ac-results-content').width();

                SU.WebToolbar.overlayManager.openOverlay('keyword-autocomplete', {
                    data: "<div id='" + resultsId + "'>" + $(config.resultsSelector).html() + "</div>",
                    type: 'floating',
                    anchorElement: $('#' + config.id),
                    size: {width: w, height: $(config.resultsSelector).height()},
                    closeOthers: ['floating', 'notification'],
                    refresh: true
                })
            },

            resultSelected: function(model) {
                var data = model.toJSON();
                var mode = {};
                mode.contextual = data.label;

                // TODO: remove this, because the server should send the correct data
                if (data.mode == 'topic')
                {
                    mode.mode = 'topic';
                    mode.topic = data.topicid;
                }
                else
                {
                    mode.mode = 'tag';
                    mode.q = data.label;
                }
                mode.action_trigger = "exploreBox";
                SU.ToolbarAction.stumble(mode);
            }
        });

        SU.ExploreBox = new ExploreBox(config);
    }

    SU.addInit("mExploreBox", function(config){
        // config.scrollTargetSelector = '.explore-interests h2';
        exploreBoxInit(config);
    });

    SU.addInit("mExploreBoxWebToolbar", function(config){
        exploreBoxInit(config);
    });
}).call(this);(function(){
    "use strict";

    var Router = Base.Router.extend({
        pattern: "stumbler/(:username)/channels/?(:show)?",
        pagination: true
    });

    SU.Channels = Base.Controller.extend({
        initialize: function(config) {
            this.$el = $("#content");
            this.view = new Base.View(this);
            this.route = new Router(this);

            this.filter = new Base.Model({
                "show": "all"
            });

            this.filter.bind("change:show", this.filterShowUpdated, this);

            this.bindEvents({
                "change .stumbles-filter select": "filterChangeShow"
            });
        },

        filterChangeShow: function($el) {
            this.filter.set("show", $el.val());
        },

        filterShowUpdated: function(filter) {
            this.route.navigate( filter.get("show") );
        }
    });

    SU.addInit("mChannels", function(config){
        new SU.Channels(config);
    });
}).call(this);(function(){
    "use strict";

    SU.flagModal = new Base.Modal();

    SU.FlagItem = function(config){
        var $flagTrigger = $('#flag-item, .e-flag-item'),
            flagUrl = null,
            modalClass = config.modalClass || 'flag-stumbler';

        $flagTrigger.click(function(e){
            e.preventDefault();
            flagUrl = $flagTrigger.data('flagitem');
            SU.flagModal.loadURL(flagUrl, {iframe:true, wrapperClass: modalClass}).open();
        });
    };

    SU.addInit("mFlagItem", function(config){
        new SU.FlagItem(config);
    });
}).call(this);/*
 * This is intended to be a starting point for future cases.
 * message: just a string
 *
 * meta:
 * may or may not exist. it an object.
 * may have cta (call to action),
 * ctal(text for call to action), sticky (not used yet),
 * bt (backtrace - not public facing)
 */
(function() {
    "use strict";

    // declare global flashMessages object
    // this may need to be accessed by multiple channels in future
    SU.flashMessages = {};

    SU.FlashMessage = function(data, overrides) {
        this.template = overrides.template || Handlebars.templates.alertMessage || false;
        this.$el = overrides.$el || $('#content');
        this.message = data.message || '';
        this.messageId = data.id || '';
        this.messageType = this.getMessageType(data.type);
        this.meta = data.meta || {};
        this.showClose = (this.meta.showClose === false) ? false : true;

    };
    SU.FlashMessage.prototype = {

        init: function(id){
            this.messageShow();
        },

        getMessageType: function(serverType){

            /*
             * type: (string)
             * Debug
             * Error
             * Message
             * Info
             * Success
             * Generic
             */

            var newType;
            switch (serverType) {
                case "Error":
                    newType = "error"
                    break;
                case "Info":
                    newType = "info"
                    break;
                case "Success":
                case "Debug":
                    newType = "success"
                    break;
                case "Message":
                    newType = "info"
                    break;
                default:
                    newType = "error"
            }
            return newType;
        },

        getTemplateData: function(){
            var templateData = {
                alertType : this.messageType,
                text: this.message,
                showClose: this.showClose,
                messageId: this.messageId
            };

            return templateData;
        },

        messageShow: function(){
            this.$el.prepend(this.template(this.getTemplateData()))
                .find('.alert-message .close')
                    .on('click', (function(e){
                        e.preventDefault();
                        var $targ = $(e.target),
                            $messageToClose;

                        // close by data-messageid, or by traversal
                        // in case you need to close more than one
                        if ($targ.data('closeid')) {
                            $messageToClose = $('[data-messageid="' + $targ.data('closeid') + '"]')
                        } else {
                            $messageToClose = $targ.closest('.alert-message');
                        }

                        this.messageHide($messageToClose);

                    }.bind(this)));
        },

        messageHide: function($message){
            $message.unbind().remove();
        }

    };

    SU.flashMessageHandler = function(){
        // This is being kept ambiguous until more
        // use cases are defined. We want to use a global object at this time.

        function init (config, overrides){

            var messageId,
                message,
                i;

            //iterate backwards so the first message is at the top of the page maintaining the
            //desired order of the messages
            for (i=config.length-1; i>=0; i--){
                messageId = config[i].id;
                SU.flashMessages[messageId] = new SU.FlashMessage(config[i], overrides);
            }

            for (message in SU.flashMessages) {
                SU.flashMessages[message].init(message);
            }

        };

        return {
            init: init
        }

    }();

    SU.addInit("mFlashMessage", function(config){
        var overrides = {
            $el: (config.target) ? $(config.target) : undefined
        };
        SU.flashMessageHandler.init(config.messages, overrides);
    });

}).call(this);/**
 * ajax content load
 *
 *
 * @author jeichorn
 */
(function(){
    SU.AjaxContentLoader = function(){
        this.$target = null;
        this.ajaxData = {};
        this.url = '';
    };
    SU.AjaxContentLoader.prototype = {
        setData : function(data){
            this.$target = $(data.target);
            this.url = data.url;
            this.ajaxData._token = data._token;
            this.ajaxData._nohead = "true";
            this.ajaxCall();
        },
        insert : function(content){
            this.$target.html(content);
        },
        showLoader : function(){
            var markup = '<div class="wrapper-loading"></div>';
            this.$target.append(markup).addClass('s-loading');
        },
        hideLoader : function(){
            this.$target.addClass('s-load-complete').removeClass('s-loading').find('.wrapper-loading').remove();
        },
        ajaxCall : function(){
            var self=this;
            self.showLoader();
            $.ajax({
                url: this.url,
                type: "GET",
                dataType: "html",
                data: self.ajaxData,

                complete: function() {
                    self.hideLoader();
                //called when complete
                },

                success: function(r) {
                    self.insert(r);
                },

                error: function() {
                }
            });
       }

    };
    SU.addInit("mAjaxContentLoader", function(configs) {
        var ajaxContentLoader;
        for(var i=0, ii=configs.length; i<ii; i++){
            ajaxContentLoader = new SU.AjaxContentLoader();
            ajaxContentLoader.setData(configs[i]);
        }
    });
}).call(this);(function(){
    "use strict";

    SU.addInit("mTutorial", function(config){
        var tutorialStateMachine = require("module/routers/tutorial_machine"),
            HelpTip = require('module/help_tip');


        if (config.viewer && config.viewer.messages) {
            new HelpTip({
                target: ".tutorial-tip"
            });
            tutorialStateMachine.initialize({
                tutorialUrls: config.viewer.messages
            });
        }
    });
}());// Popup Mixin shared across modal and contentPopup

define(function(require) {
    var mediator = require("module/mediator");

    return {
        initPopupMixin: function() {
            mediator.on("modal:close", this.close, this);
            mediator.on("modal:update:title", this.updateTitle, this);
            mediator.on("modal:showLoading", this.showLoading, this);
            mediator.on("modal:hideLoading", this.hideLoading, this);
            mediator.on("modal:showContext", this.showContext, this);
            mediator.on("modal:hideContext", this.hideContext, this);
            mediator.on("modal:update:classes", this.updateClasses, this);
        },

        showContext: function(context) {
            if (this.$context) {
                this.$context.removeClass("hidden").css({
                    opacity: 1
                }).show();
                this.$context.find(".modal-context-message").html(context);
            }
        },

        hideContext: function(options) {
            options || (options = {});

            if (options.close) {
                this.close(options);
            } else if (options.animate) {
                this.$context.fadeOut(function() {
                    $(this).addClass("hidden");
                });
            } else {
                this.$context.addClass("hidden");
            }
        },

        showLoading: function(options) {
            if (this.$loader) {
                this.$loader.removeClass("hidden");
                this.showLoader(_.extend({
                    $target: this.$loader,
                    loaderClass: "center"
                }, options));
            }
        },

        hideLoading: function() {
            if (this.$loader) {
                this.showChrome();
                this.$loader.addClass("hidden");
                this.hideLoader();
            }
        },

        updateTitle: function(title) {
            if (this.$el) {
                this.$el.find(".modal-title").html(title);
            }
        },

        showChrome: function() {
            if (this.$el) {
                this.$el.find(".modal-header").removeClass("hidden");
                if (this.options.animate) {
                    this.$el.find(".modal-view").addClass("fadeIn");
                }
            }
        },

        updateClasses: function(classes) {
            this.$el.find(".modal-view").removeClass().addClass("modal-view " + classes);
        }
    };
}, "module/mixins/popup");define(function(require) {
    var mediator = require("module/mediator"),
        TrackingModule;

    TrackingModule = function(view) {
        this.view = view;
        this.mediator = mediator;

        this.mediator.on("tracking:getModel", this.getModel, this);
    };

    TrackingModule.prototype = {
        getModel: function(e, fn) {
            var model,
                index;

            if (this.view.$el.has(e.currentTarget).length) {
                model = this.view.getClosestById(e);
                index = $(e.currentTarget).closest("article").index();
                fn(model, index);
            }
        }
    };

    return TrackingModule;
}, "module/tracking");define(function(require) {
    var mediator = require("module/mediator"),
        popupMixin = require("module/mixins/popup"),
        loaderMixin = require("module/mixins/loader"),
        utils = require("module/utils"),
        ContentPopup;

    ContentPopup = function(options, e) {
        this.options = options ? _.clone(options) : {};
        this.options.viewOptions || (this.options.viewOptions = {});
        this.options.onShow || (this.options.onShow = function(){});
        this.options.onHide || (this.options.onHide = function(){});

        // Default qtip options
        var qtipOptions = {
            overwrite: !!this.options.overwrite,
            position: {
                my: "left center",
                at: "right center",
                target: this.options.pointerTarget || this.options.target,
                viewport: $(".wrapper-content"),
                adjust: {
                    resize: this.options.resize || false,
                    method: "flip none",
                    x: -1,
                    y: -3
                }
            },
            show: {
                event: e ? e.type :"click",
                ready: this.options.immediate
            },
            hide: {
                event: "click unfocus"
            },
            events: {
                show: this.onShow.bind(this),
                hidden: this.onHidden.bind(this)
            },
            content: Handlebars.templates.contentPopup(_.extend({
                title: this.options.title
            }, this.options.popupTemplateOptions)),
            style: {
                tip: {
                    height: 15,
                    width: 20
                }
            }
        };

        // Allow for user overrides
        this.options.position && _.extend(qtipOptions.position, this.options.position);
        this.options.show && _.extend(qtipOptions.show, this.options.show);
        this.options.hide && _.extend(qtipOptions.hide, this.options.hide);
        this.options.events && _.extend(qtipOptions.events, this.options.events);
        this.options.style && _.extend(qtipOptions.style, this.options.style);

        this.$target = this.options.target.qtip(qtipOptions, e);

        this.initPopupMixin();

        mediator.on("reflow", this.reposition, this);

        return this;
    };

    ContentPopup.prototype = _.extend({
        size: {
            height: 0,
            width: 0
        },

        onShow: function(e, api) {
            this.$el = api.elements.tooltip;
            this.$loader = this.$el.find(".loading");
            this.$context = this.$el.find(".modal-context");
            api.elements.tooltip.on("click", ".modal-close", this.close.bind(this));

            // View specified, render view
            if (!this.view) {
                if (this.options.view) {
                    if (!this.options.skipLoader) {
                        this.showLoading(this.options.spinnerOptions);
                    } else {
                        _.defer(this.showChrome.bind(this));
                    }
                    this.view = new this.options.view(_.extend({
                        el: api.elements.tooltip.find(".modal-body")
                    }, this.options.viewOptions));
                } else {
                    // No view, append passed in content
                    api.elements.tooltip.find(".modal-body").append(this.options.content);
                    _.defer(this.showChrome.bind(this));
                }
            }
            this.options.onShow(e, api);

            this.watchResize(api);
        },

        onHidden: function(e, api) {
            if (this.view && !!this.options.overwrite) {
                this.view.trigger("close");
                this.view.resetView();
                delete this.view;
                if (this.options.immediate) {
                    api.destroy();
                }
            }
            this.options.onHide(e, api);
            api.elements.tooltip.off("click", ".modal-close");
            clearTimeout(this.resizeTimeout);
        },

        watchResize: function(api) {
            var height = api.elements.tooltip.outerHeight(),
                width = api.elements.tooltip.outerWidth();

            if (height !== this.size.height || width !== this.size.width) {
                this.size.height = height;
                this.size.width = width;
                this.reposition();
            }
            this.resizeTimeout = setTimeout(_.bind(this.watchResize, this, api), 100);
        },

        reposition: function() {
            this.$target.qtip("reposition");
        },

        close: function() {
            this.$target.qtip("hide");
        }
   }, loaderMixin, popupMixin);

    return ContentPopup;
}, "module/content_popup");define(function(require) {
    var mediator = require("module/mediator"),
        ActionDropdown;

    ActionDropdown = function(options) {
        this.options = options ? _.clone(options) : {};
        this.options.actions || (this.options.actions = []);

        // Default qtip options
        var qtipOptions = {
            position: {
                my: "top center",
                at: "bottom center",
                target: this.options.pointerTarget || this.options.target,
                viewport: this.options.viewport || true,
                adjust: {
                    method: "flip none",
                    x: -1,
                    y: -3
                }
            },
            show: {
                event: "click",
                ready: options.immediate
            },
            hide: {
                event: "click unfocus"
            },
            events: {
                show: this.onShow.bind(this),
                hidden: this.onHidden.bind(this)
            },
            content: this.options.actionsTarget || this.template(actions),
            style: {
                classes: "action-dropdown-qtip",
                tip: {
                    height: 10,
                    width: 15
                }
            }
        };

        // Allow for user overrides
        this.options.position && _.extend(qtipOptions.position, this.options.position);
        this.options.show && _.extend(qtipOptions.show, this.options.show);
        this.options.hide && _.extend(qtipOptions.hide, this.options.hide);
        this.options.events && _.extend(qtipOptions.events, this.options.events);
        this.options.style && _.extend(qtipOptions.style, this.options.style);

        this.$target = this.options.target.qtip(qtipOptions);
        mediator.on("reflow", this.reposition, this);

        return this;
    };

    ActionDropdown.prototype = {
        size: {
            height: 0,
            width: 0
        },

        template: function(actions) {
            return Handlebars.templates.actionDropdown({
                actions: _.map(actions, function(action) {
                    action.cid = _.uniqueId();
                    return {
                        cid: action.cid,
                        title: action.title,
                        url: action.url
                    };
                }),
                dropdownClass: this.options.dropdownClass
            });
        },

        onShow: function(e, api) {
            api.elements.tooltip.on("click", ".action", this.onAction.bind(this));
            this.watchResize(api);
        },

        onHidden: function(e, api) {
            this.options.immediate && api.destroy();
            api.elements.tooltip.off("click", ".action");
            clearTimeout(this.resizeTimeout);
        },

        onAction: function(e) {
            var actionCid = $(e.currentTarget).attr("data-cid"),
                action = _.find(this.options.actions, function(action) {
                    return action.cid === actionCid;
                });

            if (action.view) {
                new action.view(action.viewOptions);
            }
            this.close();
        },

        watchResize: function(api) {
            var height = api.elements.tooltip.outerHeight(),
                width = api.elements.tooltip.outerWidth();

            if (height !== this.size.height || width !== this.size.width) {
                this.size.height = height;
                this.size.width = width;
                this.reposition();
            }
            this.resizeTimeout = setTimeout(_.bind(this.watchResize, this, api), 100);
        },

        reposition: function() {
            this.$target.qtip("reposition");
        },

        close: function() {
            this.$target.qtip("hide");
        }
   };

    return ActionDropdown;
}, "module/action_dropdown");define(function(require) {
    var ContentPopup = require("module/content_popup");

    function tooltip(e, options) {
        var templateName = $(e.currentTarget).attr("data-template"),
            template = Handlebars.templates[templateName],
            templateData,
            onShow,
            onHide,
            config;

        options || (options = {});
        templateData = options.data ? options.data.data : {};

        if (template) {
            onShow = function(e, api) {
                api.elements.target.addClass("s-active");
            };
            onHide = function(e, api) {
                api.elements.target.removeClass("s-active");
            };

            config = {
                target: $(e.currentTarget),
                immediate: true,
                skipLoader: true,
                overwrite: true,
                content: template(templateData),
                position: {
                    my: "left center",
                    at: "right center",
                    viewport: true,
                    adjust: {
                        resize: false,
                        x: 0,
                        y: 1
                    }
                },
                show: {
                    solo: true
                },
                style: {
                    height: false,
                    width: false,
                    classes: "tutorial-tip-wrap"
                },
                onShow: onShow,
                onHide: onHide
            };

            if (options.modal) {
                _.extend(config, {
                    events: {
                        visible: function(event, api) {
                            // Set tooltip over the overlay
                            api.elements.tooltip.css("z-index", 401);
                            api.elements.target.css("z-index", 401);
                        }
                    },
                    onShow: function(e, api) {
                        onShow(e, api);
                        $("body").append("<div class='modal-view'></div>");
                        $("body").addClass("modal-mode");
                    },
                    onHide: function(e, api) {
                        onHide(e, api);
                        $("body > .modal-view").fadeOut(function() {
                            $(this).remove();
                        });
                        $("body").removeClass("modal-mode");
                    }
                });
            }

            new ContentPopup(config, e);
        }
    }

    return function(options) {
        $("body").on("click", options.target, tooltip);
        $("body").on("tutorial:tip", options.target, tooltip);
    };
}, "module/help_tip");define(function() {
    "use strict";

    return Backbone.Model.extend({
        initialize: function(attrs, options) {
            options || (options = {});

            if (options.url) {
                this.uri = {
                    url: options.url
                };
            } else if (options.uri) {
                this.uri = options.uri;
            }

            return this;
        },

        url: function() {
            var url = "";

            if (this.uri) {
                url = this.uri.url;
            } else if (this.collection) {
                url = _.result(this.collection, "url");
            }

            return url;
        },

        editUrl: function() {
            // a model may or may not have a url
            try {
                return this.url() + "/edit";
            } catch(e) {
                return "";
            }
        },

        parse: function(raw) {
            var actions,
                interactions;

            raw || (raw = {});

            // BLASPHEMOUS!!!
            if (raw.data && raw.data.data) {
                raw = raw.data;
            }

            this.uri = raw.uri || this.uri;
            this.view = raw.view || this.view || {};
            this.interactions = {};
            this.actions = {};

            interactions = this.view.interaction;
            if (interactions) {
                _.each(interactions, _.bind(this._buildNestedCollection, this, this.interactions));
            }
            actions = this.view.action;
            if (actions) {
                _.each(actions, _.bind(this._buildNestedCollection, this, this.actions));
            }

            return raw.data;
        },

        _buildNestedCollection: function(obj, value, key) {
            var BaseCollection = require("module/collections/base");

            obj[key] = new BaseCollection(value.data.items, {
                uri: value.uri,
                parse: true
            });
        },

        // Returns a "unique" key identifier for the collection
        getCacheKey: function() {
            return this.url();
        },

        toData: function() {
            var interactionData,
                data = {
                uri: _.clone(this.uri),
                view: _.clone(this.view),
                data: _.clone(this.attributes)
            };

            _.each(this.interactions, function(interaction, name) {
                interactionData = interaction.toData();
                if (interactionData) {
                    data.view.interaction[name] = interactionData.data;
                    data.view.interaction[name].data.count = data.view.interaction[name].data.items.length;
                }
            });

            return data;
        },

        toHandlebars: function() {
            var json = _.clone(this.view || {});
            json.cid = this.cid;
            json.editUrl = this.editUrl();

            return json;
        },

        updateCache: function() {
            // Notify fetchCached that we should update the cache
            this.collection && this.collection.updateCache();
            this.trigger("updateCache", this, this.collection);
        },

        save: function(attrs, options) {
            attrs || (attrs = {});
            options || (options = {});

            if (this.uri) {
                options.data || (options.data = {});
                _.extend(options.data, {
                    _token: this.uri.token
                });
            }

            return Backbone.Model.prototype.save.call(this, attrs, options);
        },

        destroy: function(options) {
            var paramData;

            paramData = $.param({
                _token: this.uri.token
            });
            options = options ? _.clone(options) : {};
            options = _.extend({
                data: paramData
            }, options);

            return Backbone.Model.prototype.destroy.call(this, options);
        },

        // Creates a new collection if not already defined and returns
        // a fetch promise, otherwise it returns a promise which will resolve
        // immediately. Takes a key name to store the collection on the object,
        // a Collection constructor, and collection options.
        fetchStatic: function(key, Collection, options) {
            var collection = this[key],
                deferred,
                promise;

            if (!collection) {
                collection = new Collection([], options);
                this[key] = collection;
                promise = collection.fetch(options);
            } else {
                deferred = $.Deferred();
                promise = deferred.promise();
                deferred.resolve(collection);
                if (options.success) {
                    _.defer(options.success, collection);
                }
            }

            // Always return a promise
            return promise;
        }
    });
}, "module/models/base");define(function(require) {
    var BaseModel = require("module/models/base");

    return BaseModel.extend({});
}, "module/models/user");define(function() {
    "use strict";

    var Backbone = require("Backbone"),
        loaderMixin = require("module/mixins/loader"),
        TrackingModule = require("module/tracking"),
        mediator = require("module/mediator"),
        utils = require("module/utils");

    return Backbone.View.extend({
        mediator: mediator,

        initialize: function(options) {
            options || (options = {});
            options.template && !this.template && (this.template = options.template);
            _.extend(this, loaderMixin);
            new TrackingModule(this);
        },

        stopProp: function(e) {
            if (e && e.stopPropagation) {
                e.stopPropagation();
                e.preventDefault();
            }
        },

        stopPropagation: function(e) {
            e && e.stopPropagation && e.stopPropagation();
        },

        resetView: function() {
            this.hideLoader();
            this.$el.html("").css({
                height: "auto"
            });
            this.dropdown && this.dropdown.remove();
            this.undelegateEvents();
            this.infiniteScroll && this.infiniteScroll.enableFetch();
        },

        onError: function(obj, response) {
            var message = "";

            if (response.statusText === "abort" || response.status === 0) {
                return;
            }

            try {
                response = JSON.parse(response.responseText);
                message = response.meta.message;
            } catch (e) {
                message = "Don't worry. The engineers will pay dearly for this outage.";
            }

            this.hideLoader && this.hideLoader();
            this.$el.find(".no-results").remove();
            this.$el.after(Handlebars.templates.onError({
                message: message
            }));
        },

        initScroller: function(){
            var $scrollerWrap = this.$el.find('.antiscroll-wrap'),
                $scrollerInner = this.$el.find('.antiscroll-inner');

            if (!$scrollerWrap.length && this.$el.hasClass("antiscroll-wrap")) {
                $scrollerWrap = this.$el;
            }

            if ($scrollerWrap) {
                $scrollerWrap.width($scrollerWrap.width());
                $scrollerInner.width($scrollerWrap.width());
                $scrollerWrap.find(".antiscroll-inner").css({
                    "height": $scrollerWrap.height() + "px",
                    "overflow-y": "scroll"
                });
            }
            if (!this.options.osScroller && !utils.isMobile()) {
                this.scroller && this.scroller.destroy();
                this.scroller = $scrollerWrap.antiscroll({
                    x: false
                }).data('antiscroll');
            }
        },

        getClosestById: function(e) {
            return this.collection.get($(e.currentTarget).closest("[data-id]").attr("data-id"));
        },

        getItemById: function(e, closest) {
            var item;

            if (closest) {
                item = this.collection.get($(e.currentTarget).closest(closest).attr("data-id"));
            } else {
                item = this.collection.get($(e.currentTarget).attr("data-id"));
            }

            return item;
        },

        getItemByCid: function(e) {
            return this.collection.getByCid($(e.currentTarget).attr("data-cid"));
        }
    });
}, "module/views/base");define(function(require) {
    var BaseView = require("module/views/base"),
        popupMixin = require("module/mixins/popup"),
        mediator = require("module/mediator");

    return BaseView.extend({
        el: "body",
        template: Handlebars.templates.modal,

        events: {
            "click .modal-close": "close",
            "click .modal-wrap": "stopPropagation",
            "keyup": "keyPress"
        },

        initialize: function(options) {
            BaseView.prototype.initialize.call(this, options);
            this.templateOptions = options.templateOptions || {};
            options.animate && (this.templateOptions.animate = options.animate);
            this.ModalView = options.view;
            this.viewOptions = options.viewOptions || {};
            this.afterRender = options.afterRender || function() {};
            this.skipLoader = options.skipLoader || false;

            if (!this.options.disableClickToClose) {
                this.events = _.extend({}, this.events, {
                    "click": "close"
                });
            }

            _.extend(this, popupMixin);
            this.initPopupMixin();

            this.viewOptions = _.extend({
                el: ".modal-body"
            }, this.viewOptions);

            BaseView.prototype.initialize.call(this, options);

            this.render();
        },

        render: function() {
            this.$el.append(this.template(_.extend({
                modalClass: this.options.modalClass,
                title: this.options.title,
                subTitle: this.options.subTitle,
                noCloseButton: this.options.noCloseButton || this.options.unclosable
            }, this.templateOptions)));
            this.$el.addClass("modal-mode");
            this.$loader = this.$el.find(".loading");
            this.$context = this.$el.find(".modal-context");

            if (!this.skipLoader && !this.options.contentTemplate) {
                this.showLoading();
            } else {
                _.defer(this.showChrome.bind(this));
            }

            if (this.ModalView) {
                this.modalView = new this.ModalView(this.viewOptions);
                this.modalView.on("close", this.close, this);
            } else if (this.options.contentTemplate) {
                this.$el.find(".modal-body").html(
                    this.options.contentTemplate(this.options.contentTemplateData)
                );
            }
            this.afterRender(this);
            this.trigger("afterRender");
        },

        keyPress: function(e) {
            if (e.keyCode === 27) {
                this.close();
            }
        },

        close: function(options) {
            options || (options = {});

            if (this.options.unclosable) {
                return;
            }

            if (options.animate) {
                this.$el.find(".modal-view").fadeOut(this._close.bind(this));
            } else {
                this._close();
            }
        },

        _close: function() {
            this.undelegateEvents();
            this.$el.removeClass("modal-mode");
            this.$el.find(".modal-view").remove();
            this.trigger("close");
            this.modalView && this.modalView.trigger("modal:close");
        }
    });
}, "module/modal");define(function(require) {
    "use strict";

    var BaseView = require("module/views/base"),
        mediator = require("module/mediator");

    return BaseView.extend({
        successMessageDelay: 2000,

        events: {
            "click .close": "close"
        },

        initialize: function(options) {
            _.bindAll(this, "showConfirm", "confirmCancel", "onConfirm", "close", "onSuccess", "onError");
            BaseView.prototype.initialize.call(this, options);
        },

        showConfirm: function(options) {
            mediator.trigger("modal:showContext", Handlebars.templates.confirm(options));
            options.onConfirm && (this.onConfirm = options.onConfirm);

            $("#confirm").off("click", this.onConfirm);
            $("#confirm").on("click", this.onConfirm.bind(this));
            $("#confirm-cancel").off("click", this.confirmCancel);
            $("#confirm-cancel").on("click", this.confirmCancel.bind(this));
        },

        confirmCancel: function(e) {
            this.stopProp(e);
            mediator.trigger("modal:hideContext");
        },

        onConfirm: function(e) {
            this.stopProp(e);
        },

        showLoading: function() {
            mediator.trigger("modal:showLoading");
        },

        hideLoading: function() {
            mediator.trigger("modal:hideLoading");
        },

        close: function(e) {
            this.stopProp(e);
            this.undelegateEvents();
            $("#confirm").off("click", this.onConfirm);
            $("#confirm-cancel").off("click", this.confirmCancel);

            this.trigger("close", e);
            mediator.trigger("modal:close", e);
        },

        onSuccess: function(model, response) {
            mediator.trigger("modal:hideLoading");
            mediator.trigger("modal:showContext", response.meta.message);
            setTimeout(function() {
                mediator.trigger("modal:hideContext", {
                    close: true,
                    animate: true
                });
            }, this.successMessageDelay);
        },

        onError: function(model, response) {
            response = JSON.parse(response.responseText);

            mediator.trigger("modal:hideLoading");
            mediator.trigger("modal:showContext", response.meta.message);
            setTimeout(function() {
                mediator.trigger("modal:hideContext", {
                    animate: true
                });
            }, this.successMessageDelay);
        }
    });
}, "module/views/overlay_view");define(function(require) {
    var OverlayView = require("module/views/overlay_view");

    return OverlayView.extend({
        template: Handlebars.templates.signin,

        events: {
            "click #back": "back"
        },

        initialize: function(options) {
            OverlayView.prototype.initialize.call(this, options);

            this.render();
        },

        render: function() {

            this.$el.html(this.template({
                uri: this.options.uri,
                next: this.options.next,
                noBackButton: this.options.noBackButton
            }));

            this.mediator.trigger("modal:update:title", "Please Sign-In");
        },

        back: function(e) {
            this.stopProp(e);
            this.resetView();
            this.trigger("back");
        }
    });
}, "module/views/signin_view");define(function(require) {
    var BaseView = require("module/views/base"),
        CaptchaView = require("module/views/signup_captcha_view");

    return BaseView.extend({
        events: {
            "submit #submit-form": "submit",
            "click .submit": "submit"
        },

        initialize: function(options) {
            var first = true,
                error,
                errorLength = 0,
                errorText,
                errorToShowPrimary,
                errorToShowSecondary;

            BaseView.prototype.initialize.call(this, options);
            try {
                if (this.model.view.data.externalServices.facebook.token) {
                    this.facebookConnected = true;
                }
            } catch (e) {}
            $('input, textarea').placeholder();

            if (this.model.view.errors) {
                for (error in this.model.view.errors) {
                    errorLength += 1;
                    if (error.match(/birth/) || error === "nucaptcha-answer") {
                        errorToShowSecondary = this.model.view.errors[error];
                    } else {
                        errorToShowPrimary = this.model.view.errors[error];
                    }
                }
                if (errorToShowPrimary && errorToShowPrimary.text) {
                    errorText = errorToShowPrimary.text;
                } else if (errorToShowSecondary) {
                    errorText = errorToShowSecondary.text;
                }
                if (error === "nucaptcha-answer" && errorLength === 1) {
                    this.showCaptcha(errorText);
                } else {
                    this.onError(errorText);
                }
            }
        },

        submit: function(e) {
            var self = this,
                requiredList = [];


            this.$el.find("input, select").each(function() {
                requiredList.push(self.checkRequired($(this)));
            });
            if (!this.facebookConnected) {
                this.stopProp(e);
                if (_.compact(requiredList).length === 0) {
                    this.showCaptcha();
                }
            }
        },

        showCaptcha: function(error) {
            var captchaView,
                $signupText,
                $fieldset;

            $fieldset = this.$el.find("#user-data-form").addClass("fadeOut");
            $signupText = this.$el.find("#sign-up-email").addClass("fadeOut");
            setTimeout(function() {
                $fieldset.hide();
                $signupText.hide();
                captchaView = new CaptchaView({
                    className: "captcha-wrap fadeOut",
                    model: this.model,
                    error: error
                });
                this.$el.find("#signup-form").append(captchaView.$el);
                captchaView.$el.removeClass("fadeOut");
                setTimeout(function() {
                    this.$el.find("#nucaptcha-answer").focus();
                }.bind(this), 300);
                // Facebook captcha skip click
                this.$el.find(".connect-service.facebook").on("click", function(e) {
                    e.stopImmediatePropagation();
                    SU.ServicesAuth.open('facebook', 'captcha');
                });
                this.undelegateEvents();
            }.bind(this), 300);
        },

        validateDate: function($fieldWrap) {
            var data = {},
                $month,
                month,
                $day,
                day,
                $year,
                year;

            $month = $fieldWrap.find(".validate.month");
            month = $month.val();
            $day = $fieldWrap.find(".validate.day");
            day = $day.val();
            $year = $fieldWrap.find(".validate.year");
            year = $year.val();

            // check if date has changed
            if (!month || !day || !year) {
                return false;
            }

            data[$month.attr("name")] = month;
            data[$day.attr("name")] = day;
            data[$year.attr("name")] = year;

            return data;
        },

        checkRequired: function($el) {
            var radio = false,
                present = false,
                value,
                $target,
                $radio;

            $target = $el.closest(".validate-wrap");
            radio = $el.is("[type='radio']");

            if (!$target.length || $target.hasClass("hidden")) {
                return;
            }

            if ($target.attr("data-validate-date")) {
                // If there is a date, required check passes, no matter what it is.
                present = !!this.validateDate($target);
            } else if (radio) {
                // A radio is valid if the one item is checked.
                $radio = $target.find("input[type='radio'][name='" + $el.attr("name") + "']:checked");
                present = !!$radio.length;
            } else {
                value = $el.val().replace(/^\s*|\s*$/g, "");
                present = (value && $el.attr("data-default") !== value);
            }

            if (!present) {
                this.onError("All fields are required.");
                return true;
            }
        },

        onError: function(str) {
            this.$el.find(".error-message").removeClass("hidden fadeOut").text(str);
        }
    });
}, "module/views/signup_view");define(function(require) {
    var OverlayView = require("module/views/overlay_view");

    return OverlayView.extend({
        initialize: function(options) {
            OverlayView.prototype.initialize.call(this, options);
            this.template = Handlebars.templates[options.type];
            this.templateOptions = options.data || {};

            this.render();
        },

        render: function() {
            this.$el.html(this.template(this.templateOptions));
            this.updateTitle();

            return this;
        },

        updateTitle: function() {
            var $target = this.$el.find(".title");
                title = $target.text();

            $target.remove();
            $(".modal-title").text(title);
        }
    });
}, "module/views/tutorial_view");define(function(require) {
    var Backbone = require("Backbone"),
        mediator = require("module/mediator");

    return Backbone.Router.extend({
        initialize: function(options) {
            mediator.on("navigate", this.navigate, this);

            var re = new RegExp("(\/)+$", "g");
            /*jshint regexp: false*/
            this.route(/(.*)\/+$/, "trailFix", function (id) {
                // remove all trailing slashes if more than one
                id = id.replace(re, '');
                this.navigate(id, {
                    trigger: true,
                    replace: true
                });
            });
        },

        route: function (route, name, callback) {
            Backbone.Router.prototype.route.call(this, route, name, function () {
                this.trigger.apply(this, ["change", route, name].concat(arguments));
                callback.apply(this, arguments);
            });
        }
    });
}, "module/routers/base");define(function(require) {
    var TutorialView = require("module/views/tutorial_view"),
        Modal = require("module/modal"),
        mediator = require("module/mediator");

    return {
        initialize: function(options) {
            this.tutorialUrls = options.tutorialUrls;

            // Setup routes for each tutorial
            mediator.on("route", this.onRoute, this);
            this.onRoute(window.location.pathname);
        },

        onRoute: function(route) {
            var tutorial = this.tutorialUrls[route];

            if (tutorial) {
                delete this.tutorialUrls[route];
                _.delay(function() {
                    $(".tutorial-tip[data-template='" + tutorial.type + "']").trigger("tutorial:tip", [{
                        modal: true,
                        data: tutorial
                    }]);
                }, 300);

                $.post(tutorial.uri.url, {
                    type: tutorial.type,
                    _token: tutorial.uri.token
                }, '', 'json');
            }
        }
    };
}, "module/routers/tutorial_machine");