/*!
 * jQuery UI 1.8.17
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */(function(a,b){function d(b){return!a(b).parents().andSelf().filter(function(){return a.curCSS(this,"visibility")==="hidden"||a.expr.filters.hidden(this)}).length}function c(b,c){var e=b.nodeName.toLowerCase();if("area"===e){var f=b.parentNode,g=f.name,h;if(!b.href||!g||f.nodeName.toLowerCase()!=="map")return!1;h=a("img[usemap=#"+g+"]")[0];return!!h&&d(h)}return(/input|select|textarea|button|object/.test(e)?!b.disabled:"a"==e?b.href||c:c)&&d(b)}a.ui=a.ui||{};a.ui.version||(a.extend(a.ui,{version:"1.8.17",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}}),a.fn.extend({propAttr:a.fn.prop||a.fn.attr,_focus:a.fn.focus,focus:function(b,c){return typeof b=="number"?this.each(function(){var d=this;setTimeout(function(){a(d).focus(),c&&c.call(d)},b)}):this._focus.apply(this,arguments)},scrollParent:function(){var b;a.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?b=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(a.curCSS(this,"position",1))&&/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0):b=this.parents().filter(function(){return/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!b.length?a(document):b},zIndex:function(c){if(c!==b)return this.css("zIndex",c);if(this.length){var d=a(this[0]),e,f;while(d.length&&d[0]!==document){e=d.css("position");if(e==="absolute"||e==="relative"||e==="fixed"){f=parseInt(d.css("zIndex"),10);if(!isNaN(f)&&f!==0)return f}d=d.parent()}}return 0},disableSelection:function(){return this.bind((a.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),a.each(["Width","Height"],function(c,d){function h(b,c,d,f){a.each(e,function(){c-=parseFloat(a.curCSS(b,"padding"+this,!0))||0,d&&(c-=parseFloat(a.curCSS(b,"border"+this+"Width",!0))||0),f&&(c-=parseFloat(a.curCSS(b,"margin"+this,!0))||0)});return c}var e=d==="Width"?["Left","Right"]:["Top","Bottom"],f=d.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+d]=function(c){if(c===b)return g["inner"+d].call(this);return this.each(function(){a(this).css(f,h(this,c)+"px")})},a.fn["outer"+d]=function(b,c){if(typeof b!="number")return g["outer"+d].call(this,b);return this.each(function(){a(this).css(f,h(this,b,!0,c)+"px")})}}),a.extend(a.expr[":"],{data:function(b,c,d){return!!a.data(b,d[3])},focusable:function(b){return c(b,!isNaN(a.attr(b,"tabindex")))},tabbable:function(b){var d=a.attr(b,"tabindex"),e=isNaN(d);return(e||d>=0)&&c(b,!e)}}),a(function(){var b=document.body,c=b.appendChild(c=document.createElement("div"));a.extend(c.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),a.support.minHeight=c.offsetHeight===100,a.support.selectstart="onselectstart"in c,b.removeChild(c).style.display="none"}),a.extend(a.ui,{plugin:{add:function(b,c,d){var e=a.ui[b].prototype;for(var f in d)e.plugins[f]=e.plugins[f]||[],e.plugins[f].push([c,d[f]])},call:function(a,b,c){var d=a.plugins[b];if(!!d&&!!a.element[0].parentNode)for(var e=0;e<d.length;e++)a.options[d[e][0]]&&d[e][1].apply(a.element,c)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(b,c){if(a(b).css("overflow")==="hidden")return!1;var d=c&&c==="left"?"scrollLeft":"scrollTop",e=!1;if(b[d]>0)return!0;b[d]=1,e=b[d]>0,b[d]=0;return e},isOverAxis:function(a,b,c){return a>b&&a<b+c},isOver:function(b,c,d,e,f,g){return a.ui.isOverAxis(b,d,f)&&a.ui.isOverAxis(c,e,g)}}))})(jQuery);


/*!
 * jQuery UI Widget 1.8.17
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */(function(a,b){if(a.cleanData){var c=a.cleanData;a.cleanData=function(b){for(var d=0,e;(e=b[d])!=null;d++)try{a(e).triggerHandler("remove")}catch(f){}c(b)}}else{var d=a.fn.remove;a.fn.remove=function(b,c){return this.each(function(){c||(!b||a.filter(b,[this]).length)&&a("*",this).add([this]).each(function(){try{a(this).triggerHandler("remove")}catch(b){}});return d.call(a(this),b,c)})}}a.widget=function(b,c,d){var e=b.split(".")[0],f;b=b.split(".")[1],f=e+"-"+b,d||(d=c,c=a.Widget),a.expr[":"][f]=function(c){return!!a.data(c,b)},a[e]=a[e]||{},a[e][b]=function(a,b){arguments.length&&this._createWidget(a,b)};var g=new c;g.options=a.extend(!0,{},g.options),a[e][b].prototype=a.extend(!0,g,{namespace:e,widgetName:b,widgetEventPrefix:a[e][b].prototype.widgetEventPrefix||b,widgetBaseClass:f},d),a.widget.bridge(b,a[e][b])},a.widget.bridge=function(c,d){a.fn[c]=function(e){var f=typeof e=="string",g=Array.prototype.slice.call(arguments,1),h=this;e=!f&&g.length?a.extend.apply(null,[!0,e].concat(g)):e;if(f&&e.charAt(0)==="_")return h;f?this.each(function(){var d=a.data(this,c),f=d&&a.isFunction(d[e])?d[e].apply(d,g):d;if(f!==d&&f!==b){h=f;return!1}}):this.each(function(){var b=a.data(this,c);b?b.option(e||{})._init():a.data(this,c,new d(e,this))});return h}},a.Widget=function(a,b){arguments.length&&this._createWidget(a,b)},a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:!1},_createWidget:function(b,c){a.data(c,this.widgetName,this),this.element=a(c),this.options=a.extend(!0,{},this.options,this._getCreateOptions(),b);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()}),this._create(),this._trigger("create"),this._init()},_getCreateOptions:function(){return a.metadata&&a.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName),this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled")},widget:function(){return this.element},option:function(c,d){var e=c;if(arguments.length===0)return a.extend({},this.options);if(typeof c=="string"){if(d===b)return this.options[c];e={},e[c]=d}this._setOptions(e);return this},_setOptions:function(b){var c=this;a.each(b,function(a,b){c._setOption(a,b)});return this},_setOption:function(a,b){this.options[a]=b,a==="disabled"&&this.widget()[b?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",b);return this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_trigger:function(b,c,d){var e,f,g=this.options[b];d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent;if(f)for(e in f)e in c||(c[e]=f[e]);this.element.trigger(c,d);return!(a.isFunction(g)&&g.call(this.element[0],c,d)===!1||c.isDefaultPrevented())}}})(jQuery);


/*
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function(a){var r=a.fn.domManip,d="_tmplitem",q=/^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,b={},f={},e,p={key:0,data:{}},i=0,c=0,l=[];function g(g,d,h,e){var c={data:e||(e===0||e===false)?e:d?d.data:{},_wrap:d?d._wrap:null,tmpl:null,parent:d||null,nodes:[],calls:u,nest:w,wrap:x,html:v,update:t};g&&a.extend(c,g,{nodes:[],parent:d});if(h){c.tmpl=h;c._ctnt=c._ctnt||c.tmpl(a,c);c.key=++i;(l.length?f:b)[i]=c}return c}a.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(f,d){a.fn[f]=function(n){var g=[],i=a(n),k,h,m,l,j=this.length===1&&this[0].parentNode;e=b||{};if(j&&j.nodeType===11&&j.childNodes.length===1&&i.length===1){i[d](this[0]);g=this}else{for(h=0,m=i.length;h<m;h++){c=h;k=(h>0?this.clone(true):this).get();a(i[h])[d](k);g=g.concat(k)}c=0;g=this.pushStack(g,f,i.selector)}l=e;e=null;a.tmpl.complete(l);return g}});a.fn.extend({tmpl:function(d,c,b){return a.tmpl(this[0],d,c,b)},tmplItem:function(){return a.tmplItem(this[0])},template:function(b){return a.template(b,this[0])},domManip:function(d,m,k){if(d[0]&&a.isArray(d[0])){var g=a.makeArray(arguments),h=d[0],j=h.length,i=0,f;while(i<j&&!(f=a.data(h[i++],"tmplItem")));if(f&&c)g[2]=function(b){a.tmpl.afterManip(this,b,k)};r.apply(this,g)}else r.apply(this,arguments);c=0;!e&&a.tmpl.complete(b);return this}});a.extend({tmpl:function(d,h,e,c){var i,k=!c;if(k){c=p;d=a.template[d]||a.template(null,d);f={}}else if(!d){d=c.tmpl;b[c.key]=c;c.nodes=[];c.wrapped&&n(c,c.wrapped);return a(j(c,null,c.tmpl(a,c)))}if(!d)return[];if(typeof h==="function")h=h.call(c||{});e&&e.wrapped&&n(e,e.wrapped);i=a.isArray(h)?a.map(h,function(a){return a?g(e,c,d,a):null}):[g(e,c,d,h)];return k?a(j(c,null,i)):i},tmplItem:function(b){var c;if(b instanceof a)b=b[0];while(b&&b.nodeType===1&&!(c=a.data(b,"tmplItem"))&&(b=b.parentNode));return c||p},template:function(c,b){if(b){if(typeof b==="string")b=o(b);else if(b instanceof a)b=b[0]||{};if(b.nodeType)b=a.data(b,"tmpl")||a.data(b,"tmpl",o(b.innerHTML));return typeof c==="string"?(a.template[c]=b):b}return c?typeof c!=="string"?a.template(null,c):a.template[c]||a.template(null,q.test(c)?c:a(c)):null},encode:function(a){return(""+a).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;")}});a.extend(a.tmpl,{tag:{tmpl:{_default:{$2:"null"},open:"if($notnull_1){__=__.concat($item.nest($1,$2));}"},wrap:{_default:{$2:"null"},open:"$item.calls(__,$1,$2);__=[];",close:"call=$item.calls();__=call._.concat($item.wrap(call,__));"},each:{_default:{$2:"$index, $value"},open:"if($notnull_1){$.each($1a,function($2){with(this){",close:"}});}"},"if":{open:"if(($notnull_1) && $1a){",close:"}"},"else":{_default:{$1:"true"},open:"}else if(($notnull_1) && $1a){"},html:{open:"if($notnull_1){__.push($1a);}"},"=":{_default:{$1:"$data"},open:"if($notnull_1){__.push($.encode($1a));}"},"!":{open:""}},complete:function(){b={}},afterManip:function(f,b,d){var e=b.nodeType===11?a.makeArray(b.childNodes):b.nodeType===1?[b]:[];d.call(f,b);m(e);c++}});function j(e,g,f){var b,c=f?a.map(f,function(a){return typeof a==="string"?e.key?a.replace(/(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g,"$1 "+d+'="'+e.key+'" $2'):a:j(a,e,a._ctnt)}):e;if(g)return c;c=c.join("");c.replace(/^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/,function(f,c,e,d){b=a(e).get();m(b);if(c)b=k(c).concat(b);if(d)b=b.concat(k(d))});return b?b:k(c)}function k(c){var b=document.createElement("div");b.innerHTML=c;return a.makeArray(b.childNodes)}function o(b){return new Function("jQuery","$item","var $=jQuery,call,__=[],$data=$item.data;with($data){__.push('"+a.trim(b).replace(/([\\'])/g,"\\$1").replace(/[\r\t\n]/g," ").replace(/\$\{([^\}]*)\}/g,"{{= $1}}").replace(/\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,function(m,l,k,g,b,c,d){var j=a.tmpl.tag[k],i,e,f;if(!j)throw"Unknown template tag: "+k;i=j._default||[];if(c&&!/\w$/.test(b)){b+=c;c=""}if(b){b=h(b);d=d?","+h(d)+")":c?")":"";e=c?b.indexOf(".")>-1?b+h(c):"("+b+").call($item"+d:b;f=c?e:"(typeof("+b+")==='function'?("+b+").call($item):("+b+"))"}else f=e=i.$1||"null";g=h(g);return"');"+j[l?"close":"open"].split("$notnull_1").join(b?"typeof("+b+")!=='undefined' && ("+b+")!=null":"true").split("$1a").join(f).split("$1").join(e).split("$2").join(g||i.$2||"")+"__.push('"})+"');}return __;")}function n(c,b){c._wrap=j(c,true,a.isArray(b)?b:[q.test(b)?b:a(b).html()]).join("")}function h(a){return a?a.replace(/\\'/g,"'").replace(/\\\\/g,"\\"):null}function s(b){var a=document.createElement("div");a.appendChild(b.cloneNode(true));return a.innerHTML}function m(o){var n="_"+c,k,j,l={},e,p,h;for(e=0,p=o.length;e<p;e++){if((k=o[e]).nodeType!==1)continue;j=k.getElementsByTagName("*");for(h=j.length-1;h>=0;h--)m(j[h]);m(k)}function m(j){var p,h=j,k,e,m;if(m=j.getAttribute(d)){while(h.parentNode&&(h=h.parentNode).nodeType===1&&!(p=h.getAttribute(d)));if(p!==m){h=h.parentNode?h.nodeType===11?0:h.getAttribute(d)||0:0;if(!(e=b[m])){e=f[m];e=g(e,b[h]||f[h]);e.key=++i;b[i]=e}c&&o(m)}j.removeAttribute(d)}else if(c&&(e=a.data(j,"tmplItem"))){o(e.key);b[e.key]=e;h=a.data(j.parentNode,"tmplItem");h=h?h.key:0}if(e){k=e;while(k&&k.key!=h){k.nodes.push(j);k=k.parent}delete e._ctnt;delete e._wrap;a.data(j,"tmplItem",e)}function o(a){a=a+n;e=l[a]=l[a]||g(e,b[e.parent.key+n]||e.parent)}}}function u(a,d,c,b){if(!a)return l.pop();l.push({_:a,tmpl:d,item:this,data:c,options:b})}function w(d,c,b){return a.tmpl(a.template(d),c,b,this)}function x(b,d){var c=b.options||{};c.wrapped=d;return a.tmpl(a.template(b.tmpl),b.data,c,b.item)}function v(d,c){var b=this._wrap;return a.map(a(a.isArray(b)?b.join(""):b).filter(d||"*"),function(a){return c?a.innerText||a.textContent:a.outerHTML||s(a)})}function t(){var b=this.nodes;a.tmpl(null,null,null,this).insertBefore(b[0]);a(b).remove()}})(jQuery);
 /**
 * @author dmitry.petrov@sup.com (Dmitry Petrov)
 * @fileoverview Base widget for all livejournal widgets.
 */

/**
 * @name $.lj.basicWidget
 * @requires $.ui.core, $.ui.widget
 * @class Base widget for all livejournal widgets.<br />
 *	Basic widget adds pub/sub system to the widget hierarchy. By convention widgets add prefix equal
 *	to the widget name of the most parent element who fires it. E.g. if someWidget and subSomeWidget
 *	that extends someWidget do fire open event, it should be prefixed with someWidget - someWidget/open.
 *
 */
( function( $ ) {

	var __callbacks = {},

		//these events we set once and for all widget instances
		globalEvents = {
			documentClick: false
		}

	/** @lends $.lj.basicWidget.prototype */
	$.widget( 'lj.basicWidget', {

		/** 
		 * Default options for widgets.
		 * @type Object
		 * @private
		 */
		options: {
			/**
			 * Object contains strings with class names that are used within widget.
			 */
			classNames: {},
			/**
			 * Object contains strings with selectors that are used to find nodes within widget.
			 */
			selectors: {},
			/**
			 * Object contains translation strings for a widget. Widget should not contain hardcoded strings.
			 */
			ml: {},
			/**
			 * Object contains strings with templates, that are used to build content within widget.
			 */
			tmpl: {}
		},

		_create: function() {
			/**
			 * Contains all events that should not trigger events on next fire for this widget.
			 * @type Object
			 */
			this.__suppressedEvents = {};
		},

		/**
		 * Bind common events for the widget
		 */
		_bindControls: function() {
			var widget = this;

			/**
			 * documentClick
			 */
			if( !globalEvents.documentClick ) {
				$( document ).click( function( ev ) {
					widget._fire( 'documentClick', [], true );
				} );

				globalEvents.documentClick = true;
			}
		},

		_setOption: function(name, val) {
			switch (name) {
				case 'selectors':
				case 'classNames':
				case 'tmpl':
				case 'templates':
					this.options[name] = $.extend(this.options[name], val);
					return;
					break;
			}

			$.Widget.prototype._setOption.apply(this, arguments);
		},

		/**
		 * Subscribe to the event with the callback.
		 *
		 * @param {String} type Event type.
		 * @param {Function} callback Function that should be fired on the event.
		 */
		_on: function( type, callback ) {
			if( !( type in __callbacks ) ) {
				__callbacks[ type ] = [];
			}

			__callbacks[ type ].push( {
				fn: callback,
				owner: this
			} );
		},

		/**
		 * Remove subscription on the event.
		 *
		 * @param {String} type Event type.
		 * @param {Function=} callback Callback function. If parameter is omitted, function will remove all
		 *     callbacks of this instance from the subscription on this type of event.
		 */
		_off: function( type, callback ) {
			if( !( type in __callbacks ) ) { return; }

			var cbs = __callbacks[ type ];
			for( var i = 0; i < cbs.length; ++i ) {
				if( ( callback && cbs[ i ].fn === callback ) || ( cbs[i].owner === this ) ) {
					cbs.splice( i, 1 );
				}
			}
		},

		/**
		 * Dispatch event.
		 *
		 * @param {String} type Event type.
		 * @param {Array|[]} args array with arguments that will be passed to the callback functions.
		 * @param {Boolean|False} includeOwner If false the message is not recieved by
		 *     the object that dispatched it.
		 */
		_fire: function( type, args, includeOwner ) {
			args = args || [];
			includeOwner = includeOwner || false;
			if( type in __callbacks ) {
				var cbs = __callbacks[ type ],
					i = -1;

				while( cbs[ ++i ] ) {
					if( !includeOwner && cbs[ i ].owner === this ) { continue; }
					if( type in cbs[ i ].owner.__suppressedEvents ) { continue; }
					cbs[ i ].fn.apply( null, args );
				}

				//we delete supressed event flag only after firing event because 
				//wedget can subscribe more than one callback
				while(cbs[ --i ]) {
					if( type in cbs[ i ].owner.__suppressedEvents ) {
						delete cbs[ i ].owner.__suppressedEvents[ type ];
					}
				}
			}
		},

		/**
		 * Prevent event from being trigger on this widget instance on next fire.
		 *     An event after next will be processed as normal
		 */
		_suppressNextEvent: function( eventName ) {
			this.__suppressedEvents[ eventName ] = true;
		},

		/**
		 * Remove all subscriptions on widget distruction. If overriden, this method should be
		 *     also caled.
		 */
		_destroy: function() {
			var cbs;
			for( var type in __callbacks ) {
				cbs = __callbacks[ type ];
				for( var i = 0; i < cbs.length; ++i ) {
					if( cbs[i].owner === this ) {
						cbs.splice( i, 1 )
					}
				}
			}
		},

		/**
		 * Find element inside the widget and return it. Note, that function caches the elements
		 * and assigns them ti the widget object with the name _{name}
		 *
		 * @param {string} name Name of the selector to search in this.options.selectors
		 */
		_el: function(name) {
			var method = '_' + name;

			if (!this[method]) { this[method] = this.element.find(this.options.selectors[name]); };

			return this[method];
		},

		/**
		 * Fetch the class name from the options.
		 *
		 * @param {string} name Name of the class name to search in this.options.classNames.
		 */
		_cl: function(name) {
				return this.options.classNames[name];
		},

		/**
		 * Fetch the selector from the options.
		 *
		 * @param {string} name Name of the selector to search in this.options.selectors
		 */
		_s: function(name) {
				return this.options.selectors[name];
		}
	} );
} )( jQuery );

/*!
 * LiveJournal Bubble
 * use it to wrap some content with pop-up "bubble" -
 * it'll be positioned relative to "target" param (also can be passed with public method "show" invocation)
 *
 * Copyright 2011, sergey.zhirkov@sup.com
 *
 * http://docs.jquery.com/UI
 * 
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *
 * Usage:
 *	<script>
 *		$('div.with-bubble-content')
 *			.bubble()
 *			.bubble('publicMethod')
 *			.bubble({ many: options })
 *			.bubble('option', 'getOptionName')
 *			.bubble('option', 'setOptionName', 'setOptionValue')
 *			.bind('bubblehide', function( ev ){}); // bind some event
 *	</script>
 */

(function ($, window) {

	var LJBubble = {
		
		options: {
			target: null,
			currentTarget: null,
			
			hoverTimer: null,
			hoverDelay: 600,
			showDelay: 0,

			position: {
				x: 0,
				y: 0
			},

			/**
			 * offset object can contain directly fields x and y or fields l,r,t,b,tl,tr,bl,br
			 *    that contain offset object for the bubble in the exact position.
			 *  Priority order: x,y -> tl,bl,tr,br -> t,b -> l,r
			 */
			offset: {},
			
			// horizontal align relative to target elem
			// TODO "right" align
			align: 'center', // left || center
			
			// always show under target elem (even if bubble node does not fit screen height)
			alwaysShowUnderTarget: false,
			
			closeControl: true,
			closeOnContentClick: false,
			closeOnDocumentClick: true,
			closeOnEscape: true,
			
			// show on special event triggered by target (no action by default - "false")
			showOn: false, // 'click' || ('hover' || 'mouseover') || 'focus' || false
			showEffect: '', //can be fade
			
			preventDefaultTargetClick: true,
			
			outerHtml: '' +
				'<div class="b-popup bubble-node" style="display: none;">' +
					'<div class="b-popup-outer">' +
						'<div class="b-popup-inner">' +
							'<i class="i-popup-arr i-popup-arrtl">' +
								'<i class="i-popup-arr-brdr-outer">' +
									'<i class="i-popup-arr-brdr-inner">' +
										'<i class="i-popup-arr-bg"></i>' +
									'</i>' +
								'</i>' +
							'</i>' +
							'<i class="i-popup-close"></i>' +
						'</div>' +
					'</div>' +
				'</div>',
			
			classNames: {
				containerAddClass: '', //if this value is set it will add this class to the top node
				positionPrefix: 'i-popup-arr',
				arrowDefault: 'i-popup-arr',
				withCloseControl: 'b-popup-withclosecontrol',
				noCloseControl: 'b-popup-noclosecontrol'
			},
			
			selectors: {
				bubbleNode: 'div.bubble-node',
				bubbleArrow: 'i.i-popup-arr',
				bubbleInner: 'div.b-popup-inner',
				closeControl: 'i.i-popup-close'
			}
		},
		
		
		// private methods
		
		_create: function () {
			var ljBubble = this,
				options = ljBubble.options,
				selectors = options.selectors;

			$.lj.basicWidget.prototype._create.apply(this);
			$.lj.basicWidget.prototype._bindControls.apply(this);

			//this flag is needed because we cannot simply top propogation
			//on content click - user won't be able to open links.
			this.blockDocumentClick = false;

			// wrap bubble content with bubble outer html
			ljBubble._makeNode();

			this._on('documentClick', function() {
				if (options.closeOnDocumentClick && !ljBubble.blockDocumentClick) {
					ljBubble.hide();
				} else {
					ljBubble.blockDocumentClick = false;
				}
			});
			
			// set default options
			ljBubble._setOptions(options);
		},
		
		_setOption: function (option, value) {
			var ljBubble = this,
				options = ljBubble.options,
				classNames = options.classNames,
				eventNamespace = '.' + ljBubble.widgetName + '-' + option,
				currentShowOn = options.showOn,
				newValue;

			switch (option) {
				case 'target':
					newValue = $(value);
					if(options.target && options.target[0] === newValue[0]) {
						break;
					}

					//if target changes we should rebind all events from the old one.
					//we don't if the old one is a string or an ordinary node, because
					//it can happen only on init
					if (options.target && !(typeof options.target === "string") &&
						('length' in  options.target)) {
						this._setOption('showOn', false);
						options.target = newValue;
						this._setOption('showOn', currentShowOn);
					} else {
						options.target = $(value);
					}
					return; //return from the function, because we modified value
				break;
				case 'closeControl':
					if (value) {
						ljBubble.bubbleNode
							.delegate(options.selectors.closeControl, 'click' + eventNamespace, function (event) {
								ljBubble.hide();
							})
							.removeClass(classNames.noCloseControl)
							.addClass(classNames.withCloseControl);
					} else {
						ljBubble.bubbleNode
							.undelegate(options.selectors.closeControl, 'click' + eventNamespace)
							.removeClass(classNames.withCloseControl)
							.addClass(classNames.noCloseControl);
					}
				break;
				case 'position':
					ljBubble.bubbleNode.css({
						left: value.x,
						top: value.y
					});
				break;
				case 'showOn':
					value = (value == 'mouseover') ? 'hover' : value;
				
					if (value == 'click') {
						options.target.bind('click' + eventNamespace, function (event) {
							var target = $(this);
							
							event.preventDefault();
							ljBubble.blockDocumentClick = true;
							
							if (ljBubble.bubbleNode.is(':visible')) {
								ljBubble.hide();
							} else {
								ljBubble.show(target);
							}
						});
					} else {
						options.target.unbind('click' + eventNamespace);
					}
					
					if (value == 'hover') {
						options.target
							.add(ljBubble.bubbleNode)
								.bind('touchstart' + eventNamespace + ' mouseenter' + eventNamespace, function () {
									var target = this;
									clearTimeout(options.hoverTimer);
									options.hoverTimer = setTimeout(function () {
										ljBubble.show(target);
									}, options.showDelay);
								})
								.bind('mouseleave' + eventNamespace, function () {
									clearTimeout(options.hoverTimer);
									options.hoverTimer = setTimeout(function () {
										ljBubble.hide();
									}, options.hoverDelay);
								});
					} else {
						options.target
							.add(ljBubble.bubbleNode)
								.unbind('touchstart' + eventNamespace)
								.unbind('mouseenter' + eventNamespace)
								.unbind('mouseleave' + eventNamespace);
					}

					if (value == 'focus') {
						options.target
							.bind('focus' + eventNamespace, function (event) {
								var target = $(this);

								ljBubble.blockDocumentClick = true;
								event.preventDefault();
								event.stopPropagation();
								
								ljBubble.show(target);
							});
							// @BUG: this was commented out because click on the bubble
							//       content triggers blur event.
							// .bind('blur' + eventNamespace, function (event) {
							// 	ljBubble.hide();
							// });
					} else {
						options.target
							.unbind('focus' + eventNamespace)
							.unbind('blur' + eventNamespace);
					}			
				break;
				case 'preventDefaultTargetClick':
					if (value) {
						options.target.bind('click' + eventNamespace, function (event) {
							event.preventDefault();
						});
					} else {
						options.target.unbind('click' + eventNamespace);
					}
				break;
				case 'closeOnEscape':
					if (value) {
						$(document).bind('keydown' + eventNamespace, function (event) {
							// escape
							if (event.keyCode == 27) {
								ljBubble.hide();
							}
						});
					} else {
						$(document).unbind('keydown' + eventNamespace);
					}
				break;
				case 'closeOnContentClick':
					if (!value) {
						ljBubble.bubbleNode.bind('mousedown' + eventNamespace + ' click' + eventNamespace, function (event) {
							ljBubble.blockDocumentClick = true;
						});
					} else {
						ljBubble.bubbleNode.unbind('mousedown' + eventNamespace + ' click' + eventNamespace);
					}
				break;
			}

			options[option] = value;
		},

		_makeNode: function () {
			var bubbleNode = $(this.options.outerHtml),
				bubbleArrow = bubbleNode.find(this.options.selectors.bubbleArrow),
				bubbleInner = bubbleNode.find(this.options.selectors.bubbleInner);
			
			// this.element - with bubble content
			this.element
				.css('display', 'block')
				.prependTo(bubbleInner);
			
			this.bubbleNode = bubbleNode.prependTo('body');
			this.bubbleArrow = bubbleArrow;
			
			// store arrow elem position
			bubbleNode.css({
				visibility: 'hidden',
				display: 'block'
			});

			var containerAddClass = this.options.classNames.containerAddClass;
			//additional class is needed to customize look and behavior of bubble if needed
			if (containerAddClass && containerAddClass.length > 0) {
				bubbleNode.addClass(containerAddClass);
			}

			bubbleArrow.data({
				'left': bubbleArrow.position().left,
				'top': bubbleArrow.position().top
			});
			bubbleNode.css({
				visibility: 'visible',
				display: 'none'
			});
		},
		
		_getPosition: function (targetControl) {
			targetControl = targetControl || this.options.currentTarget;
			
			// if there is image in target (like this: <a><img src="..."></a>) - bubble will be positioned relative to image
			if (targetControl.find('img').length) {
				targetControl = targetControl.find('img');
			}
			
			var ljBubble = this,
				options = ljBubble.options,
				align = options.align,
				alwaysShowUnderTarget = options.alwaysShowUnderTarget,
			
				viewport = $(window),
				viewportWidth = viewport.width(),
				viewportHeight = viewport.height(),
				body = $('body'),
				viewportScrollLeft = body.prop('scrollLeft'),
				
				elem = ljBubble.bubbleNode,
				elemWidth = elem.width(),
				elemHeight = elem.height(),
				
				popupArrow = ljBubble.bubbleArrow,
				popupArrowLeft = popupArrow.data('left'),
				popupArrowTop = popupArrow.data('top'),
				popupArrowWidth = 13, // popup arrow drawn with borders (6px at left and right side)
				
				targetOffset = targetControl.offset(),
				targetLeft = Math.round(targetOffset.left),
				targetTop = Math.round(targetOffset.top),
				targetWidth = targetControl.width(),
				targetHeight = targetControl.height(),
				
				scrollOffset = viewport.scrollTop(),
				
				leftPositionX = (align == 'center') ?
					// center align (arrow relative to target elem) 
					Math.floor( targetLeft + (targetWidth / 2) - popupArrowLeft - (popupArrowWidth / 2) ) :
					// left align 
					targetLeft,
				rightPositionX = targetLeft + Math.floor( (targetWidth / 2) - (elemWidth - popupArrowLeft - popupArrowWidth / 2) ),
				topPositionY = targetTop - popupArrowTop + targetHeight,
				bottomPositionY = targetTop + popupArrowTop - elemHeight,
				
				arrowPositionType = {
					x: 'l', // left
					y: 't' // top
				},
				arrowPositionTypes = {
					'tl': { x: leftPositionX, y: topPositionY },
					'tr': { x: rightPositionX, y: topPositionY },
					'bl': { x: leftPositionX, y: bottomPositionY },
					'br': { x: rightPositionX, y: bottomPositionY }
				},
				
				position,
				
				checkAngle = {
					x: leftPositionX + elemWidth,
					y: topPositionY + elemHeight
				};
				
			if (checkAngle.x > viewportWidth + viewportScrollLeft) {
				arrowPositionType.x = 'r'; // right
			}
			
			if (!alwaysShowUnderTarget && checkAngle.y > viewportHeight + viewport.scrollTop() && bottomPositionY > 0) {
				arrowPositionType.y = 'b'; // bottom
			}
			
			arrowPositionType = arrowPositionType.y + arrowPositionType.x;

			popupArrow
				.removeClass()
				.addClass(options.classNames.arrowDefault)
				.addClass(options.classNames.positionPrefix + arrowPositionType);
			
			position = arrowPositionTypes[arrowPositionType];
			position = this._applyOffset( position, arrowPositionType );
			
			return { position: position, bubblePosition: arrowPositionType };
		},

		_updatePosition: function () {
			var newPosition = this._getPosition();
			this.option('position', newPosition.position);

			return newPosition;
		},

		_applyOffset: function( position, bubblePosition ) {
			var offset = this.options.offset,
				offsetObj;

			if( 'x' in offset ) {
				offsetObj = offset;
			} else {
				offsetObj = offset[ bubblePosition ] || offset[ bubblePosition.charAt( 0 ) ] || offset[ bubblePosition.charAt( 1 ) ];
			}

			if( offsetObj ) {
				position.x += offsetObj.x;
				position.y += offsetObj.y;
			}

			return position;
		},

		// public methods
		
		show: function (target) {
			var ljBubble = this,
				options = ljBubble.options,
				position;
				
			//prevent delayed mouseout event
			clearTimeout(this.options.hoverTimer);

			target = (target) ? $(target) : options.target;
			
			$( ':lj-bubble' ).not( this.element ).bubble( "hide" );
			
			if (!ljBubble.bubbleNode.is(':visible')) {
				ljBubble.option('currentTarget', target);
				position = ljBubble._updatePosition();

				if (this.options.showEffect === 'fade') {
					this.bubbleNode.fadeIn(200);
				} else {
					this.bubbleNode.show();
				}
			}
			
			ljBubble._trigger( 'show', null, [ {
				position: position
			} ] );
			
			return this;
		},
		
		hide: function () {
			//prevent delayed mouseout event
			clearTimeout(this.options.hoverTimer);

			if (!this.bubbleNode.is(':visible')) { //do not fire events if bubble is already hidden
				return;
			}

			if (this.options.showEffect === 'fade') {
				this.bubbleNode.fadeOut(200);
			} else {
				this.bubbleNode.hide();
			}

			this._trigger('hide');

			return this;
		},

		/**
		 * Reposition bubble on the page. The method is needed to reposition bubble
		 * in case when it's content is changed and it remains visible at the same time.
		 */
		updatePosition: function() {
			this._updatePosition();
		}

	};
	
	$.widget('lj.bubble', $.lj.basicWidget, LJBubble);
	
})(jQuery, this);

/**
 * Contextual popup is displayed on mouse hover near
 * every userpic and userhead
 */

/**
 * Widget shows the dialog to edit current user note.
 */
LJWidgetIPPU_AddAlias = new Class(LJWidgetIPPU, {
	init: function (opts, params) {
		opts.widgetClass = "IPPU::AddAlias";
		this.width = opts.width; // Use for resizing later
		this.height = opts.height; // Use for resizing later
		this.alias = opts.alias;
		LJWidgetIPPU_AddAlias.superClass.init.apply(this, arguments);
	},

	changeAlias: function (evt, form) {
		this.doPost({
				alias: form["Widget[IPPU_AddAlias]_alias"].value + "",
				foruser: form["Widget[IPPU_AddAlias]_foruser"].value + ""
		});

		evt.preventDefault();
	},

	onData: function (data) {
		if (!data.res || !data.res.success) {
			return;
		}

		this.close();

		//Changing button. Only on profile page
		var edit_node = jQuery('.profile_addalias');
		if (edit_node.length) {
			if (data.res.alias) {
				edit_node[0].style.display = 'none';
				edit_node[1].style.display = 'block';
				edit_node[1].firstChild.alias = data.res.alias;
			} else {
				edit_node[0].style.display = 'block';
				edit_node[1].style.display = 'none';
			}
		}
		
		var username = data.res.username,
			alias = data.res.alias;
		if(ContextualPopup.cachedResults[username]) {
			ContextualPopup.cachedResults[username].alias_title = alias ? 'Edit Note' : 'Add Note';
			ContextualPopup.cachedResults[username].alias = alias;
		}

		if (ContextualPopup.currentId === username) {
			ContextualPopup.renderPopup(ContextualPopup.currentId);
		}
	},

	onError: function (msg) {
		LJ_IPPU.showErrorNote("Error: " + msg);
	},

	onRefresh: function () {
		var form = jQuery('#addalias_form').get(0),
			input = jQuery(form['Widget[IPPU_AddAlias]_alias']),
			delete_btn = jQuery(form['Widget[IPPU_AddAlias]_aliasdelete']),
			widget = this;
		input.focus();

		if (delete_btn.length) {
			delete_btn.click(function(){
				input.val('');
			});
			input.input(function() {
				// save button disabled
				form['Widget[IPPU_AddAlias]_aliaschange'].disabled = !this.value;
			});
		}

		jQuery(form).submit(function(e) { widget.changeAlias(e, form) });
	},

	cancel: function (e) {
		this.close();
	}
});


//this object contains only authToken
Aliases = {}
function addAlias(target, ptitle, ljusername, oldalias, callback) {
	if (! ptitle) return true;
	
	new LJWidgetIPPU_AddAlias({
		title: ptitle,
		width: 440,
		height: 180,
		authToken: Aliases.authToken,
		callback: callback
		}, {
			alias: target.alias||oldalias,
			foruser: ljusername
		});

	return false;
}


(function($) {

	/**
	 * Object contains methods to build and display user popup.
	 */
	var popup = {
		popupDelay: 500,
		popupTimer: null,
		adriverImages : {
			anonymous: 'http://ad.adriver.ru/cgi-bin/rle.cgi?sid=1&ad=186396&bt=21&pid=482107&bid=893162&bn=893162&rnd={random}',
			guest: 'http://ad.adriver.ru/cgi-bin/rle.cgi?sid=1&ad=186396&bt=21&pid=482107&bid=893165&bn=893165&rnd={random}',
			self: 'http://ad.adriver.ru/cgi-bin/rle.cgi?sid=1&ad=186396&bt=21&pid=482107&bid=893167&bn=893167&rnd={random}'
		},

		classNames: {
			popup: 'b-popup-contextual'
		},
		selectors: {
			wrapper: '.b-contextualhover',
			bubble: '.b-popup',
			popup: '.contextualPopup'
		},
		templates: {
			wrapper: '<div class="b-contextualhover"></div>',
			loading: 'Loading...',
			content: 
					'{{if userpic }}' +
					'<div class="b-contextualhover-side">' +
						'<div class="b-contextualhover-userpic">' +
							'<a href="${userpic.allpics}"><img src="${userpic.pic}" alt="" /></a>' +
						'</div>' +
					'</div>' +
					'{{/if}}' +
					'<div class="b-contextualhover-section">' +
					'<div class="b-contextualhover-title">' +
						'<h3>{{html title.title}}</h3>' +
						'{{each headLinks}}' +
								'<p>{{if $value.url}}<a href="${$value.url}">${$value.text}</a>' +
								'{{else}}{{html $value}}{{/if}}</p>' + 
						'{{/each}}' +
					'</div>' +
					'{{each(i, group) linkGroups}}' +
						'{{if group.length }}' +
						'<ul class="b-contextualhover-options">' +
							'{{each group}}<li>' +
								'{{if $value.url}}<a href="${$value.url}">${$value.text}</a>' +
								'{{else}}{{html $value}}{{/if}}' +
							'</li>{{/each}}' +
						'</ul>' +
						'{{/if}}' +
					'{{/each}}' +
					'{{if showBanOptions }}' +
					'<ul class="b-contextualhover-options">' +
						'{{if reportBot}}<li><a href="${reportBot.url}">${reportBot.text}</a></li>{{/if}}' +
						'<li class="b-contextualhover-options-ban">' +
							'<p>${banUsersLink.text}:</p>' +
							'{{if banCheckboxes}}<div class="b-contextualhover-options-wrap">' +
								'{{each banCheckboxes}}' +
								'<p><label><input type="checkbox" class="input-checkbox ${$value.className}" {{if $value.checked}}checked{{/if}} /> ${$value.label}</label></p>' +
								'{{/each}}' +
							'</div>{{/if}}' +
						'</li>' +
					'</ul>' +
					'{{/if}}' +
					'</div>'
		},

		init: function() {
			var wrapper = jQuery(this.templates.wrapper),
				self = this;

			this.element = jQuery(wrapper).bubble({
				// showDelay: 500,
				closeControl: false,
				// showOn: 'hover',
				hide: function() {
					ContextualPopup.hideHourglass();
				},
				classNames: {
					containerAddClass: this.classNames.popup
				}
			});

			this.bindShowHideEvents(this.element.closest(this.selectors.bubble));
		},

		bindShowHideEvents: function(el) {
			var self = this;
			el = jQuery(el);

			el.bind('mouseenter', function(ev) { self.show(); });
			el.bind('mouseleave', function(ev) { self.hide(); });
		},

		show: function(force) {
			this.setVisibile(true, force);
		},

		hide: function(force) {
			this.setVisibile(false, force);
		},

		setVisibile: function(isVisible, force) {
			var action = isVisible ? "show" : "hide",
				self = this;

			force = force || false;
			clearTimeout(this.popupTimer);

			if (force) {
				this.element.bubble(action);
			} else {
				this.popupTimer = setTimeout(function() {
					self.element.bubble(action);
				}, this.popupDelay);
			}
		},

		/**
		 * Constructs object, passes it to the template,
		 * inserts it in the bubble and binds events.
		 *
		 * @param {Object} data Object returned from the endpoint.
		 * @param {String} ctxPopupId The id of the user.
		 */
		render: function(data, ctxPopupId) {
			if (!data) {
				this.element.empty().append(this.templates.loading);
				return;
			} else if (!data.username || !data.success || data.noshow) {
				this.hide(true);
				return;
			}

			var buildObject = {
				headLinks: [],
				linkGroups: []
			};

			if (data.url_userpic && data.url_userpic != ctxPopupId) {
				buildObject.userpic = {
					allpics: data.url_allpics,
					pic: data.url_userpic
				};
			}

			// relation
			var label, username = '<strong>' + data.display_username + ' </strong>';
			if (data.is_comm) {
				if (data.is_member)
					label = data.ml_you_member.replace('[[username]]', username);
				else if (data.is_friend)
					label = data.ml_you_watching.replace('[[username]]', username);
				else
					label = username;
			} else if (data.is_syndicated) {
				if (data.is_friend)
						label = data.ml_you_subscribed.replace('[[username]]', username);
				else
					label = username;
			} else {
				if (data.is_requester) {
					label = data.ml_this_is_you;
				} else {
					label = username;
					
					if (data.is_friend_of) {
						if (data.is_friend)
							label += data.ml_mutual_friend;
						else
							label += data.ml_lists_as_friend;
					} else if (data.is_friend) {
						label += data.ml_your_friend;
					}
				}
			}

			buildObject.title = {
				title: label
			};

			// aliases
			if (!data.is_requester && data.is_logged_in) {
				if (data.alias_enable) {
					if (data.alias) {
						buildObject.headLinks.push('<i>' + data.alias.encodeHTML() + '</i>');
					}
					
					buildObject.headLinks.push({
						url: Site.siteroot + '/manage/notes.bml',
						click: function(e)
						{
							e.preventDefault();
							addAlias(this, data.alias_title, data.username, data.alias || '');
						},
						text: data.alias_title
					});
				} else {
					buildObject.headLinks.push(
						'<span class="alias-unavailable">'+
							'<a href="'+Site.siteroot+'/manage/account">'+
								'<img src="'+Site.statprefix+'/horizon/upgrade-paid-icon.gif?v=2621" width="13" height="16" alt=""/>'+
							'</a> '+
							'<a href="'+Site.siteroot+'/support/faqbrowse.bml?faqid=295">'+data.alias_title+'</a>'+
						'</span>');
				}
			}

			// add/remove friend link
			if (data.is_logged_in && !data.is_requester) {
				buildObject.headLinks.push({
					selector: 'a[href="{url}"]:first',
					url: data.url_addfriend,
					click: function(e)
					{
						e.preventDefault();
						e.stopPropagation();
						ContextualPopup.changeRelation(data, ctxPopupId, data.is_friend ? 'removeFriend' : 'addFriend', e);
					},
					text: function()
					{
						if (data.is_comm)
							return data.is_friend ? data.ml_stop_community : data.ml_watch_community;
						else if (data.is_syndicated)
							return data.is_friend ? data.ml_unsubscribe_feed : data.ml_subscribe_feed;
						else
							return data.is_friend ? data.ml_remove_friend : data.ml_add_friend;
					}()
				});

				if (data.is_friend && !data.is_identity) {
					buildObject.headLinks.push({
						url: data.url_addfriend,
						text: data.ml_edit_friend_tags
					});
				}
			}

			var linkGroup = [];
			
			// member of community
			if (data.is_logged_in && data.is_comm) {
				linkGroup.push({
					selector: 'a[href="{url}"]',
					url: data.is_member ? data.url_leavecomm : data.url_joincomm,
					text: data.is_member ? data.ml_leave : data.ml_join_community,
					click: function(e)
					{
						e.preventDefault();
						ContextualPopup.changeRelation(data, ctxPopupId, data.is_member ? 'leave' : 'join', e);
					}
				});
			}

			//filter community
			if( ( !data.is_comm && Site.current_journal && ( "is_comm" in Site.current_journal ) 
						&& Site.current_journal.is_comm === "1" ) || data.posted_in ) {
				linkGroup.push({
					url: ( ( data.posted_in ) ? data.posted_in : Site.current_journal.url_journal ) + '/?poster=' + data.username,
					text: ( Site.remoteUser === data.username && !data.posted_in ) 
							? ( data.ml_filter_by_poster_me || 'Filter community by me' ) 
							: ( data.ml_filter_by_poster || 'Filter community by poster' )
				});
			}

			buildObject.linkGroups.push(linkGroup);
			linkGroup = [];

			// send message
			if (data.is_logged_in && data.is_person && ! data.is_requester && data.url_message) {
				linkGroup.push({
					url: data.url_message,
					text: data.ml_send_message
				});
			}

			// vgift
			if ((data.is_person || data.is_comm) && !data.is_requester && data.can_receive_vgifts) {
				linkGroup.push({
					url: Site.siteroot + '/shop/vgift.bml?to=' + data.username,
					text: data.ml_send_gift
				});
			}

			// wishlist
			// commented according to task LJSUP-11396
			// if ((data.is_person || data.is_comm) && !data.is_requester && data.wishlist_url) {
			// 	linkGroup.push({
			// 		url: data.wishlist_url,
			// 		text: data.ml_view_wishlist
			// 	});
			// }

			// buy the same userhead
			if (data.is_logged_in && data.is_person && ! data.is_requester && data.is_custom_userhead) {
				linkGroup.push((data.is_app_userhead) ?
						{ url: data.url_userhead_install, text: data.ml_userhead_install } :
						{ url: data.url_buy_userhead, text: data.ml_buy_same_userhead }
				);
			}

			// identity
			if (data.is_identity && data.is_requester) {
				linkGroup.push({
					url: Site.siteroot + '/identity/convert.bml',
					text: data.ml_upgrade_account
				});
			}

			// add site-specific content here
			var extraContent = LiveJournal.run_hook('ctxpopup_extrainfo', data);
			if (extraContent) {
				linkGroup.push(extraContent);
			}

			buildObject.linkGroups.push(linkGroup);

			if (data.is_logged_in && !data.is_requester && !data.is_comm && !data.is_syndicated) {
				buildObject.showBanOptions = true;
				buildObject.banUsersLink = {
					url: Site.siteroot + '/manage/banusers.bml',
					text: data.ml_ban
				};

				// ban/unban
				buildObject.banCheckboxes = [];
				buildObject.banCheckboxes.push({
					selector: '.ban_user',
					className: 'ban_user',
					label: data.ml_ban_in_my,
					checked: data.is_banned,
					change: function(e)
					{
						e.preventDefault();
						ContextualPopup.changeRelation(data, ctxPopupId, data.is_banned ? 'setUnban' : 'setBan', e);
					}
				});

				// report a bot
				if (!Site.remote_is_suspended) {
					buildObject.reportBot = {
						url: Site.siteroot + '/abuse/bots.bml?user=' + data.username,
						text: data.ml_report
					};
				}

				// ban user from all maintained communities
				if (!data.is_requester && !data.is_comm && !data.is_syndicated && data.have_communities) {
					buildObject.banCheckboxes.push({
						selector: '.ban_everywhere',
						className: 'ban_everywhere',
						label: data.ban_everywhere_title,
						checked: data.is_banned_everywhere,
						change: function(e)
						{
							e.preventDefault();
							var action = data.is_banned_everywhere ? 'unbanEverywhere' : 'banEverywhere';
							ContextualPopup.changeRelation(data, ctxPopupId, action, e);
						}
					});
				}
			}

			var userType = 'guest';
			if (!data.is_logged_in) { //  anonymous
				userType = 'anonymous';
			} else if (data.is_requester) { // self
				userType = 'self';
			}

			new Image().src = this.adriverImages[userType].supplant({ random: Math.random()});

			this.element
				.empty()
				.append(jQuery.tmpl(this.templates.content, buildObject));

			if (this.element.is(':visible')) {
				//show method forces bubble to reposition with respect to the new content
				this.element.bubble('updatePosition');
			}

			this.setPopupEvents(buildObject);
		},

		/**
		 * Go through all build objects and find all callbacks that should be bound 
		 * to the node events.
		 *
		 * @param {Object} buildObject Template object.
		 */
		setPopupEvents: function(buildObject) {
			var element = this.element;
			element.undelegate();

			function walkObject(obj) {
				$.each(obj, function(key, value) {
					var selector;

					if (value.click) {
						//default handler is by url
						var selector = value.selector || '[href="' + value.url + '"]';
						selector = selector.supplant(value);
						element.delegate(selector, 'click', value.click);
					}

					if (value.change) {
						//for checkboxes selector should present anyway
						var selector = value.selector;
						selector = selector.supplant(value);
						element.delegate(selector, 'change', value.change);
					}

					//maybe this object has children with events to be set
					if(typeof value === "object") {
						walkObject(value);
					}
				});
			}

			walkObject(buildObject);
		}
	};

	window.ContextualPopup = {
		cachedResults  : {},
		currentRequests: {},
		currentId      : null,
		currentElement : null,
		hourglass      : null,

		setup: function() {
			// don't do anything if no remote
			if (!Site.ctx_popup) return;

			popup.init();
			jQuery(document.body)
				.mouseover(ContextualPopup.mouseOver)
				.ljAddContextualPopup();
		},

		/**
		 * Search child nodes and bind hover events on them if needed.
		 */
		searchAndAdd: function(node) {
			if (!Site.ctx_popup) return;

			// attach to all ljuser head icons
			var rex_userid = /\?userid=(\d+)/,
				rex_userpic = /(userpic\..+\/\d+\/\d+)|(\/userpic\/\d+\/\d+)/,
				class_nopopup = 'noctxpopup',
				ljusers = jQuery('span.ljuser>a>img', node),
				i = -1, userid, ljuser, parent;

			// use while for speed
			while (ljusers[++i]) {
				ljuser = ljusers[i];
				parent = ljuser.parentNode;

				if (parent.href && (userid = parent.href.match(rex_userid)) && !(parent.className.indexOf(class_nopopup) >= 0)) {
					ljuser.userid = userid[1];
				} else if (parent.parentNode.getAttribute('lj:user')) {
					ljuser.username = parent.parentNode.getAttribute('lj:user');
				} else {
					continue;
				}

				if (parent.parentNode.getAttribute('data-journal')) {
					ljuser.posted_in = parent.parentNode.getAttribute('data-journal');
				}
				ljuser.className += ' ContextualPopup';
			}
			
			ljusers = node.getElementsByTagName('img');
			i = -1;
			while (ljusers[++i]) {
				ljuser = ljusers[i];
				if (ljuser.src.match(rex_userpic) && !(ljuser.className.indexOf(class_nopopup) >= 0)) {
					ljuser.up_url = ljuser.src;
					if (ljuser.parentNode.getAttribute('data-journal')) {
						ljuser.posted_in = ljuser.parentNode.getAttribute('data-journal');
					}
					ljuser.className += ' ContextualPopup';
				}
			}
		},

		mouseOver: function(e) {
			var target = e.target,
				ctxPopupId = target.username || target.userid || target.up_url,
				t = ContextualPopup;

			if (target.tagName == 'IMG' && ctxPopupId) {
				// if we don't have cached data background request it
				if (!t.cachedResults[ctxPopupId]) {
					t.getInfo(target, ctxPopupId);
				}

				// doesn't display alt as tooltip
				if (jQuery.browser.msie && target.title !== undefined) {
					target.title = '';
				}

				// show other popup
				if (t.currentElement != target) {
					t.showPopup(ctxPopupId, target);
				} else {
					popup.show();
				}
			}
		},

		showPopup: function(ctxPopupId, ele) {
			var showNow = popup.element.is(':visible');

			jQuery(this.currentElement)
				.unbind('mouseenter mouseleave');

			this.currentId = ctxPopupId;
			var data = this.cachedResults[ctxPopupId];

			if (data && data.noshow) return;
			if (this.currentElement && this.currentElement !== ele) {
				popup.hide(true);
			}

			if (data && data.error) {
				popup.hide(true);
				ContextualPopup.showNote(data.error, ele);
				return;
			}

			popup.render(data, ctxPopupId);
			popup.element.bubble('option', 'target', jQuery(ele));
			popup.bindShowHideEvents(ele);
			popup.show(showNow);
			this.currentElement = ele;
		},

		renderPopup: function(ctxPopupId) {
			popup.render(this.cachedResults[ctxPopupId], ctxPopupId)
		},

		// ajax request to change relation
		changeRelation: function (info, ctxPopupId, action, e) {
			var changedRelation = function(data)
			{
				if (data.error) {
					return ContextualPopup.showNote(data.error);
				}
				
				if (ContextualPopup.cachedResults[ctxPopupId]) {
					jQuery.extend(ContextualPopup.cachedResults[ctxPopupId], data);
				}
				
				// if the popup is up, reload it
				ContextualPopup.renderPopup(ctxPopupId);
			}
			
			var xhr = jQuery.post(LiveJournal.getAjaxUrl('changerelation'),
						{
							target: info.username,
							action: action,
							auth_token: info[action + '_authtoken']
						},
						function(data)
						{
							ContextualPopup.hourglass = null;
							changedRelation(data);
						},
						'json'
					);
			
			ContextualPopup.hideHourglass();
			ContextualPopup.hourglass = jQuery(e).hourglass(xhr)[0];
			//entering mouse on the hourglass should no close popup
			jQuery(ContextualPopup.hourglass.ele).bind('mouseenter', function(ev) {
				popup.element.trigger('mouseenter');
			});
			// so mousing over hourglass doesn't make ctxpopup think mouse is outside
			ContextualPopup.hourglass.add_class_name('lj_hourglass');
			
			return false;
		},

		// create a little popup to notify the user of something
		showNote: function (note, ele) {
			ele = ele || popup.element[0];
			LJ_IPPU.showNote(note, ele);
		},

		cleanCache: function(keys) {
			var self = this;

			keys = keys || [];
			if (typeof keys === 'string') {
				keys = [ keys ];
			}

			keys.forEach(function(key) {
				if (self.cachedResults[key]) {
					delete self.cachedResults[key];
				}
			});
		},

		// do ajax request of user info
		getInfo: function(target, popup_id) {
			var t = this;
			if (t.currentRequests[popup_id]) {
				return;
			}
			t.currentRequests[popup_id] = 1;

			var reqParams = {
				user: target.username || ''
			};

			jQuery.ajax({
				url: LiveJournal.getAjaxUrl('ctxpopup'),
				data: Object.extend( reqParams, {
					userid: target.userid || 0,
					userpic_url: target.up_url || '',
					mode: 'getinfo'
				}),
				dataType: 'json',
				success: function(data)
				{
					if (data.error) {
						data.username = reqParams.user;
						t.cachedResults[data.username] = data;
						popup.hide(true);
						t.showNote(data.error, target);
						return;
					}

					if( target.posted_in ) {
						data.posted_in = target.posted_in;
					}
					
					t.cachedResults[String(data.userid)] =
					t.cachedResults[data.username] =
					t.cachedResults[data.url_userpic] = data;
					
					// non default userpic
					if (target.up_url) {
						t.cachedResults[target.up_url] = data;
					}
					
					t.currentRequests[popup_id] = null;
					
					if (t.currentId == popup_id) {
						t.renderPopup(popup_id);
					}
				},
				error: function()
				{
					t.currentRequests[popup_id] = null;
				}
			});
		},

		hideHourglass: function () {
			if (this.hourglass) {
				this.hourglass.hide();
				this.hourglass = null;
			}
		}
	};

})(jQuery);


// when page loads, set up contextual popups
jQuery(ContextualPopup.setup);

Horizon = new Object;

// Holds style info for the top level menu
Horizon.toplevel_hover_style = null;
// Holds the last menu opened
Horizon.opened_menu = null;
// Holds Select elements tht have been hidden
Horizon.hiddenSelects = [];
// Is IE version 6 or lower flag
Horizon.isIE6down = jQuery.browser.msie && jQuery.browser.version < 7;

Horizon.scheme_init = function () {
    Horizon.toplevel_hover_style = DOM.getComputedStyle($("Alpha"));
	var list = $('footer_lang_list')
	if (list) {
		DOM.addEventListener(list, "change", function (evt) { Horizon.changeLang(evt, list.value) });
	}
}

Horizon.open_menu = function (m) {
    /* Needed to nicely turn on top level menu items for IE */
    if (Horizon.toplevel_hover_style) {
        m.style.backgroundImage = Horizon.toplevel_hover_style.backgroundImage;
        m.style.borderColor = Horizon.toplevel_hover_style.borderColor;
        m.style.borderWidth = Horizon.toplevel_hover_style.borderWidth;
        m.style.borderStyle = Horizon.toplevel_hover_style.borderStyle;
        var links = m.getElementsByTagName('a');
        links[0].style.color = Horizon.toplevel_hover_style.color;
    }

    Horizon.hideSelects();
    var menus = m.getElementsByTagName('ul');
    for (var i = 0; i <= menus.length; i++) {
        if (!menus[i]) return;
        menus[i].style.display = "block";
    }

    Event.stop(e);
    return false;
}

Horizon.close_menu = function (m) {
    if (Horizon.toplevel_hover_style) {
        m.style.backgroundImage = '';
        m.style.borderColor = '';
        m.style.borderWidth = '';
        m.style.borderStyle = '';
        var links = m.getElementsByTagName('a');
        links[0].style.color = '';
    }

    Horizon.showSelects();
    var menus = m.getElementsByTagName('ul');
    for (var i = 0; i <= menus.length; i++) {
        if (!menus[i]) return;
        menus[i].style.display = "none";
    }

    Event.stop(e);
    return false;
}

Horizon.mouseMove = function (evt) {
    Event.prep(evt);
    if (!evt.target) return;

    var ancestors = DOM.getAncestorsByClassName(evt.target, "NavMenuItem", true);
    if (ancestors.length) {
        if (!Horizon.opened_menu || Horizon.opened_menu != ancestors[0])
            Horizon.open_menu(ancestors[0]);
        if (Horizon.opened_menu && Horizon.opened_menu != ancestors[0])
            Horizon.close_menu(Horizon.opened_menu);
        Horizon.opened_menu = ancestors[0];
    } else {
        if (Horizon.opened_menu) Horizon.close_menu(Horizon.opened_menu);
        Horizon.opened_menu = null;
    }
}

Horizon.hideSelects = function () {
    if (!Horizon.isIE6down) return;
    var sels = document.getElementsByTagName("select");
    var ele;
    for (var i = 0; i < sels.length; i++) {
        ele = sels[i];
        if (!ele) continue;

        if (ele.style.visibility != 'hidden' && ele.className == 'hideable') {
            ele.style.visibility = 'hidden';
            Horizon.hiddenSelects.push(ele);
        }
    }
}

Horizon.showSelects = function () {
    var ele;
    while (ele = Horizon.hiddenSelects.pop())
        ele.style.visibility = '';
}

Horizon.changeLang = function(evt, lang) {
    if (lang) {
        window.location = Site.siteroot + "/tools/setlang.bml?lang=" + lang + "&returnto=" + escape(window.location);
    }
}

jQuery(Horizon.scheme_init);
!window.vertigo && DOM.addEventListener(document, 'mousemove', Horizon.mouseMove);

(function( top ) {

	var icoBase = 'http://wh.lj.ru/iepinned';

	function updateJumpList( dict, inboxNumber ) {
		inboxNumber = inboxNumber || 0;
		window.external.msSiteModeCreateJumplist( 'LiveJournal');
		window.external.msSiteModeAddJumpListItem( dict.journal, Site.remoteJournalBase, icoBase + '/recent.ico' );
		window.external.msSiteModeAddJumpListItem( dict.friends, Site.remoteJournalBase + '/friends', icoBase + '/friends.ico' );
		window.external.msSiteModeAddJumpListItem( dict.ljtimes, Site.siteroot + '/ljtimes/', icoBase + '/ljtimes.ico' );
		window.external.msSiteModeAddJumpListItem( dict.ratings_posts, Site.siteroot + '/ratings/posts/', icoBase + '/top.ico' );
		window.external.msSiteModeAddJumpListItem( dict.random_journal, Site.siteroot + '/random.bml', icoBase + '/surprise.ico' );

		if( inboxNumber > 0 ) {
			window.external.msSiteModeAddJumpListItem( dict.inbox + '(' + inboxNumber + ')', Site.siteroot + '/inbox/', icoBase + '/inbox.ico' );
			window.external.msSiteModeSetIconOverlay( icoBase + '/inbox.ico', dict.inbox + '(' + inboxNumber + ')' );
		} else {
			window.external.msSiteModeAddJumpListItem( dict.inbox, Site.siteroot + '/inbox/', icoBase + '/inbox_empty.ico' );
			window.external.msSiteModeClearIconOverlay();
		}
		window.external.msSiteModeShowJumplist();
	}

	function fetchInbox() {
		var url = Site.siteroot + LiveJournal.getAjaxUrl( 'inbox_count' );
		$.getJSON( url, function( data ) {
			updateJumpList( data.number );
		} );
	}

	function setMeta( name, content ) {
		var meta = document.createElement( 'meta' )
		meta.name = name;
		meta.content = content;

		document.getElementsByTagName( 'head' )[0].appendChild( meta );
	}

	function injectPinnedMeta( dict ) {
		if( Site.has_remote ) {
			setMeta( "msapplication-task", "name=" + dict.update_journal + ";action-uri=" + Site.siteroot + "/update.bml;icon-uri=" + icoBase + "/post.ico" );
		}

		setMeta( "application-name", dict.app_name );
		setMeta( "msapplication-tooltip", dict.app_tooltip );
		setMeta( "msapplication-starturl", Site.siteroot );
	}

	var defaultDict = {
		app_name: 'LiveJournal',
		app_tooltip: 'Livejournal.com',
		inbox: 'Inbox',
		update_journal: 'Post an entry',
		journal: 'Journal',
		friends: 'Friends',
		ljtimes: 'LJTimes',
		ratings_posts: 'Ratings',
		random_journal: 'Surprise me!' 
    }

	top.ie9InitPinnedMode = function( dict ) {
        dict = jQuery.extend( {}, defaultDict, dict );
		try {
			injectPinnedMeta( dict );

			if(window.external.msIsSiteMode()) {
				if( Site.has_remote > 0 ) {
					//here we should pass the number of current unread notifications
                    var unread_count = parseInt( Site.inbox_unread_count, 10) || 0;
					updateJumpList( dict, unread_count );

					/*
					setInterval( function() {
						//fetchInbox();
						//ajax requests emulation
						//updateJumpList( dict, Math.floor( Math.random() * 10 ) );
					}, 3000 );
					*/
				} else {
					window.external.msSiteModeClearJumplist();
					window.external.msSiteModeClearIconOverlay();
				}
			}
			else {}
		}
		catch(e) { }
	}

    ie9InitPinnedMode();

}( window ));


/*!
 * LiveJournal loader for vkontakte like buttons.
 *
 * Copyright 2011, dmitry.petrov@sup.com
 *
 * VK script is often loaded with notable delay, so
 * plugin just loads it after the page rendering and
 * allows to display page faster.
 *
 */
( function( $ ) {

	if( $.VK ) { return; }

	$.VK = {};

	var onloads = [];
		buttons = [],
		onloadPassed = false,
		scriptLoaded = false,
		scriptLoading = false;

	/**
	 * Public API
	 *
	 * @namespase $.VK
	 */
	$.VK = {

		/**
		 * Init VK object after the script load.
		 *     Function passes all option to the VK.init
		 *  @param {Object} options
		 */
		init: function( options ) {
			onloads.push( function() {
				VK.init( options );
			} )
		},

		/**
		 * Add button to init after script load.
		 *    If this method was called after the page load, and script wasn't downloaded yet,
		 *    it will trigger downloading.
		 */
		addButton: function( elementId, options ) {
			buttons.push( {
				id: elementId,
				options: options
			} );

			if( onloadPassed && !scriptLoading ) {
				if( scriptLoaded ) {
					initButtons();
				} else {
					loadScript( initButtons );
				}
			}
		}
	}

	function initButtons() {
		for( var i = 0; i < buttons.length; ++i ) {
			VK.Widgets.Like( buttons[ i ].id, buttons[ i ].options );
		}

		buttons = [];
	}

	function loadScript( onload ) {
		onload = onload || $.noop;
		scriptLoading = true;

		$.getScript( 'http://userapi.com/js/api/openapi.js?31', function() {
			scriptLoading = false;
			scriptLoaded = true;
			for( var i = 0; i < onloads.length; ++i ) {

				onloads[ i ]();
			}
			onloads = [];
			onload();
		} );
	}

	jQuery( function() {
		//Do not download the script if the widgets were not added yet.
		if( buttons.length ) {
			//Do not load the script directly after the page load.
			//We don't want to delay other onload functions somehow.
			setTimeout( function() {
				loadScript( initButtons );
			}, 500 );
		}
		onloadPassed = true;
	} );

} ) ( jQuery );

