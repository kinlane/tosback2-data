/* file: js/horizon.js 
----------------------------------------------------------------------------------*/
(function($) {
	"use strict";

	var options = {
			item: '.b-navmenu-item',
			submenu: '.b-navmenu-submenu',
			activeItem: 'b-navmenu-item-active'
		},
		currentActive = null,
		menuClicked = false;

	function changeLang() {
		if (this.value) {
			window.location = Site.siteroot + "/tools/setlang.bml?lang=" + this.value + "&returnto=" + encodeURIComponent(window.location);
		}
	}

	function docClick(ev) {
		if (currentActive && !menuClicked) {
			currentActive.removeClass(options.activeItem);
			currentActive = null;
		}

		menuClicked = false;
	}

	function menuClick(ev) {
		var newActive = jQuery(this).closest(options.item);

		//for touch devices we should just expand menu on first tap
		if (newActive.hasClass(options.activeItem) || newActive.find(options.submenu).length === 0) {
			return; //we should pass the handler here
		}

		if (currentActive) {
			currentActive.removeClass(options.activeItem);
		}

		currentActive = jQuery(this).closest(options.item);
		currentActive.addClass(options.activeItem);
		menuClicked = true;

		ev.preventDefault();
	}

	function initScheme() {
		$('#footer_lang_list').on('change', changeLang);

		if (LJ.Support.touch && window.vertigo) {
			$('.b-navmenu').on('click', '.b-navmenu-rootlink', menuClick);
			$(document).on('touchstart', docClick);
		}
	}

	LiveJournal.register_hook('page_load', initScheme);
}(jQuery));

/* file: js/jquery/jquery.vkloader.js 
----------------------------------------------------------------------------------*/
/*!
 * LiveJournal loader for vkontakte like buttons.
 *
 * Copyright 2011, dmitry.petrov@sup.com
 *
 * VK script is often loaded with notable delay, so
 * plugin just loads it after the page rendering and
 * allows to display page faster.
 *
 */
( function( $ ) {

	if( $.VK ) { return; }

	$.VK = {};

	var onloads = [];
		buttons = [],
		onloadPassed = false,
		scriptLoaded = false,
		scriptLoading = false;

	/**
	 * Public API
	 *
	 * @namespase $.VK
	 */
	$.VK = {

		/**
		 * Init VK object after the script load.
		 *     Function passes all option to the VK.init
		 *  @param {Object} options
		 */
		init: function( options ) {
			onloads.push( function() {
				VK.init( options );
			} )
		},

		/**
		 * Add button to init after script load.
		 *    If this method was called after the page load, and script wasn't downloaded yet,
		 *    it will trigger downloading.
		 */
		addButton: function( elementId, options ) {
			buttons.push( {
				id: elementId,
				options: options
			} );

			if( onloadPassed && !scriptLoading ) {
				if( scriptLoaded ) {
					initButtons();
				} else {
					loadScript( initButtons );
				}
			}
		}
	}

	function initButtons() {
		for( var i = 0; i < buttons.length; ++i ) {
			VK.Widgets.Like( buttons[ i ].id, buttons[ i ].options );
		}

		buttons = [];
	}

	function loadScript( onload ) {
		onload = onload || $.noop;
		scriptLoading = true;

		$.getScript( 'http://userapi.com/js/api/openapi.js?31', function() {
			scriptLoading = false;
			scriptLoaded = true;
			for( var i = 0; i < onloads.length; ++i ) {

				onloads[ i ]();
			}
			onloads = [];
			onload();
		} );
	}

	jQuery( function() {
		//Do not download the script if the widgets were not added yet.
		if( buttons.length ) {
			//Do not load the script directly after the page load.
			//We don't want to delay other onload functions somehow.
			setTimeout( function() {
				loadScript( initButtons );
			}, 500 );
		}
		onloadPassed = true;
	} );

} ) ( jQuery );

/* file: js/lj.api.js 
----------------------------------------------------------------------------------*/
(function ($) {
	"use strict";
	/**
	 * TODO:
	 *
	 * If this api will go outside of livejournal.com it should get rid of all dependencies
	 * from jquery.js and basic.js and should require only a few libs from LJ namespace through LJ.require
	 * to handle everything.
	 */

	/**
	 * @namespace LJ.Api
	 * @requires basic.js, jquery.js, livejournal.js, jquery/jquery.xdomainrequest.js, lj.postmessage.js
	 * @description Api provides an unified method to handle communications with the server.
	 * @author dmitry.petrov@sup.com (Dmitry Petrov), anazarov@sup.com (Alexander Nazarov)
	 */
	LJ.define('LJ.Api');

	LJ.require('LJ.console');
	LJ.require('LJ.Support');

	var origin = location.protocol + '//' + location.host,
		siteroot = window.Site? Site.siteroot : origin,
		url = '/__api/',
		cdn = {
			endpoint: (window.Site && location.protocol === 'http:')? (Site.jsonrpcprefix || Site.statprefix) : null,
			time: (window.Site? Site.server_time * 1000 : +new Date()),
			methods: {}
		},
		context = {
			options: {},
			endpoint: siteroot,
			sameDomain: siteroot === origin
		};

	cdn.time -= cdn.time % 9E+5;

	function createRequestBody(name, params) {
		return {
			jsonrpc: '2.0',
			method: name,
			params: $.extend({}, params, { auth_token: context.options.auth_token }),
			id: Unique.id()
		};
	}

	function handleAnswer(callback, answer) {
		if (answer.result) {
			if (!answer.result.auth_token) {
				LJ.console.log('Warn: server did not return the new auth_token, further request may fail');
			} else {
				context.options.auth_token = answer.result.auth_token;
				delete answer.result.auth_token;
			}

			if (callback) {
				callback(answer.result);
			}
		} else if (answer.error) {
			if (callback) {
				callback({ error: answer.error });
			}
		}
	}

	function handleError(name, params, callback) {
		LJ.console.log('Warn: An internal error has occured while calling the method ', name, 'with params ', params);

		if (callback) {
			callback({
				error: {
					message: 'Internal error',
					code: 1
				}
			});
		}
	}

	/**
	 * Init LJ functionality.
	 *
	 * @param {Object} options Options for init object. auth_token field is required for further actions.
	 */
	LJ.Api.init = function(options) {
		options = options || {};

		if (context._initFired) {
			LJ.console.log('Warn: LJ.Api.init was already called before');
		}

		context._initFired = true;
		context.options = $.extend({}, options);

		if (!context.options.auth_token) {
			LJ.console.log('Warn: Auth token has not been specified, request may fail');
		}

		if (cdn.endpoint) {
			if (Site.rpc && Array.isArray(Site.rpc.public)) {
				Site.rpc.public.forEach(function (method) {
					cdn.methods[method] = true;
				});
			}
		}

		LJ.UI.bootstrap('lj-api');
	};

	/**
	 * Call api method on the server.
	 *
	 * @param {string} name Method name.
	 * @param {Object=} params A hash with parameters to send to the server.
	 * @param {Function=} callback Callback will be fired with results from the server.
	 */
	LJ.Api.call = function(name, params, callback) {
		var request = createRequestBody(name, params),
			publicMethod = !!cdn.methods.hasOwnProperty(name),
			endpoint = publicMethod? cdn.endpoint : context.endpoint,
			ajax, reqstr;

		if (!publicMethod && (LJ.Support.cors || context.sameDomain)) {
			/* CORS support detected or is not needed */
			ajax = $.ajax({
				url: endpoint + url,
				type: 'POST',
				dataType: 'json',
				contentType: 'text/plain',
				xhrFields: context.sameDomain? {} : { withCredentials: true },
				data: LiveJournal.JSON.stringify(request)
			});
		} else {
			/* Fall back to JSONP */

			if (publicMethod) {
				delete request.params.auth_token;
				request.id = cdn.time;
			}

			reqstr = LiveJournal.JSON.stringify(request);

			ajax = $.ajax($.extend({
				url: endpoint + url,
				dataType: 'jsonp',
				data: { request: reqstr }
			}, publicMethod? { cache: true, jsonpCallback: 'jQuery' + cdn.time } : {}));
		}

		ajax
			.success(handleAnswer.bind(null, callback))
			.error(handleError.bind(null, name, params, callback));

		return ajax;
	};
}(jQuery));
