// http://underscorejs.org/underscore-min.js/*    json2.js    2011-10-19    Public Domain.    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.    See http://www.JSON.org/js.html    This code should be minified before deployment.    See http://javascript.crockford.com/jsmin.html    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO    NOT CONTROL.    This file creates a global JSON object containing two methods: stringify    and parse.        JSON.stringify(value, replacer, space)            value       any JavaScript value, usually an object or array.            replacer    an optional parameter that determines how object                        values are stringified for objects. It can be a                        function or an array of strings.            space       an optional parameter that specifies the indentation                        of nested structures. If it is omitted, the text will                        be packed without extra whitespace. If it is a number,                        it will specify the number of spaces to indent at each                        level. If it is a string (such as '\t' or '&nbsp;'),                        it contains the characters used to indent at each level.            This method produces a JSON text from a JavaScript value.            When an object value is found, if the object contains a toJSON            method, its toJSON method will be called and the result will be            stringified. A toJSON method does not serialize: it returns the            value represented by the name/value pair that should be serialized,            or undefined if nothing should be serialized. The toJSON method            will be passed the key associated with the value, and this will be            bound to the value            For example, this would serialize Dates as ISO strings.                Date.prototype.toJSON = function (key) {                    function f(n) {                        // Format integers to have at least two digits.                        return n < 10 ? '0' + n : n;                    }                    return this.getUTCFullYear()   + '-' +                         f(this.getUTCMonth() + 1) + '-' +                         f(this.getUTCDate())      + 'T' +                         f(this.getUTCHours())     + ':' +                         f(this.getUTCMinutes())   + ':' +                         f(this.getUTCSeconds())   + 'Z';                };            You can provide an optional replacer method. It will be passed the            key and value of each member, with this bound to the containing            object. The value that is returned from your method will be            serialized. If your method returns undefined, then the member will            be excluded from the serialization.            If the replacer parameter is an array of strings, then it will be            used to select the members to be serialized. It filters the results            such that only members with keys listed in the replacer array are            stringified.            Values that do not have JSON representations, such as undefined or            functions, will not be serialized. Such values in objects will be            dropped; in arrays they will be replaced with null. You can use            a replacer function to replace those with JSON values.            JSON.stringify(undefined) returns undefined.            The optional space parameter produces a stringification of the            value that is filled with line breaks and indentation to make it            easier to read.            If the space parameter is a non-empty string, then that string will            be used for indentation. If the space parameter is a number, then            the indentation will be that many spaces.            Example:            text = JSON.stringify(['e', {pluribus: 'unum'}]);            // text is '["e",{"pluribus":"unum"}]'            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'            text = JSON.stringify([new Date()], function (key, value) {                return this[key] instanceof Date ?                    'Date(' + this[key] + ')' : value;            });            // text is '["Date(---current time---)"]'        JSON.parse(text, reviver)            This method parses a JSON text to produce an object or array.            It can throw a SyntaxError exception.            The optional reviver parameter is a function that can filter and            transform the results. It receives each of the keys and values,            and its return value is used instead of the original value.            If it returns what it received, then the structure is not modified.            If it returns undefined then the member is deleted.            Example:            // Parse the text. Values that look like ISO date strings will            // be converted to Date objects.            myData = JSON.parse(text, function (key, value) {                var a;                if (typeof value === 'string') {                    a =/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);                    if (a) {                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],                            +a[5], +a[6]));                    }                }                return value;            });            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {                var d;                if (typeof value === 'string' &&                        value.slice(0, 5) === 'Date(' &&                        value.slice(-1) === ')') {                    d = new Date(value.slice(5, -1));                    if (d) {                        return d;                    }                }                return value;            });    This is a reference implementation. You are free to copy, modify, or    redistribute.*//*jslint evil: true, regexp: true *//*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,    lastIndex, length, parse, prototype, push, replace, slice, stringify,    test, toJSON, toString, valueOf*/// Create a JSON object only if one does not already exist. We create the// methods in a closure to avoid creating global variables.var JSON;if (!JSON) {    JSON = {};}(function () {    'use strict';    function f(n) {        // Format integers to have at least two digits.        return n < 10 ? '0' + n : n;    }    if (typeof Date.prototype.toJSON !== 'function') {        Date.prototype.toJSON = function (key) {            return isFinite(this.valueOf())                ? this.getUTCFullYear()     + '-' +                    f(this.getUTCMonth() + 1) + '-' +                    f(this.getUTCDate())      + 'T' +                    f(this.getUTCHours())     + ':' +                    f(this.getUTCMinutes())   + ':' +                    f(this.getUTCSeconds())   + 'Z'                : null;        };        String.prototype.toJSON      =            Number.prototype.toJSON  =            Boolean.prototype.toJSON = function (key) {                return this.valueOf();            };    }    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,        gap,        indent,        meta = {    // table of character substitutions            '\b': '\\b',            '\t': '\\t',            '\n': '\\n',            '\f': '\\f',            '\r': '\\r',            '"' : '\\"',            '\\': '\\\\'        },        rep;    function quote(string) {// If the string contains no control characters, no quote characters, and no// backslash characters, then we can safely slap some quotes around it.// Otherwise we must also replace the offending characters with safe escape// sequences.        escapable.lastIndex = 0;        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {            var c = meta[a];            return typeof c === 'string'                ? c                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);        }) + '"' : '"' + string + '"';    }    function str(key, holder) {// Produce a string from holder[key].        var i,          // The loop counter.            k,          // The member key.            v,          // The member value.            length,            mind = gap,            partial,            value = holder[key];// If the value has a toJSON method, call it to obtain a replacement value.        if (value && typeof value === 'object' &&                typeof value.toJSON === 'function') {            value = value.toJSON(key);        }// If we were called with a replacer function, then call the replacer to// obtain a replacement value.        if (typeof rep === 'function') {            value = rep.call(holder, key, value);        }// What happens next depends on the value's type.        switch (typeof value) {        case 'string':            return quote(value);        case 'number':// JSON numbers must be finite. Encode non-finite numbers as null.            return isFinite(value) ? String(value) : 'null';        case 'boolean':        case 'null':// If the value is a boolean or null, convert it to a string. Note:// typeof null does not produce 'null'. The case is included here in// the remote chance that this gets fixed someday.            return String(value);// If the type is 'object', we might be dealing with an object or an array or// null.        case 'object':// Due to a specification blunder in ECMAScript, typeof null is 'object',// so watch out for that case.            if (!value) {                return 'null';            }// Make an array to hold the partial results of stringifying this object value.            gap += indent;            partial = [];// Is the value an array?            if (Object.prototype.toString.apply(value) === '[object Array]') {// The value is an array. Stringify every element. Use null as a placeholder// for non-JSON values.                length = value.length;                for (i = 0; i < length; i += 1) {                    partial[i] = str(i, value) || 'null';                }// Join all of the elements together, separated with commas, and wrap them in// brackets.                v = partial.length === 0                    ? '[]'                    : gap                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'                    : '[' + partial.join(',') + ']';                gap = mind;                return v;            }// If the replacer is an array, use it to select the members to be stringified.            if (rep && typeof rep === 'object') {                length = rep.length;                for (i = 0; i < length; i += 1) {                    if (typeof rep[i] === 'string') {                        k = rep[i];                        v = str(k, value);                        if (v) {                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                        }                    }                }            } else {// Otherwise, iterate through all of the keys in the object.                for (k in value) {                    if (Object.prototype.hasOwnProperty.call(value, k)) {                        v = str(k, value);                        if (v) {                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                        }                    }                }            }// Join all of the member texts together, separated with commas,// and wrap them in braces.            v = partial.length === 0                ? '{}'                : gap                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'                : '{' + partial.join(',') + '}';            gap = mind;            return v;        }    }// If the JSON object does not yet have a stringify method, give it one.    if (typeof JSON.stringify !== 'function') {        JSON.stringify = function (value, replacer, space) {// The stringify method takes a value and an optional replacer, and an optional// space parameter, and returns a JSON text. The replacer can be a function// that can replace values, or an array of strings that will select the keys.// A default replacer method can be provided. Use of the space parameter can// produce text that is more easily readable.            var i;            gap = '';            indent = '';// If the space parameter is a number, make an indent string containing that// many spaces.            if (typeof space === 'number') {                for (i = 0; i < space; i += 1) {                    indent += ' ';                }// If the space parameter is a string, it will be used as the indent string.            } else if (typeof space === 'string') {                indent = space;            }// If there is a replacer, it must be a function or an array.// Otherwise, throw an error.            rep = replacer;            if (replacer && typeof replacer !== 'function' &&                    (typeof replacer !== 'object' ||                    typeof replacer.length !== 'number')) {                throw new Error('JSON.stringify');            }// Make a fake root object containing our value under the key of ''.// Return the result of stringifying the value.            return str('', {'': value});        };    }// If the JSON object does not yet have a parse method, give it one.    if (typeof JSON.parse !== 'function') {        JSON.parse = function (text, reviver) {// The parse method takes a text and an optional reviver function, and returns// a JavaScript value if the text is a valid JSON text.            var j;            function walk(holder, key) {// The walk method is used to recursively walk the resulting structure so// that modifications can be made.                var k, v, value = holder[key];                if (value && typeof value === 'object') {                    for (k in value) {                        if (Object.prototype.hasOwnProperty.call(value, k)) {                            v = walk(value, k);                            if (v !== undefined) {                                value[k] = v;                            } else {                                delete value[k];                            }                        }                    }                }                return reviver.call(holder, key, value);            }// Parsing happens in four stages. In the first stage, we replace certain// Unicode characters with escape sequences. JavaScript handles many characters// incorrectly, either silently deleting them, or treating them as line endings.            text = String(text);            cx.lastIndex = 0;            if (cx.test(text)) {                text = text.replace(cx, function (a) {                    return '\\u' +                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                });            }// In the second stage, we run the text against regular expressions that look// for non-JSON patterns. We are especially concerned with '()' and 'new'// because they can cause invocation, and '=' because it can cause mutation.// But just to be safe, we want to reject all unexpected forms.// We split the second stage into 4 regexp operations in order to work around// crippling inefficiencies in IE's and Safari's regexp engines. First we// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we// replace all simple value tokens with ']' characters. Third, we delete all// open brackets that follow a colon or comma or that begin the text. Finally,// we look to see that the remaining characters are only whitespace or ']' or// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.            if (/^[\],:{}\s]*$/                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {// In the third stage we use the eval function to compile the text into a// JavaScript structure. The '{' operator is subject to a syntactic ambiguity// in JavaScript: it can begin a block or an object literal. We wrap the text// in parens to eliminate the ambiguity.                j = eval('(' + text + ')');// In the optional fourth stage, we recursively walk the new structure, passing// each name/value pair to a reviver function for possible transformation.                return typeof reviver === 'function'                    ? walk({'': j}, '')                    : j;            }// If the text is not JSON parseable, then a SyntaxError is thrown.            throw new SyntaxError('JSON.parse');        };    }}());/*! Lo-Dash 0.5.2 lodash.com/license Underscore.js 1.3.3 github.com/documentcloud/underscore/blob/master/LICENSE*/;(function(e,t){"use strict";function i(){}function s(){for(var e,t,n,i=-1,s=arguments.length,a={e:"",f:"",j:"",q:"",c:{d:""},m:{d:""}};++i<s;)for(t in e=arguments[i],e)n=null==(n=e[t])?"":n,/d|i/.test(t)?("string"==typeof n&&(n={b:n,l:n}),a.c[t]=n.b,a.m[t]=n.l):a[t]=n;e=a.a,t=/^[^,]+/.exec(e)[0],a.g=t,a.h=O,a.k=P,a.n=M,a.p=b,a.r=a.r!==r,a.s=a.s!==r,"o"in a||(a.o=_),a.f||(a.f="if(!"+t+")return s");if("b"!=t||!a.c.i)a.c=null;t="",a.s&&(t+="'use strict';"),t+="var g,y,h="+a.g+",s",a.j&&(t+="="+a.j),t+=";"+a.f+";"+a.q+";",a.c&&(t+="var j=h.length;g=-1;",a.m&&(t+="if(j>-1&&j===j>>>0){"),a.o&&(t+="if(x.call(h)==v){h=h.split('')}"),t+=a.c.d+";while(++g<j){y=h[g];"+a.c.i+"}",a.m&&(t+="}"));if(a.m){a.c?t+="else{":a.n&&(t+="var j=h.length;g=-1;if(j&&P(h)){while(++g<j){y=h[g+=''];"+a.m.i+"}}else{"),a.h||(t+="var t=typeof h=='function'&&p.call(h,'prototype');"),a.k&&a.r?(t+="var m=-1,n=Y[typeof h]?k(h):[],j=n.length;"+a.m.d+";while(++m<j){g=n[m];",a.h||(t+="if(!(t&&g=='prototype')){"),t+="y=h[g];"+a.m.i+"",a.h||(t+="}")):(t+=a.m.d+";for(g in h){",a.h?(a.r&&(t+="if(e.call(h,g)){"),t+="y=h[g];"+a.m.i+";",a.r&&(t+="}")):(t+="if(!(t&&g=='prototype')",a.r&&(t+="&&e.call(h,g)"),t+="){y=h[g];"+a.m.i+"}")),t+="}";if(a.h){t+="var d=h.constructor;";for(n=0;7>n;n++)t+="g='"+a.p[n]+"';if(","constructor"==a.p[n]&&(t+="!(d&&d.prototype===h)&&"),t+="e.call(h,g)){y=h[g];"+a.m.i+"}"}if(a.c||a.n)t+="}"}return t+=a.e+";return s",Function("D,E,F,I,c,e,f,N,P,T,i,X,Y,k,p,u,v,x","var G=function("+e+"){"+t+"};return G")(H,m,p,o,w,E,d,c,f,l,u,L,B,C,S,x,A,T)}function o(e,n){var r=e.b,i=n.b,e=e.a,n=n.a;return e===t?1:n===t?-1:e<n?-1:e>n?1:r<i?-1:1}function u(e,t){return function(n,r,i){return e.call(t,n,r,i)}}function a(){}function f(e){return T.call(e)==k}function l(e){return"function"==typeof e}function c(e,t,n){if(!e)return-1;var r=-1,i=e.length;if(n){if("number"!=typeof n)return r=h(e,t),e[r]===t?r:-1;r=(0>n?Math.max(0,i+n):n)-1}for(;++r<i;)if(e[r]===t)return r;return-1}function h(e,t,n,r){if(!e)return 0;var i=0,s=e.length;if(n){r&&(n=p(n,r));for(t=n(t);i<s;)r=i+s>>>1,n(e[r])<t?i=r+1:s=r}else for(;i<s;)r=i+s>>>1,e[r]<t?i=r+1:s=r;return i}function p(e,t){function n(){var o=arguments,u=t;return i||(e=t[r]),s.length&&(o=o.length?s.concat(x.call(o)):s),this instanceof n?(a.prototype=e.prototype,u=new a,(o=e.apply(u,o))&&B[typeof o]?o:u):e.apply(u,o)}var r,i=l(e);if(i){if(D||N&&2<arguments.length)return N.call.apply(N,arguments)}else r=t,t=e;var s=x.call(arguments,2);return n}function d(e){return e}var n=!0,r=!1,v="object"==typeof exports&&exports&&("object"==typeof global&&global&&global==global.global&&(e=global),exports),m=Array.prototype,g=Object.prototype,y=RegExp("^"+(g.valueOf+"").replace(/[.*+?^=!:${}()|[\]\/\\]/g,"\\$&").replace(/valueOf|for [^\]]+/g,".+?")+"$"),b="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),w=m.concat,E=g.hasOwnProperty,S=g.propertyIsEnumerable,x=m.slice,T=g.toString,N=y.test(N=x.bind)&&N,C=y.test(C=Object.keys)&&C,k="[object Arguments]",L="[object Object]",A="[object String]",O,M=n;(function(){function e(){this.x=1}var t=[];e.prototype={valueOf:1,y:1};for(var n in new e)t.push(n);for(n in arguments)M=!n;O=4>(t+"").length})(1);var g=!f(arguments),_="xx"!="x"[0]+Object("x")[0],D=N&&/\n|Opera/.test(N+T.call(e.opera)),P=C&&/^.+$|true/.test(C+!!e.attachEvent),H={"[object Arguments]":n,"[object Array]":n,"[object Boolean]":r,"[object Date]":r,"[object Function]":r,"[object Number]":r,"[object Object]":r,"[object RegExp]":r,"[object String]":n},B={"boolean":r,"function":n,object:n,number:r,string:r,"undefined":r,unknown:n},j={j:"",f:"if(!b)return[]",d:{b:"s=Array(j)",l:"s="+(P?"Array(j)":"[]")},i:{b:"s[g]=a(y,g,b)",l:"s"+(P?"[m]=":".push")+"(a(y,g,b))"}};g&&(f=function(e){return!!e&&!!E.call(e,"callee")}),l(/x/)&&(l=function(e){return"[object Function]"==T.call(e)});var F=s({a:"l",j:"[]",i:"s.push(g)"}),g=C?function(e){var t=typeof e;return"function"==t&&S.call(e,"prototype")?F(e):e&&B[t]?C(e):[]}:F,y=s({a:"l",j:"[]",i:"s.push(y)"}),I=s({a:"b,hh",j:"false",o:r,d:{b:"if(x.call(h)==v)return b.indexOf(hh)>-1"},i:"if(y===hh)return true"}),j=s({a:"b,a,w",j:"b",q:"if(!a)a=f;else if(w)a=i(a,w)",i:"if(a(y,g,b)===false)return s"},j),q=s({a:"b,a,z,w",j:"z",q:"var W=arguments.length<3;if(w)a=i(a,w)",d:{b:"if(W)s=b[++g]"},i:{b:"s=a(s,y,g,b)",l:"s=W?(W=false,y):a(s,y,g,b)"}});i.VERSION="0.5.2",i.bind=p,i.contains=I,i.identity=d,i.indexOf=c,i.isArguments=f,i.isFunction=l,i.keys=g,i.map=j,i.reduce=q,i.sortedIndex=h,i.union=function(){for(var e=-1,t=[],n=w.apply(t,arguments),r=n.length;++e<r;)0>c(t,n[e])&&t.push(n[e]);return t},i.values=y,i.collect=j,i.foldl=q,i.include=I,i.inject=q,typeof define=="function"&&typeof define.amd=="object"&&define.amd?(e._=i,define(function(){return i})):v?"object"==typeof module&&module&&module.t==v?(module.t=i)._=i:v._=i:e._=i})(this);/** @license MIT License (c) copyright B Cavalier & J Hann *//** * curl (cujo resource loader) * An AMD-compliant javascript module and resource loader * * curl is part of the cujo.js family of libraries (http://cujojs.com/) * * Licensed under the MIT License at: * 		http://www.opensource.org/licenses/mit-license.php * * @version 0.6.5 */(function (global) {"use strict";	var		version = '0.6.5',		curlName = 'curl',		userCfg = global[curlName],		prevCurl,		prevDefine,		doc = global.document,		head = doc && (doc['head'] || doc.getElementsByTagName('head')[0]),		// constants / flags		msgUsingExports = {},		msgFactoryExecuted = {},		interactive = {},		// this is the list of scripts that IE is loading. one of these will		// be the "interactive" script. too bad IE doesn't send a readystatechange		// event to tell us exactly which one.		activeScripts = {},		// these are always handy :)		cleanPrototype = {},		toString = cleanPrototype.toString,		undef,		// script ready states that signify it's loaded		readyStates = { 'loaded': 1, 'interactive': interactive, 'complete': 1 },		// local cache of resource definitions (lightweight promises)		cache = {},		// preload are files that must be loaded before any others		preload = false,		// net to catch anonymous define calls' arguments (non-IE browsers)		argsNet,		// RegExp's used later, "cached" here		dontAddExtRx = /\?/,		absUrlRx = /^\/|^[^:]+:\/\//,		findLeadingDotsRx = /(\.)(\.?)(?:$|\/([^\.\/]+.*)?)/g, // /(?:^|\/)(\.)(\.?)\/?/g,		removeCommentsRx = /\/\*[\s\S]*?\*\/|(?:[^\\])\/\/.*?[\n\r]/g,		findRValueRequiresRx = /require\s*\(\s*["']([^"']+)["']\s*\)|(?:[^\\]?)(["'])/g,		cjsGetters,		core;	function noop () {}	function isType (obj, type) {		return toString.call(obj).indexOf('[object ' + type) == 0;	}	function normalizePkgDescriptor (descriptor) {		var main;		descriptor.path = removeEndSlash(descriptor['path'] || descriptor['location'] || '');		main = removeEndSlash(descriptor['main']) || 'main';		if (main.charAt(0) != '.') main = './' + main;		// trailing slashes trick reduceLeadingDots to see them as base ids		descriptor.main = reduceLeadingDots(main, descriptor.name + '/');		descriptor.mainPath = reduceLeadingDots(main, descriptor.path + '/');		descriptor.config = descriptor['config'];		return descriptor;	}	function joinPath (path, file) {		return removeEndSlash(path) + '/' + file;	}	function removeEndSlash (path) {		return path && path.charAt(path.length - 1) == '/' ? path.substr(0, path.length - 1) : path;	}	function reduceLeadingDots (childId, baseId) {		// this algorithm is similar to dojo's compactPath, which interprets		// module ids of "." and ".." as meaning "grab the module whose name is		// the same as my folder or parent folder".  These special module ids		// are not included in the AMD spec but seem to work in node.js, too.		var levels, removeLevels, isRelative;		removeLevels = 1;		childId = childId.replace(findLeadingDotsRx, function (m, dot, doubleDot, remainder) {			if (doubleDot) removeLevels++;			isRelative = true;			return remainder || '';		});		// TODO: throw if removeLevels > baseId levels in debug module		if (isRelative) {			levels = baseId.split('/');			levels.splice(levels.length - removeLevels, removeLevels);			// childId || [] is a trick to not concat if no childId			return levels.concat(childId || []).join('/');		}		else {			return childId;		}	}	function pluginParts (id) {		var delPos = id.indexOf('!');		return {			resourceId: id.substr(delPos + 1),			// resourceId can be zero length			pluginId: delPos >= 0 && id.substr(0, delPos)		};	}	function Begetter () {}	function beget (parent, mixin) {		Begetter.prototype = parent || cleanPrototype;		var child = new Begetter();		Begetter.prototype = cleanPrototype;		for (var p in mixin) child[p] = mixin[p];		return child;	}	function Promise () {		var self, thens, complete;		self = this;		thens = [];		function then (resolved, rejected, progressed) {			// capture calls to callbacks			thens.push([resolved, rejected, progressed]);		}		function notify (which, arg) {			// complete all callbacks			var aThen, cb, i = 0;			while ((aThen = thens[i++])) {				cb = aThen[which];				if (cb) cb(arg);			}		}		complete = function promiseComplete (success, arg) {			// switch over to sync then()			then = success ?				function (resolved, rejected) { resolved && resolved(arg); } :				function (resolved, rejected) { rejected && rejected(arg); };			// we no longer throw during multiple calls to resolve or reject			// since we don't really provide useful information anyways.			complete = noop;			// complete all callbacks			notify(success ? 0 : 1, arg);			// no more notifications			notify = noop;			// release memory			thens = undef;		};		this.then = function (resolved, rejected, progressed) {			then(resolved, rejected, progressed);			return self;		};		this.resolve = function (val) {			self.resolved = val;			complete(true, val);		};		this.reject = function (ex) {			self.rejected = ex;			complete(false, ex);		};		this.progress = function (msg) {			notify(2, msg);		}	}	function isPromise (o) {		return o instanceof Promise;	}	function when (promiseOrValue, callback, errback, progback) {		// we can't just sniff for then(). if we do, resources that have a		// then() method will make dependencies wait!		if (isPromise(promiseOrValue)) {			return promiseOrValue.then(callback, errback, progback);		}		else {			return callback(promiseOrValue);		}	}	/**	 * Returns a function that when executed, executes a lambda function,	 * but only executes it the number of times stated by howMany.	 * When done executing, it executes the completed function. Each callback	 * function receives the same parameters that are supplied to the	 * returned function each time it executes.  In other words, they	 * are passed through.	 * @private	 * @param howMany {Number} must be greater than zero	 * @param lambda {Function} executed each time	 * @param completed {Function} only executes once when the counter	 *   reaches zero	 * @returns {Function}	 */	function countdown (howMany, lambda, completed) {		var result;		return function () {			if (--howMany >= 0 && lambda) result = lambda.apply(undef, arguments);			// we want ==, not <=, since some callers expect call-once functionality			if (howMany == 0 && completed) completed(result);			return result;		}	}	core = {		createContext: function (cfg, baseId, depNames, isPreload) {			var def;			def = new Promise();			def.ctxId = def.id = baseId || ''; // '' == global			def.isPreload = isPreload;			def.depNames = depNames;			// functions that dependencies will use:			function toAbsId (childId) {				return reduceLeadingDots(childId, def.ctxId);			}			function toUrl (n) {				// even though internally, we don't seem to need to do				// toAbsId, the AMD spec says we need to do this for plugins.				// also, the spec states that we should not append an extension				// in this function.				return core.resolvePathInfo(toAbsId(n), cfg).url;			}			function localRequire (ids, callback) {				var cb, rvid, childDef, earlyExport;				// this is public, so send pure function				// also fixes issue #41				cb = callback && function () { callback.apply(undef, arguments[0]); };				// RValue require (CommonJS)				if (isType(ids, 'String')) {					// return resource					rvid = toAbsId(ids);					childDef = cache[rvid];					earlyExport = isPromise(childDef) && childDef.exports;					if (!(rvid in cache)) {						// this should only happen when devs attempt their own						// manual wrapping of cjs modules or get confused with						// the callback syntax:						throw new Error('Module not resolved: '  + rvid);					}					if (cb) {						throw new Error('require(id, callback) not allowed');					}					return earlyExport || childDef;				}				else {					// use same id so that relative modules are normalized correctly					when(core.getDeps(core.createContext(cfg, def.ctxId, ids, isPreload)), cb);				}			}			def.require = localRequire;			localRequire['toUrl'] = toUrl;			def.toAbsId = toAbsId;			return def;		},		createResourceDef: function (cfg, id, isPreload, optCtxId) {			var def, origResolve, execute;			def = core.createContext(cfg, id, undef, isPreload);			def.ctxId = optCtxId == undef ? id : optCtxId;			origResolve = def.resolve;			// using countdown to only execute definition function once			execute = countdown(1, function (deps) {				def.deps = deps;				try {					return core.executeDefFunc(def);				}				catch (ex) {					def.reject(ex);				}			});			// intercept resolve function to execute definition function			// before resolving			def.resolve = function resolve (deps) {				when(isPreload || preload, function () {					origResolve((cache[def.id] = execute(deps)));				});			};			// track exports			def.exportsReady = function executeFactory (deps) {				when(isPreload || preload, function () {					// only resolve early if we also use exports (to avoid					// circular dependencies). def.exports will have already					// been set by the getDeps loop before we get here.					if (def.exports) {						execute(deps);						def.progress(msgFactoryExecuted);					}				});			};			return def;		},		createPluginDef: function (cfg, id, isPreload, ctxId) {			var def;			def = core.createContext(cfg, id, undef, isPreload);			def.ctxId = ctxId;			return def;		},		getCjsRequire: function (def) {			return def.require;		},		getCjsExports: function (def) {			return def.exports || (def.exports = {});		},		getCjsModule: function (def) {			var module = def.module;			if (!module) {				module = def.module = {					'id': def.id,					'uri': core.getDefUrl(def),					'exports': core.getCjsExports(def)				};				module.exports = module['exports']; // oh closure compiler!			}			return module;		},		getDefUrl: function (def) {			// note: don't look up an anon module's id from it's own toUrl cuz			// the parent's config was used to find this module			// the toUrl fallback is for named modules in built files			// which must have absolute ids.			return def.url || (def.url = core.checkToAddJsExt(def.require['toUrl'](def.id)));		},		config: function (cfg) {			var hasCfg, defineName,				apiName, apiObj, defName, defObj, define;			hasCfg = cfg;			defineName = 'define';			if (!cfg) cfg = {};			// allow dev to rename/relocate curl() to another object			apiName = cfg['apiName'] || curlName;			apiObj = cfg['apiContext'] || global;			// if the dev is overwriting an existing curl()			if (apiObj != global || apiName != curlName ? apiObj[apiName] : prevCurl && hasCfg) {				throw new Error(apiName + ' already exists');			}			apiObj[apiName] = _curl;			// restore previous curl			if (prevCurl && hasCfg) global[curlName] = prevCurl;			// allow dev to rename/relocate define() to another object			defName = cfg['defineName'] || defineName;			defObj = cfg['defineContext'] || global;			if (defObj != global || defName != defineName ? defObj[defName] : prevDefine && hasCfg) {				throw new Error(defName + ' already exists');			}			defObj[defName] = define = function () {				// wrap inner _define so it can be replaced without losing define.amd				var args = core.fixArgs(arguments);				_define(args);			};			// restore previous define			if (prevDefine && hasCfg) global[defineName] = prevDefine;			// indicate our capabilities:			define['amd'] = { 'plugins': true, 'jQuery': true, curlName: version };			// switch to re-runnable config			if (hasCfg) core.config = core.moreConfig;			return core.moreConfig(cfg);		},		moreConfig: function (cfg, prevCfg) {			var newCfg, pluginCfgs;			if (!prevCfg) prevCfg = {};			newCfg = beget(prevCfg, cfg);			// set defaults and convert from closure-safe names			newCfg.baseUrl = newCfg['baseUrl'] || '';			newCfg.pluginPath = newCfg['pluginPath'] || 'curl/plugin';			// create object to hold path map.			// each plugin and package will have its own pathMap, too.			newCfg.pathMap = beget(prevCfg.pathMap);			pluginCfgs = newCfg.plugins = beget(prevCfg.plugins, cfg['plugins']);			// temporary arrays of paths. this will be converted to			// a regexp for fast path parsing.			newCfg.pathList = [];			// normalizes path/package info and places info on either			// the global cfg.pathMap or on a plugin-specific altCfg.pathMap.			// also populates a pathList on cfg or plugin configs.			function fixAndPushPaths (coll, isPkg) {				var id, pluginId, data, parts, currCfg, info;				for (var name in coll) {					data = coll[name];					// grab the package id, if specified. default to					// property name.					data.name = data['id'] || data['name'] || name;					currCfg = newCfg;					// don't remove `|| name` since data may be a string, not an object					parts = pluginParts(removeEndSlash(data.name || name));					id = parts.resourceId;					pluginId = parts.pluginId;					if (pluginId) {						// plugin-specific path						currCfg = pluginCfgs[pluginId];						if (!currCfg) {							currCfg = pluginCfgs[pluginId] = beget(newCfg);							currCfg.pathMap = beget(newCfg.pathMap);							currCfg.pathList = [];						}						// remove plugin-specific path from coll						delete coll[name];					}					if (isPkg) {						info = normalizePkgDescriptor(data);					}					else {						info = { path: removeEndSlash(data) };					}					info.specificity = id.split('/').length;					if (id) {						currCfg.pathMap[id] = info;						currCfg.pathList.push(id);					}					else {						// naked plugin name signifies baseUrl for plugin						// resources. baseUrl could be relative to global						// baseUrl.						currCfg.baseUrl = core.resolveUrl(data, newCfg);					}				}			}			// adds the path matching regexp onto the cfg or plugin cfgs.			function convertPathMatcher (cfg) {				var pathMap = cfg.pathMap;				cfg.pathRx = new RegExp('^(' +					cfg.pathList.sort(function (a, b) { return pathMap[a].specificity < pathMap[b].specificity; } )						.join('|')						.replace(/\/|\./g, '\\$&') +					')(?=\\/|$)'				);				delete cfg.pathList;			}			// fix all new paths and packages			fixAndPushPaths(cfg['paths'], false);			fixAndPushPaths(cfg['packages'], true);			// create search regex for each path map			for (var p in pluginCfgs) {				var pathList = pluginCfgs[p].pathList;				if (pathList) {					pluginCfgs[p].pathList = pathList.concat(newCfg.pathList);					convertPathMatcher(pluginCfgs[p]);				}			}			convertPathMatcher(newCfg);			return newCfg;		},		checkPreloads: function (cfg) {			var preloads;			preloads = cfg && cfg['preloads'];			if (preloads && preloads.length > 0) {				// chain from previous preload, if any.				when(preload, function () {					preload = core.getDeps(core.createContext(userCfg, undef, preloads, true));				});			}		},		resolvePathInfo: function (absId, cfg, forPlugin) {			// searches through the configured path mappings and packages			var pathMap, pathInfo, ctxId, path, pkgCfg, found;			pathMap = cfg.pathMap;			if (forPlugin && cfg.pluginPath && absId.indexOf('/') < 0 && !(absId in pathMap)) {				// prepend plugin folder path, if it's missing and path isn't in pathMap				// Note: this munges the concepts of ids and paths for plugins,				// but is generally safe since it's only for non-namespaced				// plugins (plugins without path or package info).				ctxId = absId = joinPath(cfg.pluginPath, absId);			}			if (!absUrlRx.test(absId)) {				path = absId.replace(cfg.pathRx, function (match) {					pathInfo = pathMap[match] || {};					found = true;					pkgCfg = pathInfo.config;					// if pathInfo.main and match == absId, this is a main module					if (pathInfo.main && match == absId) {						ctxId = pathInfo.main;						return pathInfo.mainPath;					}					// if pathInfo.path return pathInfo.path					else {						return pathInfo.path || '';					}				});			}			else {				path = absId;			}			return {				ctxId: ctxId || absId,				config: pkgCfg || userCfg,				url: core.resolveUrl(path, cfg)			};		},		resolveUrl: function (path, cfg) {			var baseUrl = cfg.baseUrl;			return baseUrl && !absUrlRx.test(path) ? joinPath(baseUrl, path) : path;		},		checkToAddJsExt: function (url) {			// don't add extension if a ? is found in the url (query params)			// i'd like to move this feature to a moduleLoader			return url + (dontAddExtRx.test(url) ? '' : '.js');		},		loadScript: function (def, success, failure) {			// script processing rules learned from RequireJS			// insert script			var el = doc.createElement('script');			// initial script processing			function process (ev) {				ev = ev || global.event;				// detect when it's done loading				if (ev.type == 'load' || readyStates[el.readyState]) {					delete activeScripts[def.id];					// release event listeners					el.onload = el.onreadystatechange = el.onerror = ''; // ie cries if we use undefined					success();				}			}			function fail (e) {				// some browsers send an event, others send a string,				// but none of them send anything useful, so just say we failed:				failure(new Error('Syntax or http error: ' + def.url));			}			// set type first since setting other properties could			// prevent us from setting this later			// actually, we don't even need to set this at all			//el.type = 'text/javascript';			// using dom0 event handlers instead of wordy w3c/ms			el.onload = el.onreadystatechange = process;			el.onerror = fail;			// js! plugin uses alternate mimetypes			el.type = def.mimetype || 'text/javascript';			// TODO: support other charsets?			el.charset = 'utf-8';			el.async = !def.order;			el.src = def.url;			// loading will start when the script is inserted into the dom.			// IE will load the script sync if it's in the cache, so			// indicate the current resource definition if this happens.			activeScripts[def.id] = el;			// use insertBefore to keep IE from throwing Operation Aborted (thx Bryan Forbes!)			head.insertBefore(el, head.firstChild);			// the js! plugin uses this			return el;		},		extractCjsDeps: function (defFunc) {			// Note: ignores require() inside strings and comments			var source, ids = [], currQuote;			// prefer toSource (FF) since it strips comments			source = typeof defFunc == 'string' ?					 defFunc :					 defFunc.toSource ? defFunc.toSource() : defFunc.toString();			// remove comments, then look for require() or quotes			source.replace(removeCommentsRx, '').replace(findRValueRequiresRx, function (m, id, qq) {				// if we encounter a quote				if (qq) {					currQuote = currQuote == qq ? undef : currQuote;				}				// if we're not inside a quoted string				else if (!currQuote) {					ids.push(id);				}				return m; // uses least RAM/CPU			});			return ids;		},		fixArgs: function (args) {			// resolve args			// valid combinations for define:			// (string, array, object|function) sax|saf			// (array, object|function) ax|af			// (string, object|function) sx|sf			// (object|function) x|f			var id, deps, defFunc, defFuncArity, len, cjs;			len = args.length;			defFunc = args[len - 1];			defFuncArity = isType(defFunc, 'Function') ? defFunc.length : -1;			if (len == 2) {				if (isType(args[0], 'Array')) {					deps = args[0];				}				else {					id = args[0];				}			}			else if (len == 3) {				id = args[0];				deps = args[1];			}			// Hybrid format: assume that a definition function with zero			// dependencies and non-zero arity is a wrapped CommonJS module			if (!deps && defFuncArity > 0) {				cjs = true;				deps = ['require', 'exports', 'module'].slice(0, defFuncArity).concat(core.extractCjsDeps(defFunc));			}			return {				id: id,				deps: deps || [],				res: defFuncArity >= 0 ? defFunc : function () { return defFunc; },				cjs: cjs			};		},		executeDefFunc: function (def) {			var resource, moduleThis;			// the force of AMD is strong so anything returned			// overrides exports.			// node.js assumes `this` === `exports` so we do that			// for all cjs-wrapped modules, just in case.			// also, use module.exports if that was set			// (node.js convention).			// note: if .module exists, .exports exists.			moduleThis = def.cjs ? def.exports : undef;			resource = def.res.apply(moduleThis, def.deps);			if (resource === undef && def.exports) {				// note: exports will equal module.exports unless				// module.exports was reassigned inside module.				resource = def.module ? (def.exports = def.module.exports) : def.exports;			}			return resource;		},		defineResource: function (def, args) {			def.res = args.res;			def.cjs = args.cjs;			def.depNames = args.deps;			core.getDeps(def);		},		getDeps: function (parentDef) {			var i, names, deps, len, dep, completed, name,				exportCollector, resolveCollector;			deps = [];			names = parentDef.depNames;			len = names.length;			if (names.length == 0) allResolved();			function collect (dep, index, alsoExport) {				deps[index] = dep;				if (alsoExport) exportCollector(dep, index);			}			// reducer-collectors			exportCollector = countdown(len, collect, allExportsReady);			resolveCollector = countdown(len, collect, allResolved);			// initiate the resolution of all dependencies			// Note: the correct handling of early exports relies on the			// fact that the exports pseudo-dependency is always listed			// before other module dependencies.			for (i = 0; i < len; i++) {				name = names[i];				// is this "require", "exports", or "module"?				if (name in cjsGetters) {					// a side-effect of cjsGetters is that the cjs					// property is also set on the def.					resolveCollector(cjsGetters[name](parentDef), i, true);					// if we are using the `module` or `exports` cjs variables,					// signal any waiters/parents that we can export					// early (see progress callback in getDep below).					// note: this may fire for `require` as well, if it					// is listed after `module` or `exports` in teh deps list,					// but that is okay since all waiters will only record					// it once.					if (parentDef.exports) {						parentDef.progress(msgUsingExports);					}				}				// check for blanks. fixes #32.				// this helps support yepnope.js, has.js, and the has! plugin				else if (!name) {					resolveCollector(undef, i, true);				}				// normal module or plugin resource				else {					getDep(name, i);				}			}			return parentDef;			function getDep (name, index) {				var resolveOnce, exportOnce, childDef, earlyExport;				resolveOnce = countdown(1, function (dep) {					exportOnce(dep);					resolveCollector(dep, index);				});				exportOnce = countdown(1, function (dep) {					exportCollector(dep, index);				});				// get child def / dep				childDef = core.fetchDep(name, parentDef);				// check if childDef can export. if it can, then				// we missed the notification and it will never fire in the				// when() below.				earlyExport = isPromise(childDef) && childDef.exports;				if (earlyExport) {					exportOnce(earlyExport);				}				when(childDef,					resolveOnce,					parentDef.reject,					parentDef.exports && function (msg) {						// messages are only sent from childDefs that support						// exports, and we only notify parents that understand						// exports too.						if (childDef.exports) {							if (msg == msgUsingExports) {								// if we're using exports cjs variable on both sides								exportOnce(childDef.exports);							}							else if (msg == msgFactoryExecuted) {								resolveOnce(childDef.exports);							}						}					}				);			}			function allResolved () {				parentDef.resolve(deps);			}			function allExportsReady () {				parentDef.exportsReady && parentDef.exportsReady(deps);			}		},		fetchResDef: function (def) {			// ensure url is computed			core.getDefUrl(def);			core.loadScript(def,				function () {					var args = argsNet;					argsNet = undef; // reset it before we get deps					// if our resource was not explicitly defined with an id (anonymous)					// Note: if it did have an id, it will be resolved in the define()					if (def.useNet !== false) {						// if !args, nothing was added to the argsNet						if (!args || args.ex) {							def.reject(new Error(((args && args.ex) || 'define() missing or duplicated: ' + def.url)));						}						else {							core.defineResource(def, args);						}					}				},				def.reject			);			return def;		},		fetchDep: function (depName, parentDef) {			var toAbsId, isPreload, parts, mainId, loaderId, pluginId,				resId, pathInfo, def, tempDef, resCfg;			toAbsId = parentDef.toAbsId;			isPreload = parentDef.isPreload;			// check for plugin loaderId			parts = pluginParts(depName);			// resId is not normalized since the plugin may need to do it			resId = parts.resourceId;			// get id of first resource to load (which could be a plugin)			mainId = toAbsId(parts.pluginId || resId);			pathInfo = core.resolvePathInfo(mainId, userCfg, !!parts.pluginId);			// get custom module loader from package config if not a plugin			// TODO: figure out how to make module loaders work with plugins			if (parts.pluginId) {				loaderId = mainId;			}			else {				loaderId = pathInfo.config['moduleLoader'];				if (loaderId) {					// since we're not using toAbsId, transformers must be absolute					resId = mainId;					mainId = loaderId;					pathInfo = core.resolvePathInfo(loaderId, userCfg);				}			}			// find resource definition. ALWAYS check via (id in cache) b/c			// falsey values could be in there.			def = cache[mainId];			if (!(mainId in cache)) {				def = cache[mainId] = core.createResourceDef(pathInfo.config, mainId, isPreload, pathInfo.ctxId);				def.url = core.checkToAddJsExt(pathInfo.url);				core.fetchResDef(def);			}			// plugin or transformer			if (mainId == loaderId) {				// we need to use depName until plugin tells us normalized id.				// if the plugin changes the id, we need to consolidate				// def promises below.  Note: exports objects will be different				// between pre-normalized and post-normalized defs! does this matter?				// don't put this resource def in the cache because if the				// resId doesn't change, the check if this is a new				// normalizedDef (below) will think it's already being loaded.				tempDef = /*cache[depName] =*/ new Promise();				// note: this means moduleLoaders can store config info in the				// plugins config, too.				resCfg = userCfg.plugins[loaderId] || userCfg;				// wait for plugin resource def				when(def, function(plugin) {					var normalizedDef, fullId, dynamic;					dynamic = plugin['dynamic'];					// check if plugin supports the normalize method					if ('normalize' in plugin) {						// dojo/has may return falsey values (0, actually)						resId = plugin['normalize'](resId, toAbsId, resCfg) || '';					}					else {						resId = toAbsId(resId);					}					// use the full id (loaderId + id) to id plugin resources					// so multiple plugins may each process the same resource					// resId could be blank if the plugin doesn't require any (e.g. "domReady!")					fullId = loaderId + '!' + resId;					normalizedDef = cache[fullId];					// if this is our first time fetching this (normalized) def					if (!(fullId in cache)) {						// because we're using resId, plugins, such as wire!,						// can use paths relative to the resource						normalizedDef = core.createPluginDef(resCfg, fullId, isPreload, resId);						// don't cache non-determinate "dynamic" resources (or non-existent resources)						if (!dynamic) {							cache[fullId] = normalizedDef;						}						// curl's plugins prefer to receive a deferred,						// but to be compatible with AMD spec, we have to						// piggy-back on the callback function parameter:						var loaded = function (res) {							normalizedDef.resolve(res);							if (!dynamic) cache[fullId] = res;						};						loaded['resolve'] = loaded;						loaded['reject'] = normalizedDef.reject;						// load the resource!						plugin.load(resId, normalizedDef.require, loaded, resCfg);					}					// chain defs (resolve when plugin.load executes)					if (tempDef != normalizedDef) {						when(normalizedDef, tempDef.resolve, tempDef.reject, tempDef.progress);					}				}, tempDef.reject);			}			// return tempDef if this is a plugin-based resource			return tempDef || def;		},		getCurrentDefName: function () {			// IE marks the currently executing thread as "interactive"			// Note: Opera lies about which scripts are "interactive", so we			// just have to test for it. Opera provides a true browser test, not			// a UA sniff, thankfully.			// learned this trick from James Burke's RequireJS			var def;			if (!isType(global.opera, 'Opera')) {				for (var d in activeScripts) {					if (readyStates[activeScripts[d].readyState] == interactive) {						def = d;						break;					}				}			}			return def;		}	};	// hook-up cjs free variable getters	cjsGetters = {'require': core.getCjsRequire, 'exports': core.getCjsExports, 'module': core.getCjsModule};	function _curl (/* various */) {		var args = [].slice.call(arguments), cfg;		// extract config, if it's specified		if (isType(args[0], 'Object')) {			cfg = args.shift();			userCfg = core.config(cfg, userCfg);			core.checkPreloads(cfg);		}		// thanks to Joop Ringelberg for helping troubleshoot the API		function CurlApi (ids, callback, waitFor) {			var then, ctx;			ctx = core.createContext(userCfg, undef, [].concat(ids));			this['then'] = then = function (resolved, rejected) {				when(ctx,					// return the dependencies as arguments, not an array					function (deps) {						if (resolved) resolved.apply(undef, deps);					},					// just throw if the dev didn't specify an error handler					function (ex) {						if (rejected) rejected(ex); else throw ex;					}				);				return this;			};			this['next'] = function (ids, cb) {				// chain api				return new CurlApi(ids, cb, ctx);			};			if (callback) then(callback);			when(waitFor, function () { core.getDeps(ctx); });		}		return new CurlApi(args[0], args[1]);	}	_curl['version'] = version;	function _define (args) {		var id = args.id;		if (id == undef) {			if (argsNet !== undef) {				argsNet = {ex: 'Multiple anonymous defines in url'};			}			else if (!(id = core.getCurrentDefName())/* intentional assignment */) {				// anonymous define(), defer processing until after script loads				argsNet = args;			}		}		if (id != undef) {			// named define(), it is in the cache if we are loading a dependency			// (could also be a secondary define() appearing in a built file, etc.)			var def = cache[id];			if (!(id in cache)) {				// id is an absolute id in this case, so we can get the config.				// there's no way to allow a named define to fetch dependencies				// in the preload phase since we can't cascade the parent def.				var cfg = core.resolvePathInfo(id, userCfg).config;				def = cache[id] = core.createResourceDef(cfg, id);			}			if (!isPromise(def)) throw new Error('duplicate define: ' + id);			// check if this resource has already been resolved			def.useNet = false;			core.defineResource(def, args);		}	}	// look for pre-existing globals	if (typeof define == 'function') prevDefine = define;	if (typeof userCfg == 'function') {		prevCurl = userCfg;		userCfg = false;	}	// configure first time	userCfg = core.config(userCfg);	core.checkPreloads(userCfg);	// allow curl to be a dependency	cache[curlName] = _curl;	// expose curl core for special plugins and modules	// Note: core overrides will only work in either of two scenarios:	// 1. the files are running un-compressed (Google Closure or Uglify)	// 2. the overriding module was compressed into the same file as curl.js	// Compiling curl and the overriding module separately won't work.	cache['curl/_privileged'] = {		'core': core,		'cache': cache,		'cfg': userCfg,		'_define': _define,		'_curl': _curl,		'Promise': Promise	};}(this.window || global));//${DEBUG}define("Keystone/Storage", function() {    var cookie = {        /**         *@function get         *Description: Gets a cookie from local users computer         *@param k = key / name {String} of cookie         *@return {String} cookie value string         */        get : function(k) {            var c = ' ' + document.cookie, s = c.indexOf(' ' + k + '='), e = s < 0 ? s : c.indexOf(';', s), v = s < 0 ? '' : c.substring(s + 2 + k.length, e < 0 ? c.length : e);            return unescape(v);        },        /**         *@function set         *Description: Sets a cookie on local users computer         *@param k = key / name {String}         *@param v = value {String}         *@param e = expires {Number, Date Object}         *@param p = path {String}         *@param d = domain {String}         */        set : function(k, v, e, p, d) {            var exp = ( typeof (e) == "object" ? e : new Date((new Date().getTime()) + (!e ? 0 : e) * 86400000));            document.cookie = k + "=" + escape(v) + (!!e ? "; expires=" + exp.toGMTString() : "") + "; path=" + (!p ? "/" : p) + "; " + (!!d ? " domain=" + d : " domain=.staples.com");        }    };    return cookie;});define("Keystone/Log", function() {    /* Window logging function */   var log=function(){};    return {        log : log,        warn: log,        error: log    };});define("Keystone/ScoringFactors", ["Keystone/Storage", "Keystone/Log"], function(storage, logger) {    var firstPageView = storage.get("kssFPV") || false;    storage.set("kssFPV", 1);    /* Ensure that we define the first page view state going forward*/   function isBetween(valueToCompare,rangeArray) {       return (rangeArray[0] < valueToCompare) && (valueToCompare <= rangeArray[1]);   }   var configuration = {       plan : {           /* All Possible factors used for calculations */           "calculate" : [ "recency", "visit_frequency_30day", "siteSectionCategory",                            "keyword","siteSectionCategoryFrequency","keywordFrequency","state_constant_weights",                           "contentCategoryFrequency","breakroomUnitsPurchased","eventCheck"                           ],            "segments" : {  /* Segment definitions - created as cookies that are available to T&T */               "categoryModel": function() {                   var ccf=this.contentCategoryFrequency,                       contentCategoryBreakroom=ccf.SVB||0,                       contentCategoryShippingMail=ccf.SVSM||0,                       breakroomUnitsPurchased = this.breakroomUnitsPurchased,                       carts = this.eventCheckFrequency.cart||0,                       frequency = this.visit_frequency_30day||0;                   var scoreCarts=0.5294,                       scoreBreakroom=0.374,                       scoreMailing=-0.0361,                       scoreUnitsBreakroom=0.2509,                       scoreVisitFrequency=-0.3436;                   if(isBetween(carts,[0,1])) {scoreInternalSearch=-0.0201;}                                  if(isBetween(carts,[1,2])) {scoreInternalSearch=-0.869;}                                  if(isBetween(carts,[2,7])) {scoreInternalSearch=-1.3256;}                                  if(carts>7) {scoreInternalSearch=-2.2924;}                                     if(isBetween(contentCategoryBreakroom,[0,4])) {scoreBreakroom=-1.4672;}                                  if(contentCategoryBreakroom>4) {scoreBreakroom=-1.8523;}                                       if(contentCategoryShippingMail>0) {scoreMailing=1.6196;}                                       if(isBetween(breakroomUnitsPurchased,[0,4])) {scoreUnitsBreakroom=-2.3227;}                                  if(breakroomUnitsPurchased>4) {scoreUnitsBreakroom=-3.0458;}                                                     if(isBetween(frequency,[0,1])) {scoreVisitFrequency=-0.3436;}                   if(isBetween(frequency,[1,2])) {scoreVisitFrequency=0.0637;}                   if(isBetween(frequency,[2,6])) {scoreVisitFrequency=0.2548;}                   if(frequency>6) {scoreVisitFrequency=0.2896;}                                                    var x5=2.1+scoreCarts+scoreBreakroom+scoreMailing+scoreUnitsBreakroom+scoreVisitFrequency;                            return  1-(1/(1+Math.exp(-x5)));                  },              "propensityModel": function() {                  var pageViewsInternalSearch = this.siteSectionCategoryFrequency.search,                       pageViewsBasketBuilder = this.siteSectionCategoryFrequency.basket_builder,                       recency = this.recency,                       frequency = this.visit_frequency_30day||0, /* Number of previous visits, not visit number */                       scoreInternalSearch=0.0278,                       scoreBasketBuilder=0.00874,                       scoreRecency=0.0907,                       scoreFrequency=0.24958,                       scoreState=this.state_constant_weights||0.03607;                  /* Internal Search Formula */                  if(pageViewsInternalSearch===0) {scoreInternalSearch=0.119;}                                      if(isBetween(pageViewsInternalSearch,[0,1])) {scoreInternalSearch=-0.0532;}                                      if(isBetween(pageViewsInternalSearch,[1,2])) {scoreInternalSearch=-0.1952;}                                      if(isBetween(pageViewsInternalSearch,[2,5])) {scoreInternalSearch=-0.2791;}                                      if(isBetween(pageViewsInternalSearch,[5,9])) {scoreInternalSearch=-0.387;}                                      if(pageViewsInternalSearch>9) {scoreInternalSearch=-0.4268;}                                    /* Basketbuilder Formula */                  if(pageViewsBasketBuilder===0) {scoreBasketBuilder=0.018;} else {scoreBasketBuilder=-0.7827;}                                     /* Recency */                  if(frequency>1) { /* If they have visited previously, then we can calculate recency - otherwise, it's default */                      if(isBetween(recency,[0,4.5550])) {scoreRecency=-0.5484;}                                          if(isBetween(recency,[4.5550,5.5740])) {scoreRecency=-0.3643;}                                          if(isBetween(recency,[5.5740,6.4920])) {scoreRecency=-0.2824;}                      if(isBetween(recency,[6.4920,7.1500])) {scoreRecency=-0.2592;}                      if(isBetween(recency,[7.1500,14.0000])) {scoreRecency=-0.0081;}                      if(isBetween(recency,[14.0000,19.5800])) {scoreRecency=0.2193;}                      if(isBetween(recency,[19.5800,20.5800])) {scoreRecency=0.3305;}                      if(isBetween(recency,[20.5800,26.7200])) {scoreRecency=0.4125 ;}                      if(isBetween(recency,[26.7200,28.0500])) {scoreRecency=0.6287;}                      if(recency>28.0500) {scoreRecency=0.8541;}                  }                                    /* Frequency */                                 if(frequency===0) {scoreFrequency=1.0592;}                   if(isBetween(frequency,[0,1])) {scoreFrequency=0.7195;}                  if(isBetween(frequency,[1,2])) {scoreFrequency=-0.1773;}                  if(isBetween(frequency,[2,3])) {scoreFrequency=-0.5102;}                  if(isBetween(frequency,[3,4])) {scoreFrequency=-0.5772;}                  if(isBetween(frequency,[4,6])) {scoreFrequency=-0.7078;}                  if(isBetween(frequency,[6,14])) {scoreFrequency=-0.9458;}                  if(frequency>14) {scoreFrequency=-1.134;}                     var x5=3.39+scoreInternalSearch+scoreBasketBuilder+scoreRecency+scoreFrequency+scoreState;                                    return  1-(1/(1+Math.exp(-x5)));                               }           },           "createSegment" : function(segmentName, segmentValue) {               storage.set("TT" + segmentName, segmentValue);           }       },       defaultKeywordLookupArray : {/* An array of all siteSection keywords with accompanying regex lookup patterns for URLs and eVar14 */           "ink" : [/(ink|toner|red|cyan|magenta|yellow|blue|cartridge|drum)/i],           "paper" : [/(paper|glossy)/i],           "printer" : [/printer/i],           "computer" : [/(computer|tablet|software)/i]       },          defaultSiteSectionCategoryLookupArray : {/* An array of all site and siteSection categories with accompanying regex lookup patterns for URLs and eVar14 */           "basket_builder":[/basketbuilder\.staples\.com/i],           "search" : [/StaplesSearch/,/SearchKeyword\=/i] /* ,           "ink" : [/ink.toner/i, /ink.\w+.toner/i],           "paper" : [/paper/i],           "printer" : [/printer/i],           "computer" : [/computer/i, /tablet/i, /software/i] */       },       defaultContentCategoryLookupArray : {           "SVB":        ["adhesives","air quality","beverages","boards","brooms","candles","candy","catering","chairmats","chemicals","coffee","computer cleaners","cords","crowd control","cups","cutlery","de-icers","desserts","dollies","dropped ink","early warning","easels","file folders","first aid","floormats","furniture","gifts for the office","gum","ice melt","kitchen","lamps","lanyards","lubricants","mailroom equipment","mint","napkins","office supplies","padlocks","paint supplies","paper towels","penetrants","personal care","personal protective","plates","plugs","poly bags","rolodex","safety cans","safety supplies","safety tapes","sealants","shredders","snacks","soaps","sorbents","stands","sugar","tables","tape","tissues","trash"],           "SVSM": ["poly bags","shipping tape","shipping boxes","labels","tags","mailroom equipment","mailers","tubes","bubble wrap","stretch wrap","adhesives","envelopes","office supplies","signs","postal scales","retail tags"]       },       defaultEventCheckArray: {           "cart": ["scOpen","scAdd"]       }   };   /*jshint laxcomma:false */       return {        configuration: configuration,        firstPageView : !firstPageView /* If the first page view cookie is defined, we're definately not in a first page view state */    };});define("Keystone/Measure/PageViewsFrequency", ["Keystone/ScoringFactors", "Keystone/Storage"], function(factors, storage) {/*  Functionality to measure frequency */    var pageViewsCurrentVisit = storage.get("kssPVF") || "0";    factors.pageviews_frequency = 1 + parseInt(pageViewsCurrentVisit, 10);    storage.set("kssPVF", factors.pageviews_frequency);    /* Previous visits */});define("Keystone/Measure/VisitFrequency", ["Keystone/ScoringFactors", "Keystone/Storage", "Keystone/Log"], function(factors, storage, logger) {/*  Functionality to measure frequency */        var today = Math.floor((new Date()).getTime() / (1000 * 60 * 60 )), /* Total Number of Hours since Jan 1, 1970 */        lastVisitDate = storage.get("kssLV") || today + "", /* either "today" or the last time a person visited the site, in hours since Jan 1, 1970 */        daysSinceLastVisit = (today - parseInt(lastVisitDate, 10))/24, /* the floating value of days since last visit.  This becomes 'factors.recency' */        storeArray = storage.get("kssVNum"), /* the cookie visit-number array */        default30DayArray=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],        visitNumberStorageArray = (!!storeArray ? _.map(storeArray.split("|"), function(i) {            return parseInt(i, 10);        }) : [0, 0]), rolling30 = storage.get("kss30dV"), rolling30Array = (!!rolling30 ? _.map(rolling30.split("|"), function(i) {            return parseInt(i, 10);        }) : default30DayArray), i = 0;        if (!!factors.firstPageView) {/* If this is the initial page view of visit, then */            /* Update the factors and re-save */            visitNumberStorageArray[0] = visitNumberStorageArray[0] + 1;            if (daysSinceLastVisit>=1) {                if(daysSinceLastVisit>30) {rolling30Array=default30DayArray;}                else {                    for ( i = 0; i < daysSinceLastVisit-1; i++) {                        rolling30Array.splice(0, 0, 0);                    }                }            }             rolling30Array[0]=rolling30Array[0] + 1;            rolling30Array.length=30;            visitNumberStorageArray[1] = _.reduce(rolling30Array, function(s, x) {                return s + x;            }, 0);            /* Serialize all cookies */            storage.set("kssLV", today, 365);            storage.set("kssVNum", visitNumberStorageArray.join("|"), 365);            storage.set("kss30dV", rolling30Array.join("|"), 30);        }        /* Store pertinent information */        factors.recency = daysSinceLastVisit || 0;        factors.visit_frequency = visitNumberStorageArray[0] || 0;        factors.visit_frequency_30day = visitNumberStorageArray[1] || 0;});define("Keystone/Measure/Recency", ["Keystone/ScoringFactors", "Keystone/Storage"], function(factors) {/* Functionality to measure recency */    // factors.recency = 1;    /* Number of days since last visit */    /* Already added as a factor in Keystone/Measure/VisitFrequency module */});define("Keystone/Measure/SiteSectionCategory", ["Keystone/ScoringFactors", "Keystone/Storage","Keystone/Log"], function(factors, storage,logger) {    logger.log("START: Module siteSection Category");    var urlTestString=window.location.href,//window.location.hostname+window.location.pathname,        categoryCookie = storage.get("kssPCP"), /* the cookie that stores the current 14-day category freqency count */        defaultLookupArray = factors.configuration.defaultSiteSectionCategoryLookupArray,/* An array of all siteSection categories with accompanying regex lookup patterns for URLs and eVar14 */        lookupKeys = _.keys(defaultLookupArray), /* Keys from the default lookup array.  Basically, this is a list of siteSection categories */        categoryArray = (!!categoryCookie &&categoryCookie.split("|").length===lookupKeys.length ?             _.map(categoryCookie.split("|"), function(value) {            return parseInt(value, 10);            }) : _.map(lookupKeys, function(v) {            return 0;        })), /* categoryArray contains either the cookie frequency of all siteSection categories visited OR a default array of 0-values for new visitors */        categoryObject = {}, /* Default object that will contain our siteSection category frequency count */        i = 0, /* Standard iterator identifier */        siteSectionCategoriesFound = [];    /* Array that will eventually hold siteSection categories found. */    _.map(lookupKeys, function(key) { /* Build category object from array primatives */        categoryObject[key] = categoryArray[i];        i++;    });    function checkLater(factors, name, checkCriteria, timeToWait, count, me) {        /* Used to check on other values that may not be available at this time and then update the siteSection category accordingly */        if (count >=5) {            return;        }        /*jshint evil:true */        var criteriaExists = eval(checkCriteria);        /*jshint evil:false */        if (!!criteriaExists && _.reduce(defaultLookupArray[name], /* See if it matches the lookup array regexp */        function(result, value) {            logger.log("result="+result+",value="+value);            return result || value.test(criteriaExists);        }, false)) {            factors.siteSectionCategory = _.union(factors.siteSectionCategory, [name]);            factors.siteSectionCategoryFrequency[name]=factors.siteSectionCategoryFrequency[name]+1; /* Increment value of found siteSection category */            storage.set("kssPCP",_.values(factors.siteSectionCategoryFrequency),30); /* Store values found  */        } else {            setTimeout(function() {                me(factors, name, checkCriteria, timeToWait * 2, count + 1, me);            }, timeToWait);        }    }    /* Check URL first */    _.map(lookupKeys, function(key) {        if (_.reduce(defaultLookupArray[key], function(result, regex) {            return result || regex.test(urlTestString);        }, false)) {            categoryObject[key] = categoryObject[key] + 1;        } /* else {            checkLater(factors, key, "(!!window.s?window.s.eVar14:null)", 500, 0, checkLater);        } */        if (categoryObject[key] > 0) {            siteSectionCategoriesFound.push(key);        }    });    /* Store siteSection categories found */    storage.set("kssPCP", _.values(categoryObject).join("|"), 30);    factors.siteSectionCategory = siteSectionCategoriesFound;    factors.siteSectionCategoryFrequency = categoryObject;});define("Keystone/Measure/Keyword", ["Keystone/ScoringFactors", "Keystone/Storage","Keystone/Log"], function(factors,storage,logger) {    var categoryCookie = storage.get("kssPCKP"), /* the cookie that stores the current 14-day category freqency count */    defaultLookupArray = factors.configuration.defaultKeywordLookupArray,/* An array of all siteSection categories with accompanying regex lookup patterns for URLs and eVar14 */    lookupKeys = _.keys(defaultLookupArray), /* Keys from the default lookup array.  Basically, this is a list of siteSection categories */    categoryArray = (!!categoryCookie&&categoryCookie.split("|").length===lookupKeys.length ?         _.map(categoryCookie.split("|"), function(value) {            return parseInt(value, 10);        })         : _.map(lookupKeys, function(v) {        return 0;    })), /* categoryArray contains either the cookie frequency of all siteSection categories visited OR a default array of 0-values for new visitors */    categoryObject = {}, /* Default object that will contain our siteSection category frequency count */    i = 0, /* Standard iterator identifier */    siteSectionCategoriesFound = [];    /* Array that will eventually hold siteSection categories found. */    _.map(lookupKeys, function(key) { /* Build category object from array primatives */        categoryObject[key] = categoryArray[i];        i++;    });    /* Check URL first */    _.map(lookupKeys, function(key) {        if (_.reduce(defaultLookupArray[key], function(result, regex) {            var refSearchArray=document.referrer.split("?"),                refQuery=refSearchArray.length>1?refSearchArray[1]:"";            return result || regex.test(window.location.search) || regex.test(refQuery.replace(/\W+/g," "));        }, false)) {            categoryObject[key] = categoryObject[key] + 1;        }         if (categoryObject[key] > 0) {            siteSectionCategoriesFound.push(key);        }    });    /* Store siteSection categories found */    storage.set("kssPCKP", _.values(categoryObject).join("|"), 30);    factors.keyword = siteSectionCategoriesFound;    factors.keywordFrequency = categoryObject;});define("Keystone/Measure/StateZipWeightings",        ["Keystone/ScoringFactors", "Keystone/Storage","Keystone/Log"],    function(factors,storage,logger) {        var zip=storage.get("zipcode"),        stateFactorConstants={"AK":0.7502,"AL":-0.2973,"AR":0.0169,"AS":0.7502,"AZ":0.0169,"CA":-0.0407,"CO":0.1199,"CT":-0.2973,"DC":-0.2973,"DE":0.7502,"FL":0.047,"GA":0.047,"HI":0.7502,"IA":-0.2973,"ID":-0.2973,"IL":0.1199,"IN":0.047,"KS":-0.2973,"KY":-0.2973,"LA":-0.1703,"MA":-0.0407,"MD":-0.1703,"ME":-0.2973,"MH":0.7502,"MI":0.047,"MN":0.7502,"MO":-0.111,"MP":0.7502,"MS":0.7502,"MT":-0.2973,"NC":0.047,"ND":0.0169,"NE":0.7502,"NH":0.0169,"NJ":-0.111,"NM":0.7502,"NV":0.7502,"NY":-0.0407,"OH":0.0169,"OK":-0.0407,"OR":-0.111,"PA":-0.111,"PR":0.7502,"RI":0.0169,"SC":0.047,"SD":-0.2973,"TN":0.1199,"TX":0.047,"UT":-0.1344,"VA":-0.1703,"VI":0.7502,"VT":-0.2973,"WA":0.7502,"WI":-0.0407,"WV":-0.2973,"WY":-0.2973},        otherStateFactor=0.7502, /* State is defined, but it isnt' explicitly called out in our list of state factors */        undefinedStateFactor=0.0169; /* State was not defined - therefore, we use an undefined factor instead */    function parseStateFromZipcode(zip) {        var zipFirstThreeDigits=zip.substr(0,3), zipFirstTwoDigits=zip.substr(0,2);        /* Note: there is one 3-character zip code shared by Conneticut and NY, and I'm assigning to NY Just because */        var zip2ExactLookup={"01":"MA","04":"ME","07":"NJ","08":"NJ","10":"NY","11":"NY","12":"NY","13":"NY","14":"NY","15":"PA","16":"PA","17":"PA","18":"PA","21":"MD","22":"VA","23":"VA","25":"WV","26":"WV","27":"NC","28":"NC","29":"SC","30":"GA","31":"GA","32":"FL","33":"FL","34":"FL","35":"AL","36":"AL","37":"TN","40":"KY","41":"KY","42":"KY","43":"OH","44":"OH","45":"OH","46":"IN","47":"IN","48":"MI","49":"MI","50":"IA","51":"IA","52":"IA","53":"WI","54":"WI","55":"MN","56":"MN","57":"SD","58":"ND","59":"MT","60":"IL","61":"IL","62":"IL","63":"MO","64":"MO","65":"MO","66":"KS","67":"KS","68":"NE","69":"NE","70":"LA","72":"AR","74":"OK","75":"TX","76":"TX","77":"TX","78":"TX","79":"TX","80":"CO","81":"CO","82":"WY","84":"UT","85":"AZ","86":"AZ","87":"NM","89":"NV","90":"CA","91":"CA","92":"CA","93":"CA","94":"CA","95":"CA","97":"OR","98":"WA"};        var zip3ExactLookup={"002":"NH","005":"NY","020":"MA","021":"MA","022":"MA","023":"MA","024":"MA","025":"MA","026":"MA","027":"MA","028":"RI","029":"RI","030":"NH","031":"NH","032":"NH","033":"NH","034":"NH","035":"NH","036":"NH","037":"NH","038":"NH","039":"ME","050":"VT","051":"VT","052":"VT","053":"VT","054":"VT","055":"MA","056":"VT","057":"VT","058":"VT","059":"VT","060":"CT","061":"CT","062":"CT","063":"NY","064":"CT","065":"CT","066":"CT","067":"CT","068":"CT","069":"CT","190":"PA","191":"PA","192":"PA","193":"PA","194":"PA","195":"PA","196":"PA","197":"DE","198":"DE","199":"DE","201":"VA","240":"VA","241":"VA","242":"VA","243":"VA","244":"VA","245":"VA","246":"VA","247":"WV","248":"WV","249":"WV","380":"TN","381":"TN","382":"TN","383":"TN","384":"TN","385":"TN","386":"MS","387":"MS","388":"MS","389":"MS","390":"MS","391":"MS","392":"MS","393":"MS","394":"MS","395":"MS","396":"MS","397":"MS","399":"GA","710":"LA","711":"LA","712":"LA","713":"LA","714":"LA","716":"AR","717":"AR","718":"AR","719":"AR","730":"OK","731":"OK","733":"TX","734":"OK","735":"OK","736":"OK","737":"OK","738":"OK","739":"OK","830":"WY","831":"WY","832":"ID","833":"ID","834":"ID","835":"ID","836":"ID","837":"ID","838":"ID","880":"NM","881":"NM","882":"NM","883":"NM","884":"NM","885":"TX","889":"NV","960":"CA","961":"CA","967":"HI","968":"HI","990":"WA","991":"WA","992":"WA","993":"WA","994":"WA","995":"AK","996":"AK","997":"AK","998":"AK","999":"AK"};        return zip2ExactLookup[zipFirstTwoDigits]||zip3ExactLookup[zipFirstThreeDigits];    }        factors.state=parseStateFromZipcode(zip);    factors.state_constant_weights=undefinedStateFactor;    if(!!factors.state) { factors.state_constant_weights=stateFactorConstants[factors.state]||otherStateFactor;}});define(    "Keystone/Measure/LatentLookup", ["Keystone/ScoringFactors", "Keystone/Storage", "Keystone/Log"], function(factors, storage, logger) {    function checkLaterCallback(stopWaitingCriteria, timeToWait, count, me, callback,maxcount) {        maxcount=maxcount||5;        if (count >= maxcount) {            return;        }        /*jshint evil:true */        var criteriaExists = eval(stopWaitingCriteria);        /*jshint evil:false */        if (!!criteriaExists) {            if (typeof(callback) == "function") {                callback();            }        } else {            setTimeout(function() {                me(stopWaitingCriteria, maxcount>10?5000:timeToWait * 2, count + 1, me, callback,maxcount);            }, timeToWait);        }    }    function checkLater(factorName, factorValueName, stopWaitingCriteria, valuesToTest, cookieName, cookieDuration, timeToWait, count, me, callback, maxcount) {                /* Used to check on other values that may not be available at this time and then update the siteSection category accordingly */        maxcount=maxcount||5;        if (count >= maxcount) {            return;        }        /*jshint evil:true */        var criteriaExists = eval(stopWaitingCriteria);        /*jshint evil:false */        if (!!criteriaExists && _.reduce(valuesToTest, /* See if it matches the value to test array */        function(result, value) {            value=value.toLowerCase();            logger.log("result=" + result + ",value=" + value);            criteriaExists = criteriaExists.replace(/\s+/, " ").toLowerCase().replace(/^\s+/, "").replace(/\s+$/, "");            return result || (!!value.test ? value.test(criteriaExists) : criteriaExists.indexOf(value) != -1);        }, false)) {            /* Assume we set the factor unless there's a callback.  If there's a callback, then execute that,              * and if it returns true, then we set the factor / increment the factor frequency.  Otherwise,             * we do nothing.             */            var setFactor = typeof (callBack) == "function" ? callback(factorValueName) : true;            if (!!setFactor) {                factors[factorName] = _.union(factors[factorName], [factorValueName]);                factors[factorName+"Frequency"][factorValueName] = (factors[factorName+"Frequency"][factorValueName] || 0) + 1;                /* Increment value of found siteSection category */                storage.set(cookieName, JSON.stringify(factors[factorName]), cookieDuration);                /* Store values found  */                storage.set(cookieName + "F", JSON.stringify(factors[factorName + "Frequency"]), cookieDuration);                /* Store values found  */            }        } else {            setTimeout(function() {                me(factorName, factorValueName, stopWaitingCriteria, valuesToTest, cookieName, cookieDuration, maxcount>10?5000:timeToWait * 2, count + 1, me,callback,maxcount);            }, timeToWait);        }    }    return { checkLater: checkLater, checkLaterCallback: checkLaterCallback};}); curl(    ["Keystone/ScoringFactors","Keystone/Measure/LatentLookup","Keystone/Storage"],    function(factors,latentLookup,storage) {    /* Load initial factors from cookie */    factors.contentCategory = JSON.parse(storage.get("kssCCP") || "[]");    factors.contentCategoryFrequency = JSON.parse(storage.get("kssCCP" + "F") || "{}");    factors.eventCheck = JSON.parse(storage.get("kssEP") || "[]");    factors.eventCheckFrequency = JSON.parse(storage.get("kssEP" + "F") || "{}");    factors.breakroomUnitsPurchased=storage.get("kssBRPP")||0;    /* Callback used to identify when we find sku pages - further verifies that the page is part of a prodView event - or a sku view */    function onFoundCriteriaSkupageCheck(factorValueName) {        /* Only set the factor IF we're on a sku page (prodview event) */        if (!!window.s.events && window.s.events.indexOf("prodView") !== -1) {             storage.set(cookieName + "F", JSON.stringify(factors[factorName + "Frequency"]), cookieDuration);            if (factorValueName == "SVB" && !!s.products) {                storage.set("kssBRP", (storage.get("kssBRP") || "") + s.products.toLowerCase().replace(/\s+/," "), 30);            }            return true;        }    }    _.map(factors.configuration.defaultContentCategoryLookupArray, function(value, key) {        latentLookup.checkLater("contentCategory", key, "(!!window.s?window.s.prop6:null)", value, "kssCCP", 30, 600, 0, latentLookup.checkLater, onFoundCriteriaSkupageCheck);    });    _.map(factors.configuration.defaultEventCheckArray, function(value, key) {        latentLookup.checkLater("eventCheck", key, "(!!window.s?window.s.events:null)", value, "kssEP", 1, 5000, 0, latentLookup.checkLater,null,90);    });    /* Callback to determine if a purchase event has occured and to capture the number of units purchased if this is a breakroom product */    function onPurchase() {        productsBreakroom = storage.get("kssBRP");        factors.breakroomUnitsPurchased = _.reduce(s.products.split(","), function(memo, lineItems) {            var prodLineItem = lineItems.split(";");            if (prodLineItem.length > 2) {                /* If prodlineItem matches, then we add the number of units purchased to the total units purchased thus far */                memo = memo + (productsBreakroom.indexOf(prodLineItem[1].toLowerCase().replace(/\s+/," ")) != -1 ? parseInt(prodLineItem[2], 10) : 0);            }            return memo;        }, parseInt(storage.get("kssBRPP") || "", 10));        storage.set("kssBRPP", factors.breakroomUnitsPurchased, 30);    }    latentLookup.checkLaterCallback("(!!window.s&&window.s.events&&window.s.events.indexOf('purchase')!==-1?true:null)", 200, 0, latentLookup.checkLaterCallback, onPurchase,10);});define("Keystone/ScoringEngine", /* Scoring Engine Main Logic */["Keystone/Log", "Keystone/ScoringFactors", "Keystone/Measure/VisitFrequency",  "Keystone/Measure/PageViewsFrequency", "Keystone/Measure/Recency",  "Keystone/Measure/Keyword", "Keystone/Measure/SiteSectionCategory"], function(consoleLog, scoringFactors) {    var log = consoleLog.log;    this.version="0.5.0";    function pubDoScore() {        /* Replicate plan object over to the scoringFactors module */        scoringFactors.plan = scoringFactors.configuration.plan;        function createEvalFunction(functionToMod) {            _.map(scoringFactors.plan.calculate, function(eachVariable) {                var regexReplaceVariable = (new RegExp("(" + eachVariable + ")", "g"));                functionToMod = functionToMod.replace(regexReplaceVariable, "this." + eachVariable);            });            return functionToMod;        }        _.map(scoringFactors.plan.segments, _.bind(function(value, key, list) {            var f = value;            /* Assume this is a function */            if ( typeof (value) == "string") {                /*jshint evil:true */                f = _.bind(createEvalFunction,this)(value);                f = new Function(f);                /*jshint evil:false */            }            try {                list[key] = _.bind(f, scoringFactors);                /* Bind function to the scoring factors object that contains actual factors */            } catch(e) {            }            results = list[key]();            scoringFactors.plan.createSegment(key, results);        }, this));    }    return {        version: version,        doScore : pubDoScore    };});curl(["Keystone/ScoringEngine","Keystone/Log","Keystone/Storage"],    function(scoringEngine,logger,storage) {}).then(    function(scoringEngine) {        scoringEngine.doScore();     },    function(ex) {     });/* Base mbox.js file used by Staples */var mboxCopyright = "Copyright 1996-2011. Adobe Systems Incorporated. All rights reserved.";mboxUrlBuilder = function (a, b) {    this.a = a;    this.b = b;    this.c = new Array();    this.d = function (e) {        return e;    };    this.f = null;};mboxUrlBuilder.prototype.addParameter = function (g, h) {    var i = new RegExp('(\'|")');    if (i.exec(g)) {        throw "Parameter '" + g + "' contains invalid characters";    }    for (var j = 0; j < this.c.length; j++) {        var k = this.c[j];        if (k.name == g) {            k.value = h;            return this;        }    }    var l = new Object();    l.name = g;    l.value = h;    this.c[this.c.length] = l;    return this;};mboxUrlBuilder.prototype.addParameters = function (c) {    if (!c) {        return this;    }    for (var j = 0; j < c.length; j++) {        var m = c[j].indexOf('=');        if (m == -1 || m == 0) {            continue;        }        this.addParameter(c[j].substring(0, m), c[j].substring(m + 1, c[j].length));    }    return this;};mboxUrlBuilder.prototype.setServerType = function (n) {    this.o = n;};mboxUrlBuilder.prototype.setBasePath = function (f) {    this.f = f;};mboxUrlBuilder.prototype.setUrlProcessAction = function (p) {    this.d = p;};mboxUrlBuilder.prototype.buildUrl = function () {    var q = this.f ? this.f : '/m2/' + this.b + '/mbox/' + this.o;    var r = document.location.protocol == 'file:' ? 'http:' : document.location.protocol;    var e = r + "//" + this.a + q;    var s = e.indexOf('?') != -1 ? '&' : '?';    for (var j = 0; j < this.c.length; j++) {        var k = this.c[j];        e += s + encodeURIComponent(k.name) + '=' + encodeURIComponent(k.value);        s = '&';    }    return this.t(this.d(e));};mboxUrlBuilder.prototype.getParameters = function () {    return this.c;};mboxUrlBuilder.prototype.setParameters = function (c) {    this.c = c;};mboxUrlBuilder.prototype.clone = function () {    var u = new mboxUrlBuilder(this.a, this.b);    u.setServerType(this.o);    u.setBasePath(this.f);    u.setUrlProcessAction(this.d);    for (var j = 0; j < this.c.length; j++) {        u.addParameter(this.c[j].name, this.c[j].value);    }    return u;};mboxUrlBuilder.prototype.t = function (v) {    return v.replace(/\"/g, '&quot;').replace(/>/g, '&gt;');};mboxStandardFetcher = function () {};mboxStandardFetcher.prototype.getType = function () {    return 'standard';};mboxStandardFetcher.prototype.fetch = function (w) {    w.setServerType(this.getType());    document.write('<' + 'scr' + 'ipt src="' + w.buildUrl() + '" language="JavaScript"><' + '\/scr' + 'ipt>');};mboxStandardFetcher.prototype.cancel = function () {};mboxAjaxFetcher = function () {};mboxAjaxFetcher.prototype.getType = function () {    return 'ajax';};mboxAjaxFetcher.prototype.fetch = function (w) {    w.setServerType(this.getType());    var e = w.buildUrl();    this.x = document.createElement('script');    this.x.src = e;    document.body.appendChild(this.x);};mboxAjaxFetcher.prototype.cancel = function () {};mboxMap = function () {    this.y = new Object();    this.z = new Array();};mboxMap.prototype.put = function (A, h) {    if (!this.y[A]) {        this.z[this.z.length] = A;    }    this.y[A] = h;};mboxMap.prototype.get = function (A) {    return this.y[A];};mboxMap.prototype.remove = function (A) {    this.y[A] = undefined;};mboxMap.prototype.each = function (p) {    for (var j = 0; j < this.z.length; j++) {        var A = this.z[j];        var h = this.y[A];        if (h) {            var B = p(A, h);            if (B === false) {                break;            }        }    }};mboxFactory = function (C, b, D) {    this.E = false;    this.C = C;    this.D = D;    this.F = new mboxList();    mboxFactories.put(D, this);    this.G = typeof document.createElement('div').replaceChild != 'undefined' && (function () {        return true;    })() && typeof document.getElementById != 'undefined' && typeof (window.attachEvent || document.addEventListener || window.addEventListener) != 'undefined' && typeof encodeURIComponent != 'undefined';    this.H = this.G && mboxGetPageParameter('mboxDisable') == null;    var I = D == 'default';    this.J = new mboxCookieManager('mbox' + (I ? '' : ('-' + D)), (function () {        return mboxCookiePageDomain();    })());    this.H = this.H && this.J.isEnabled() && (this.J.getCookie('disable') == null);    if (this.isAdmin()) {        this.enable();    }    this.K();    this.L = mboxGenerateId();    this.M = mboxScreenHeight();    this.N = mboxScreenWidth();    this.O = mboxBrowserWidth();    this.P = mboxBrowserHeight();    this.Q = mboxScreenColorDepth();    this.R = mboxBrowserTimeOffset();    this.S = new mboxSession(this.L, 'mboxSession', 'session', 31 * 60, this.J);    this.T = new mboxPC('PC', 1209600, this.J);    this.w = new mboxUrlBuilder(C, b);    this.U(this.w, I);    this.V = new Date().getTime();    this.W = this.V;    var X = this;    this.addOnLoad(function () {        X.W = new Date().getTime();    });    if (this.G) {        this.addOnLoad(function () {            X.E = true;            X.getMboxes().each(function (Y) {                Y.setFetcher(new mboxAjaxFetcher());                Y.finalize();            });        });        this.limitTraffic(100, 10368000);        if (this.H) {            this.Z();            this._ = new mboxSignaler(function (ab, c) {                return X.create(ab, c);            }, this.J);        }    }};mboxFactory.prototype.isEnabled = function () {    return this.H;};mboxFactory.prototype.getDisableReason = function () {    return this.J.getCookie('disable');};mboxFactory.prototype.isSupported = function () {    return this.G;};mboxFactory.prototype.disable = function (bb, cb) {    if (typeof bb == 'undefined') {        bb = 60 * 60;    }    if (typeof cb == 'undefined') {        cb = 'unspecified';    }    if (!this.isAdmin()) {        this.H = false;        this.J.setCookie('disable', cb, bb);    }};mboxFactory.prototype.enable = function () {    this.H = true;    this.J.deleteCookie('disable');};mboxFactory.prototype.isAdmin = function () {    return document.location.href.indexOf('mboxEnv') != -1;};mboxFactory.prototype.limitTraffic = function (db, bb) {};mboxFactory.prototype.addOnLoad = function (eb) {    if (this.isDomLoaded()) {        eb();    } else {        var fb = false;        var gb = function () {                if (fb) {                    return;                }                fb = true;                eb();            };        this.hb.push(gb);        if (this.isDomLoaded() && !fb) {            gb();        }    }};mboxFactory.prototype.getEllapsedTime = function () {    return this.W - this.V;};mboxFactory.prototype.getEllapsedTimeUntil = function (ib) {    return ib - this.V;};mboxFactory.prototype.getMboxes = function () {    return this.F;};mboxFactory.prototype.get = function (ab, jb) {    return this.F.get(ab).getById(jb || 0);};mboxFactory.prototype.update = function (ab, c) {    if (!this.isEnabled()) {        return;    }    if (!this.isDomLoaded()) {        var X = this;        this.addOnLoad(function () {            X.update(ab, c);        });        return;    }    if (this.F.get(ab).length() == 0) {        throw "Mbox " + ab + " is not defined";    }    this.F.get(ab).each(function (Y) {        Y.getUrlBuilder().addParameter('mboxPage', mboxGenerateId());        Y.load(c);    });};mboxFactory.prototype.create = function (ab, c, kb) {    if (!this.isSupported()) {        return null;    }    var e = this.w.clone();    e.addParameter('mboxCount', this.F.length() + 1);    e.addParameters(c);    var jb = this.F.get(ab).length();    var lb = this.D + '-' + ab + '-' + jb;    var mb;    if (kb) {        mb = new mboxLocatorNode(kb);    } else {        if (this.E) {            throw 'The page has already been loaded, can\'t write marker';        }        mb = new mboxLocatorDefault(lb);    }    try {        var X = this;        var nb = 'mboxImported-' + lb;        var Y = new mbox(ab, jb, e, mb, nb);        if (this.H) {            Y.setFetcher(this.E ? new mboxAjaxFetcher() : new mboxStandardFetcher());        }        Y.setOnError(function (ob, n) {            Y.setMessage(ob);            Y.activate();            if (!Y.isActivated()) {                X.disable(60 * 60, ob);                window.location.reload(false);            }        });        this.F.add(Y);    } catch (pb) {        this.disable();        throw 'Failed creating mbox "' + ab + '", the error was: ' + pb;    }    var qb = new Date();    e.addParameter('mboxTime', qb.getTime() - (qb.getTimezoneOffset() * 60000));    return Y;};mboxFactory.prototype.getCookieManager = function () {    return this.J;};mboxFactory.prototype.getPageId = function () {    return this.L;};mboxFactory.prototype.getPCId = function () {    return this.T;};mboxFactory.prototype.getSessionId = function () {    return this.S;};mboxFactory.prototype.getSignaler = function () {    return this._;};mboxFactory.prototype.getUrlBuilder = function () {    return this.w;};mboxFactory.prototype.getRawCookieVal = function (c_name) {    var i,x,y,ARRcookies=document.cookie.split(";");    for (i=0;i<ARRcookies.length;i++){      x=ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));      y=ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);      x=x.replace(/^\s+|\s+$/g,"");      if (x==c_name){        return unescape(y);      }    }    return "";};mboxFactory.prototype.U = function (e, I) {    e.addParameter('mboxHost', document.location.hostname).addParameter('mboxSession', this.S.getId());    if (!I) {        e.addParameter('mboxFactoryId', this.D);    }    if (this.T.getId() != null) {        e.addParameter('mboxPC', this.T.getId());    }    e.addParameter('mboxPage', this.L);    e.addParameter('screenHeight', this.M);    e.addParameter('screenWidth', this.N);    e.addParameter('browserWidth', this.O);    e.addParameter('browserHeight', this.P);    e.addParameter('browserTimeOffset', this.R);    e.addParameter('colorDepth', this.Q);    e.addParameters(this.rb().split('&'));    e.addParameter('zipcode', this.getRawCookieVal('zipcode'));    /*get Staples Cart cookie value*/    if(this.getRawCookieVal('StaplesCart')){        var cart = this.getRawCookieVal('StaplesCart');        cart = cart.split(';');        e.addParameter('cartID', cart[0]);         e.addParameter('cartNumItems', cart[1]);        e.addParameter('cartValue', cart[2]);    }	/* get Staples Unidentified visitor model scores */	var modelPropensity=this.getRawCookieVal('TTpropensityModel'),		modelCategory = this.getRawCookieVal('TTcategoryModel'),		modelScoreOthers = this.getRawCookieVal('TTscoreModel');    if(modelPropensity){ 		e.addParameter('propensityScoringModel', parseFloat(modelPropensity));	}	if(modelCategory) {		e.addParameter('categoryScoringModel', parseFloat(modelCategory));	}	if(modelScoreOthers) {		var i,modelList=modelScoreOthers.split("|");		for(i=0;i<modelList;i++) {			e.addParameter('generalScoringModel'+(i+1),parseFloat(modelList[i]));		}	}    e.setUrlProcessAction(function (e) {        e += '&mboxURL=' + encodeURIComponent(document.location);        var sb = encodeURIComponent(document.referrer);        if (e.length + sb.length < 2000) {            e += '&mboxReferrer=' + sb;        }        e += '&mboxVersion=' + mboxVersion;        return e;    });};mboxFactory.prototype.rb = function () {    function getTNTCookieParam(cName, cVal) {        var d = unescape(function (d) {            var a, c, e, b = document.cookie.split(";");            for (a = 0; a < b.length; a++) if (c = b[a].substr(0, b[a].indexOf("=")), e = b[a].substr(b[a].indexOf("=") + 1), c = c.replace(/^\s+|\s+$/g, ""), c == d) return unescape(e)        }(cName));        return d.indexOf(cVal + ':"') > -1 ? d.split(cVal + ':"')[1].split('"')[0] : ""    };    var CTclub = unescape(getTNTCookieParam("customerTier", "HPClub")),        CTtier = unescape(getTNTCookieParam("customerTier", "tier")),        CTcbp = unescape(getTNTCookieParam("customerTier", "cbp")),        CSbusiness = unescape(getTNTCookieParam("CustomerSegment", "business")),        CSempRange = unescape(getTNTCookieParam("CustomerSegment", "empRange")),        CSmsvid1 = unescape(getTNTCookieParam("CustomerSegment", "msv_id1")),        CSmsvid2 = unescape(getTNTCookieParam("CustomerSegment", "msv_id2")),        CSmsvid3 = unescape(getTNTCookieParam("CustomerSegment",        "msv_id3")),        CSmsvid4 = unescape(getTNTCookieParam("CustomerSegment", "msv_id4")),        CSmsvid5 = unescape(getTNTCookieParam("CustomerSegment", "msv_id5")),        CSmsvid6 = unescape(getTNTCookieParam("CustomerSegment", "msv_id6")),        CSmsvid7 = unescape(getTNTCookieParam("CustomerSegment", "msv_id7")),        CSmsvid8 = unescape(getTNTCookieParam("CustomerSegment", "msv_id8")),        CSmsvid9 = unescape(getTNTCookieParam("CustomerSegment", "msv_id9")),        CSmsvid10 = unescape(getTNTCookieParam("CustomerSegment", "msv_id10")),        CScopyPaperstr = unescape(getTNTCookieParam("CustomerSegment",        "CopyPaper")),        CScopyPaperval = CScopyPaperstr.split("|"),        CSinkstr = unescape(getTNTCookieParam("CustomerSegment", "Ink")),        CSinkval = CSinkstr.split("|"),        CStonerstr = unescape(getTNTCookieParam("CustomerSegment", "Toner")),        CStonerval = CStonerstr.split("|"),        CScleaningandBreakroomstr = unescape(getTNTCookieParam("CustomerSegment", "CleaningandBreakroom")),        CScleaningandBreakroomval = CScleaningandBreakroomstr.split("|"),        CStechnologystr = unescape(getTNTCookieParam("CustomerSegment", "Technology")),        CStechnologyval = CStechnologystr.split("|"),        CSfurniturestr = unescape(getTNTCookieParam("CustomerSegment", "Furniture")),        CSfurnitureval = CSfurniturestr.split("|"),        CScomputersstr = unescape(getTNTCookieParam("CustomerSegment", "Computers")),        CScomputersval = CScomputersstr.split("|"),        CScpcstr = unescape(getTNTCookieParam("CustomerSegment", "CPC")),        CScpcval = CScpcstr.split("|"),        CSmailandShipstr = unescape(getTNTCookieParam("CustomerSegment", "MailandShip")),        CSmailandShipval = CSmailandShipstr.split("|"),        CSotherSuppliesstr = unescape(getTNTCookieParam("CustomerSegment",        "OtherSupplies")),        CSotherSuppliesval = CSotherSuppliesstr.split("|"),        CSothersstr = unescape(getTNTCookieParam("CustomerSegment", "Others")),        CSothersval = CSothersstr.split("|");    return "tier=" + CTtier + "&club=" + CTclub + "&cbp=" + CTcbp + "&business=" + CSbusiness + "&emprange=" + CSempRange + "&msv_id1=" + CSmsvid1 + "&msv_id2=" + CSmsvid2 + "&msv_id3=" + CSmsvid3 + "&msv_id4=" + CSmsvid4 + "&msv_id5=" + CSmsvid5 + "&msv_id6=" + CSmsvid6 + "&msv_id7=" + CSmsvid7 + "&msv_id8=" + CSmsvid8 + "&msv_id9=" + CSmsvid9 + "&msv_id10=" + CSmsvid10 + "&copypaper_sow=" + CScopyPaperval[0] + "&copypaper_pc=" + CScopyPaperval[1] + "&ink_sow=" + CSinkval[0] + "&ink_pc=" + CSinkval[1] + "&toner_sow=" + CStonerval[0] + "&toner_pc=" + CStonerval[1] + "&cleaningandbreakroom_sow=" + CScleaningandBreakroomval[0] + "&cleaningandbreakroom_pc=" + CScleaningandBreakroomval[1] + "&technology_sow=" + CStechnologyval[0] + "&technology_pc=" + CStechnologyval[1] + "&furniture_sow=" + CSfurnitureval[0] + "&furniture_pc=" + CSfurnitureval[1] + "&computers_sow=" + CScomputersval[0] + "&computers_pc=" + CScomputersval[1] + "&cpc_sow=" + CScpcval[0] + "&cpc_pc=" + CScpcval[1] + "&mailandship_sow=" + CSmailandShipval[0] + "&mailandship_pc=" + CSmailandShipval[1] + "&othersupplies_sow=" + CSotherSuppliesval[0] + "&othersupplies_pc=" + CSotherSuppliesval[1] + "&others_sow=" + CSothersval[0] + "&others_pc=" + CSothersval[1];};mboxFactory.prototype.Z = function () {    document.write('<style>.' + 'mboxDefault' + ' { visibility:hidden; }</style>');};mboxFactory.prototype.isDomLoaded = function () {    return this.E;};mboxFactory.prototype.K = function () {    if (this.hb != null) {        return;    }    this.hb = new Array();    var X = this;    (function () {        var tb = document.addEventListener ? "DOMContentLoaded" : "onreadystatechange";        var ub = false;        var vb = function () {                if (ub) {                    return;                }                ub = true;                for (var i = 0; i < X.hb.length; ++i) {                    X.hb[i]();                }            };        if (document.addEventListener) {            document.addEventListener(tb, function () {                document.removeEventListener(tb, arguments.callee, false);                vb();            }, false);            window.addEventListener("load", function () {                document.removeEventListener("load", arguments.callee, false);                vb();            }, false);        } else if (document.attachEvent) {            if (self !== self.top) {                document.attachEvent(tb, function () {                    if (document.readyState === 'complete') {                        document.detachEvent(tb, arguments.callee);                        vb();                    }                });            } else {                var wb = function () {                        try {                            document.documentElement.doScroll('left');                            vb();                        } catch (xb) {                            setTimeout(wb, 13);                        }                    };                wb();            }        }        if (document.readyState === "complete") {            vb();        }    })();};mboxSignaler = function (yb, J) {    this.J = J;    var zb = J.getCookieNames('signal-');    for (var j = 0; j < zb.length; j++) {        var Ab = zb[j];        var Bb = J.getCookie(Ab).split('&');        var Y = yb(Bb[0], Bb);        Y.load();        J.deleteCookie(Ab);    }};mboxSignaler.prototype.signal = function (Cb, ab) {    this.J.setCookie('signal-' + Cb, mboxShiftArray(arguments).join('&'), 45 * 60);};mboxList = function () {    this.F = new Array();};mboxList.prototype.add = function (Y) {    if (Y != null) {        this.F[this.F.length] = Y;    }};mboxList.prototype.get = function (ab) {    var B = new mboxList();    for (var j = 0; j < this.F.length; j++) {        var Y = this.F[j];        if (Y.getName() == ab) {            B.add(Y);        }    }    return B;};mboxList.prototype.getById = function (Db) {    return this.F[Db];};mboxList.prototype.length = function () {    return this.F.length;};mboxList.prototype.each = function (p) {    if (typeof p != 'function') {        throw 'Action must be a function, was: ' + typeof (p);    }    for (var j = 0; j < this.F.length; j++) {        p(this.F[j]);    }};mboxLocatorDefault = function (g) {    this.g = 'mboxMarker-' + g;    document.write('<div id="' + this.g + '" style="visibility:hidden;display:none">&nbsp;</div>');};mboxLocatorDefault.prototype.locate = function () {    var Eb = document.getElementById(this.g);    while (Eb != null) {        if (Eb.nodeType == 1) {            if (Eb.className == 'mboxDefault') {                return Eb;            }        }        Eb = Eb.previousSibling;    }    return null;};mboxLocatorDefault.prototype.force = function () {    var Fb = document.createElement('div');    Fb.className = 'mboxDefault';    var Gb = document.getElementById(this.g);    Gb.parentNode.insertBefore(Fb, Gb);    return Fb;};mboxLocatorNode = function (Hb) {    this.Eb = Hb;};mboxLocatorNode.prototype.locate = function () {    return typeof this.Eb == 'string' ? document.getElementById(this.Eb) : this.Eb;};mboxLocatorNode.prototype.force = function () {    return null;};mboxCreate = function (ab) {    var Y = mboxFactoryDefault.create(ab, mboxShiftArray(arguments));    if (Y) {        Y.load();    }    return Y;};mboxDefine = function (kb, ab) {    var Y = mboxFactoryDefault.create(ab, mboxShiftArray(mboxShiftArray(arguments)), kb);    return Y;};mboxUpdate = function (ab) {    mboxFactoryDefault.update(ab, mboxShiftArray(arguments));};mbox = function (g, Ib, w, Jb, nb) {    this.Kb = null;    this.Lb = 0;    this.mb = Jb;    this.nb = nb;    this.Mb = null;    this.Nb = new mboxOfferContent();    this.Fb = null;    this.w = w;    this.message = '';    this.Ob = new Object();    this.Pb = 0;    this.Ib = Ib;    this.g = g;    this.Qb();    w.addParameter('mbox', g).addParameter('mboxId', Ib);    this.Rb = function () {};    this.Sb = function () {};    this.Tb = null;};mbox.prototype.getId = function () {    return this.Ib;};mbox.prototype.Qb = function () {    if (this.g.length > 250) {        throw "Mbox Name " + this.g + " exceeds max length of " + "250 characters.";    } else if (this.g.match(/^\s+|\s+$/g)) {        throw "Mbox Name " + this.g + " has leading/trailing whitespace(s).";    }};mbox.prototype.getName = function () {    return this.g;};mbox.prototype.getParameters = function () {    var c = this.w.getParameters();    var B = new Array();    for (var j = 0; j < c.length; j++) {        if (c[j].name.indexOf('mbox') != 0) {            B[B.length] = c[j].name + '=' + c[j].value;        }    }    return B;};mbox.prototype.setOnLoad = function (p) {    this.Sb = p;    return this;};mbox.prototype.setMessage = function (ob) {    this.message = ob;    return this;};mbox.prototype.setOnError = function (Rb) {    this.Rb = Rb;    return this;};mbox.prototype.setFetcher = function (Ub) {    if (this.Mb) {        this.Mb.cancel();    }    this.Mb = Ub;    return this;};mbox.prototype.getFetcher = function () {    return this.Mb;};mbox.prototype.load = function (c) {    if (this.Mb == null) {        return this;    }    this.setEventTime("load.start");    this.cancelTimeout();    this.Lb = 0;    var w = (c && c.length > 0) ? this.w.clone().addParameters(c) : this.w;    this.Mb.fetch(w);    var X = this;    this.Vb = setTimeout(function () {        X.Rb('browser timeout', X.Mb.getType());    }, 15000);    this.setEventTime("load.end");    return this;};mbox.prototype.loaded = function () {    this.cancelTimeout();    if (!this.activate()) {        var X = this;        setTimeout(function () {            X.loaded();        }, 100);    }};mbox.prototype.activate = function () {    if (this.Lb) {        return this.Lb;    }    this.setEventTime('activate' + ++this.Pb + '.start');    if (this.show()) {        this.cancelTimeout();        this.Lb = 1;    }    this.setEventTime('activate' + this.Pb + '.end');    return this.Lb;};mbox.prototype.isActivated = function () {    return this.Lb;};mbox.prototype.setOffer = function (Nb) {    if (Nb && Nb.show && Nb.setOnLoad) {        this.Nb = Nb;    } else {        throw 'Invalid offer';    }    return this;};mbox.prototype.getOffer = function () {    return this.Nb;};mbox.prototype.show = function () {    this.setEventTime('show.start');    var B = this.Nb.show(this);    this.setEventTime(B == 1 ? "show.end.ok" : "show.end");    return B;};mbox.prototype.showContent = function (Wb) {    if (Wb == null) {        return 0;    }    if (this.Fb == null || !this.Fb.parentNode) {        this.Fb = this.getDefaultDiv();        if (this.Fb == null) {            return 0;        }    }    if (this.Fb != Wb) {        this.Xb(this.Fb);        this.Fb.parentNode.replaceChild(Wb, this.Fb);        this.Fb = Wb;    }    this.Yb(Wb);    this.Sb();    return 1;};mbox.prototype.hide = function () {    this.setEventTime('hide.start');    var B = this.showContent(this.getDefaultDiv());    this.setEventTime(B == 1 ? 'hide.end.ok' : 'hide.end.fail');    return B;};mbox.prototype.finalize = function () {    this.setEventTime('finalize.start');    this.cancelTimeout();    if (this.getDefaultDiv() == null) {        if (this.mb.force() != null) {            this.setMessage('No default content, an empty one has been added');        } else {            this.setMessage('Unable to locate mbox');        }    }    if (!this.activate()) {        this.hide();        this.setEventTime('finalize.end.hide');    }    this.setEventTime('finalize.end.ok');};mbox.prototype.cancelTimeout = function () {    if (this.Vb) {        clearTimeout(this.Vb);    }    if (this.Mb != null) {        this.Mb.cancel();    }};mbox.prototype.getDiv = function () {    return this.Fb;};mbox.prototype.getDefaultDiv = function () {    if (this.Tb == null) {        this.Tb = this.mb.locate();    }    return this.Tb;};mbox.prototype.setEventTime = function (Zb) {    this.Ob[Zb] = (new Date()).getTime();};mbox.prototype.getEventTimes = function () {    return this.Ob;};mbox.prototype.getImportName = function () {    return this.nb;};mbox.prototype.getURL = function () {    return this.w.buildUrl();};mbox.prototype.getUrlBuilder = function () {    return this.w;};mbox.prototype._b = function (Fb) {    return Fb.style.display != 'none';};mbox.prototype.Yb = function (Fb) {    this.ac(Fb, true);};mbox.prototype.Xb = function (Fb) {    this.ac(Fb, false);};mbox.prototype.ac = function (Fb, bc) {    Fb.style.visibility = bc ? "visible" : "hidden";    Fb.style.display = bc ? "block" : "none";};mboxOfferContent = function () {    this.Sb = function () {};};mboxOfferContent.prototype.show = function (Y) {    var B = Y.showContent(document.getElementById(Y.getImportName()));    if (B == 1) {        this.Sb();    }    return B;};mboxOfferContent.prototype.setOnLoad = function (Sb) {    this.Sb = Sb;};mboxOfferAjax = function (Wb) {    this.Wb = Wb;    this.Sb = function () {};};mboxOfferAjax.prototype.setOnLoad = function (Sb) {    this.Sb = Sb;};mboxOfferAjax.prototype.show = function (Y) {    var cc = document.createElement('div');    cc.id = Y.getImportName();    cc.innerHTML = this.Wb;    var B = Y.showContent(cc);    if (B == 1) {        this.Sb();    }    return B;};mboxOfferDefault = function () {    this.Sb = function () {};};mboxOfferDefault.prototype.setOnLoad = function (Sb) {    this.Sb = Sb;};mboxOfferDefault.prototype.show = function (Y) {    var B = Y.hide();    if (B == 1) {        this.Sb();    }    return B;};mboxCookieManager = function mboxCookieManager(g, dc) {    this.g = g;    this.dc = dc == '' || dc.indexOf('.') == -1 ? '' : '; domain=' + dc;    this.ec = new mboxMap();    this.loadCookies();};mboxCookieManager.prototype.isEnabled = function () {    this.setCookie('check', 'true', 60);    this.loadCookies();    return this.getCookie('check') == 'true';};mboxCookieManager.prototype.setCookie = function (g, h, bb) {    if (typeof g != 'undefined' && typeof h != 'undefined' && typeof bb != 'undefined') {        var fc = new Object();        fc.name = g;        fc.value = escape(h);        fc.expireOn = Math.ceil(bb + new Date().getTime() / 1000);        this.ec.put(g, fc);        this.saveCookies();    }};mboxCookieManager.prototype.getCookie = function (g) {    var fc = this.ec.get(g);    return fc ? unescape(fc.value) : null;};mboxCookieManager.prototype.deleteCookie = function (g) {    this.ec.remove(g);    this.saveCookies();};mboxCookieManager.prototype.getCookieNames = function (gc) {    var hc = new Array();    this.ec.each(function (g, fc) {        if (g.indexOf(gc) == 0) {            hc[hc.length] = g;        }    });    return hc;};mboxCookieManager.prototype.saveCookies = function () {    var ic = new Array();    var jc = 0;    this.ec.each(function (g, fc) {        ic[ic.length] = g + '#' + fc.value + '#' + fc.expireOn;        if (jc < fc.expireOn) {            jc = fc.expireOn;        }    });    var kc = new Date(jc * 1000);    document.cookie = this.g + '=' + ic.join('|') + '; expires=' + kc.toGMTString() + '; path=/' + this.dc;};mboxCookieManager.prototype.loadCookies = function () {    this.ec = new mboxMap();    var lc = document.cookie.indexOf(this.g + '=');    if (lc != -1) {        var mc = document.cookie.indexOf(';', lc);        if (mc == -1) {            mc = document.cookie.indexOf(',', lc);            if (mc == -1) {                mc = document.cookie.length;            }        }        var nc = document.cookie.substring(lc + this.g.length + 1, mc).split('|');        var oc = Math.ceil(new Date().getTime() / 1000);        for (var j = 0; j < nc.length; j++) {            var fc = nc[j].split('#');            if (oc <= fc[2]) {                var pc = new Object();                pc.name = fc[0];                pc.value = fc[1];                pc.expireOn = fc[2];                this.ec.put(pc.name, pc);            }        }    }};mboxSession = function (qc, rc, Ab, sc, J) {    this.rc = rc;    this.Ab = Ab;    this.sc = sc;    this.J = J;    this.tc = false;    this.Ib = typeof mboxForceSessionId != 'undefined' ? mboxForceSessionId : mboxGetPageParameter(this.rc);    if (this.Ib == null || this.Ib.length == 0) {        this.Ib = J.getCookie(Ab);        if (this.Ib == null || this.Ib.length == 0) {            this.Ib = qc;            this.tc = true;        }    }    J.setCookie(Ab, this.Ib, sc);};mboxSession.prototype.getId = function () {    return this.Ib;};mboxSession.prototype.forceId = function (uc) {    this.Ib = uc;    this.J.setCookie(this.Ab, this.Ib, this.sc);};mboxPC = function (Ab, sc, J) {    this.Ab = Ab;    this.sc = sc;    this.J = J;    this.Ib = typeof mboxForcePCId != 'undefined' ? mboxForcePCId : J.getCookie(Ab);    if (this.Ib != null) {        J.setCookie(Ab, this.Ib, sc);    }};mboxPC.prototype.getId = function () {    return this.Ib;};mboxPC.prototype.forceId = function (uc) {    if (this.Ib != uc) {        this.Ib = uc;        this.J.setCookie(this.Ab, this.Ib, this.sc);        return true;    }    return false;};mboxGetPageParameter = function (g) {    var B = null;    var vc = new RegExp(g + "=([^\&]*)");    var wc = vc.exec(document.location);    if (wc != null && wc.length >= 2) {        B = wc[1];    }    return B;};mboxSetCookie = function (g, h, bb) {    return mboxFactoryDefault.getCookieManager().setCookie(g, h, bb);};mboxGetCookie = function (g) {    return mboxFactoryDefault.getCookieManager().getCookie(g);};mboxCookiePageDomain = function () {    var dc = (/([^:]*)(:[0-9]{0,5})?/).exec(document.location.host)[1];    var xc = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/;    if (!xc.exec(dc)) {        var yc = (/([^\.]+\.[^\.]{3}|[^\.]+\.[^\.]+\.[^\.]{2})$/).exec(dc);        if (yc) {            dc = yc[0];        }    }    return dc ? dc : "";};mboxShiftArray = function (zc) {    var B = new Array();    for (var j = 1; j < zc.length; j++) {        B[B.length] = zc[j];    }    return B;};mboxGenerateId = function () {    return (new Date()).getTime() + "-" + Math.floor(Math.random() * 999999);};mboxScreenHeight = function () {    return screen.height;};mboxScreenWidth = function () {    return screen.width;};mboxBrowserWidth = function () {    return (window.innerWidth) ? window.innerWidth : document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth;};mboxBrowserHeight = function () {    return (window.innerHeight) ? window.innerHeight : document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight;};mboxBrowserTimeOffset = function () {    return -new Date().getTimezoneOffset();};mboxScreenColorDepth = function () {    return screen.pixelDepth;};if (typeof mboxVersion == 'undefined') {    var mboxVersion = 40;    var mboxFactories = new mboxMap();    var mboxFactoryDefault = new mboxFactory('staples.tt.omtrdc.net', 'staples', 'default');};if (mboxGetPageParameter("mboxDebug") != null || mboxFactoryDefault.getCookieManager().getCookie("debug") != null) {    setTimeout(function () {        if (typeof mboxDebugLoaded == 'undefined') {            alert('Could not load the remote debug.\nPlease check your connection' + ' to Test&amp;Target servers');        }    }, 60 * 60);    document.write('<' + 'scr' + 'ipt language="Javascript1.2" src=' + '"http://admin5.testandtarget.omniture.com/admin/mbox/mbox_debug.jsp?mboxServerHost=staples.tt.omtrdc.net' + '&clientCode=staples"><' + '\/scr' + 'ipt>');};