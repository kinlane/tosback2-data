/** File: /common/javascripts/jquery.js **/
/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {
var jQuery = function( selector, context ) {
		return new jQuery.fn.init( selector, context, rootjQuery );
	},
	_jQuery = window.jQuery,
	_$ = window.$,
	rootjQuery,
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
	rnotwhite = /\S/,
	trimLeft = /^\s+/,
	trimRight = /\s+$/,
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},
	userAgent = navigator.userAgent,
	browserMatch,
	readyList,
	DOMContentLoaded,
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,
	class2type = {};
jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;
		if ( !selector ) {
			return this;
		}
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				match = [ null, selector, null ];
			} else {
				match = quickExpr.exec( selector );
			}
			if ( match && (match[1] || !context) ) {
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );
					ret = rsingleTag.exec( selector );
					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );
						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}
					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}
					return jQuery.merge( this, selector );
				} else {
					elem = document.getElementById( match[2] );
					if ( elem && elem.parentNode ) {
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}
						this.length = 1;
						this[0] = elem;
					}
					this.context = document;
					this.selector = selector;
					return this;
				}
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );
			} else {
				return this.constructor( context ).find( selector );
			}
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}
		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}
		return jQuery.makeArray( selector, this );
	},
	selector: "",
	jquery: "1.7.2",
	length: 0,
	size: function() {
		return this.length;
	},
	toArray: function() {
		return slice.call( this, 0 );
	},
	get: function( num ) {
		return num == null ?
			this.toArray() :
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},
	pushStack: function( elems, name, selector ) {
		var ret = this.constructor();
		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );
		} else {
			jQuery.merge( ret, elems );
		}
		ret.prevObject = this;
		ret.context = this.context;
		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}
		return ret;
	},
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},
	ready: function( fn ) {
		jQuery.bindReady();
		readyList.add( fn );
		return this;
	},
	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},
	first: function() {
		return this.eq( 0 );
	},
	last: function() {
		return this.eq( -1 );
	},
	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},
	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},
	end: function() {
		return this.prevObject || this.constructor(null);
	},
	push: push,
	sort: [].sort,
	splice: [].splice
};
jQuery.fn.init.prototype = jQuery.fn;
jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		i = 2;
	}
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}
	if ( length === i ) {
		target = this;
		--i;
	}
	for ( ; i < length; i++ ) {
		if ( (options = arguments[ i ]) != null ) {
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];
				if ( target === copy ) {
					continue;
				}
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];
					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}
					target[ name ] = jQuery.extend( deep, clone, copy );
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}
	return target;
};
jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
		return jQuery;
	},
	isReady: false,
	readyWait: 1,
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},
	ready: function( wait ) {
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}
			jQuery.isReady = true;
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
			readyList.fireWith( document, [ jQuery ] );
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},
	bindReady: function() {
		if ( readyList ) {
			return;
		}
		readyList = jQuery.Callbacks( "once memory" );
		if ( document.readyState === "complete" ) {
			return setTimeout( jQuery.ready, 1 );
		}
		if ( document.addEventListener ) {
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			window.addEventListener( "load", jQuery.ready, false );
		} else if ( document.attachEvent ) {
			document.attachEvent( "onreadystatechange", DOMContentLoaded );
			window.attachEvent( "onload", jQuery.ready );
			var toplevel = false;
			try {
				toplevel = window.frameElement == null;
			} catch(e) {}
			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},
	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},
	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},
	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},
	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},
	isPlainObject: function( obj ) {
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}
		try {
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			return false;
		}
		var key;
		for ( key in obj ) {}
		return key === undefined || hasOwn.call( obj, key );
	},
	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},
	error: function( msg ) {
		throw new Error( msg );
	},
	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		data = jQuery.trim( data );
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {
			return ( new Function( "return " + data ) )();
		}
		jQuery.error( "Invalid JSON: " + data );
	},
	parseXML: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},
	noop: function() {},
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},
	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );
		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}
		return object;
	},
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},
	makeArray: function( array, results ) {
		var ret = results || [];
		if ( array != null ) {
			var type = jQuery.type( array );
			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}
		return ret;
	},
	inArray: function( elem, array, i ) {
		var len;
		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}
			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
			for ( ; i < len; i++ ) {
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}
		return -1;
	},
	merge: function( first, second ) {
		var i = first.length,
			j = 0;
		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}
		first.length = i;
		return first;
	},
	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}
		return ret;
	},
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );
				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );
				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}
		return ret.concat.apply( [], ret );
	},
	guid: 1,
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
		return proxy;
	},
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;
		} else if ( value !== undefined ) {
			exec = pass === undefined && jQuery.isFunction( value );
			if ( bulk ) {
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}
			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}
			chainable = 1;
		}
		return chainable ?
			elems :
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},
	now: function() {
		return ( new Date() ).getTime();
	},
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();
		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];
		return { browser: match[1] || "", version: match[2] || "0" };
	},
	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}
			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},
	browser: {}
});
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});
browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}
rootjQuery = jQuery(document);
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};
} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}
	try {
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}
	jQuery.ready();
}
return jQuery;
})();
var flagsCache = {};
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}
/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};
	var // Actual callback list
		list = [],
		stack = [],
		memory,
		fired,
		firing,
		firingStart,
		firingLength,
		firingIndex,
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					add( elem );
				} else if ( type === "function" ) {
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			fired = true;
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		self = {
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					if ( firing ) {
						firingLength = list.length;
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								list.splice( i--, 1 );
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			empty: function() {
				list = [];
				return this;
			},
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			disabled: function() {
				return !list;
			},
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			locked: function() {
				return !stack;
			},
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			fired: function() {
				return !!fired;
			}
		};
	return self;
};
var // Static reference to slice
	sliceDeferred = [].slice;
jQuery.extend({
	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,
				state: function() {
					return state;
				},
				isResolved: doneList.fired,
				isRejected: failList.fired,
				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;
		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );
		if ( func ) {
			func.call( deferred, deferred );
		}
		return deferred;
	},
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});
jQuery.support = (function() {
	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];
	if ( !all || !all.length || !a ) {
		return {};
	}
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];
	support = {
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),
		tbody: !div.getElementsByTagName("tbody").length,
		htmlSerialize: !!div.getElementsByTagName("link").length,
		style: /top/.test( a.getAttribute("style") ),
		hrefNormalized: ( a.getAttribute("href") === "/a" ),
		opacity: /^0.55/.test( a.style.opacity ),
		cssFloat: !!a.style.cssFloat,
		checkOn: ( input.value === "on" ),
		optSelected: opt.selected,
		getSetAttribute: div.className !== "t",
		enctype: !!document.createElement("form").enctype,
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		pixelMargin: true
	};
	jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;
	select.disabled = true;
	support.optDisabled = !opt.disabled;
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}
	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";
	input.setAttribute("checked", "checked");
	input.setAttribute( "name", "t" );
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
	support.appendChecked = input.checked;
	fragment.removeChild( input );
	fragment.appendChild( div );
	if ( div.attachEvent ) {
		for ( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}
	fragment.removeChild( div );
	fragment = select = opt = div = input = null;
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
			paddingMarginBorderVisibility, paddingMarginBorder,
			body = document.getElementsByTagName("body")[0];
		if ( !body ) {
			return;
		}
		conMarginTop = 1;
		paddingMarginBorder = "padding:0;margin:0;border:";
		positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
		paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
		style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
		html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
			"<table " + style + "' cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";
		container = document.createElement("div");
		container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );
		div = document.createElement("div");
		container.appendChild( div );
		div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );
		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
		if ( window.getComputedStyle ) {
			div.innerHTML = "";
			marginDiv = document.createElement( "div" );
			marginDiv.style.width = "0";
			marginDiv.style.marginRight = "0";
			div.style.width = "2px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
		}
		if ( typeof div.style.zoom !== "undefined" ) {
			div.innerHTML = "";
			div.style.width = div.style.padding = "1px";
			div.style.border = 0;
			div.style.overflow = "hidden";
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div style='width:5px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		}
		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
		div.innerHTML = html;
		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;
		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};
		inner.style.position = "fixed";
		inner.style.top = "20px";
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";
		outer.style.overflow = "hidden";
		outer.style.position = "relative";
		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );
		if ( window.getComputedStyle ) {
			div.style.marginTop = "1%";
			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
		}
		if ( typeof container.style.zoom !== "undefined" ) {
			container.style.zoom = 1;
		}
		body.removeChild( container );
		marginDiv = div = container = null;
		jQuery.extend( support, offsetSupport );
	});
	return support;
})();
var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;
jQuery.extend({
	cache: {},
	uuid: 0,
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
	noData: {
		"embed": true,
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},
	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},
	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}
		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",
			isNode = elem.nodeType,
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}
		if ( !id ) {
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}
		if ( !cache[ id ] ) {
			cache[ id ] = {};
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}
		privateCache = thisCache = cache[ id ];
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}
			thisCache = thisCache.data;
		}
		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}
		if ( getByName ) {
			ret = thisCache[ name ];
			if ( ret == null ) {
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}
		return ret;
	},
	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}
		var thisCache, i, l,
			internalKey = jQuery.expando,
			isNode = elem.nodeType,
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ internalKey ] : internalKey;
		if ( !cache[ id ] ) {
			return;
		}
		if ( name ) {
			thisCache = pvt ? cache[ id ] : cache[ id ].data;
			if ( thisCache ) {
				if ( !jQuery.isArray( name ) ) {
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}
				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}
		if ( !pvt ) {
			delete cache[ id ].data;
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}
		if ( isNode ) {
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}
		return true;
	}
});
jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );
				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;
						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );
							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}
			return data;
		}
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}
		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";
		return jQuery.access( this, function( value ) {
			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}
				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}
			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );
				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},
	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});
function dataAttr( elem, key, data ) {
	if ( data === undefined && elem.nodeType === 1 ) {
		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );
		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}
			jQuery.data( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}
	return true;
}
function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}
jQuery.extend({
	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},
	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},
	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},
	dequeue: function( elem, type ) {
		type = type || "fx";
		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}
		if ( fn ) {
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}
			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}
		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});
jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}
		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}
		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );
				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise( object );
	}
});
var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;
jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},
	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},
	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},
	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},
	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;
		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}
		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );
			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;
					} else {
						setClass = " " + elem.className + " ";
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}
		return this;
	},
	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;
		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );
			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );
					} else {
						elem.className = "";
					}
				}
			}
		}
		return this;
	},
	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";
		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}
		return this.each(function() {
			if ( type === "string" ) {
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );
				while ( (className = classNames[ i++ ]) ) {
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}
			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					jQuery._data( this, "__className__", this.className );
				}
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},
	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}
		return false;
	},
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];
		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}
				ret = elem.value;
				return typeof ret === "string" ?
					ret.replace(rreturn, "") :
					ret == null ? "" : ret;
			}
			return;
		}
		isFunction = jQuery.isFunction( value );
		return this.each(function( i ) {
			var self = jQuery(this), val;
			if ( this.nodeType !== 1 ) {
				return;
			}
			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}
			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});
jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";
				if ( index < 0 ) {
					return null;
				}
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {
						value = jQuery( option ).val();
						if ( one ) {
							return value;
						}
						values.push( value );
					}
				}
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}
				return values;
			},
			set: function( elem, value ) {
				var values = jQuery.makeArray( value );
				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});
				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},
	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},
	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}
		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}
		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}
		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;
			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}
		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;
		} else {
			ret = elem.getAttribute( name );
			return ret === null ?
				undefined :
				ret;
		}
	},
	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l, isBool,
			i = 0;
		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;
			for ( ; i < l; i++ ) {
				name = attrNames[ i ];
				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},
	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				elem.value = value;
			}
		}
	},
	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},
	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}
		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
		if ( notxml ) {
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}
		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;
			} else {
				return ( elem[ name ] = value );
			}
		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;
			} else {
				return elem[ name ];
			}
		}
	},
	propHooks: {
		tabIndex: {
			get: function( elem ) {
				var attributeNode = elem.getAttributeNode("tabindex");
				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;
boolHook = {
	get: function( elem, name ) {
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			jQuery.removeAttr( elem, name );
		} else {
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				elem[ propName ] = true;
			}
			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};
if ( !getSetAttribute ) {
	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};
	jQuery.attrHooks.tabindex.set = nodeHook.set;
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}
if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};
/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {
	add: function( elem, types, handler, data, selector ) {
		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			eventHandle.elem = elem;
		}
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();
			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			special = jQuery.event.special[ type ] || {};
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: selector && quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}
			if ( special.add ) {
				special.add.call( elem, handleObj );
				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}
			jQuery.event.global[ type ] = true;
		}
		elem = null;
	},
	global: {},
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;
		if ( !elemData || !(events = elemData.events) ) {
			return;
		}
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}
			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];
				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );
					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}
				delete events[ type ];
			}
		}
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},
	trigger: function( event, data, elem, onlyHandlers ) {
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}
		if ( type.indexOf( "!" ) >= 0 ) {
			type = type.slice(0, -1);
			exclusive = true;
		}
		if ( type.indexOf( "." ) >= 0 ) {
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			return;
		}
		event = typeof event === "object" ?
			event[ jQuery.expando ] ? event :
			new jQuery.Event( type, event ) :
			new jQuery.Event( type );
		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";
		if ( !elem ) {
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {
			cur = eventPath[i][0];
			event.type = eventPath[i][1];
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
					old = elem[ ontype ];
					if ( old ) {
						elem[ ontype ] = null;
					}
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;
					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}
		return event.result;
	},
	dispatch: function( event ) {
		event = jQuery.event.fix( event || window.event );
		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;
		args[0] = event;
		event.delegateTarget = this;
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}
		if ( delegateCount && !(event.button && event.type === "click") ) {
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;
			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				if ( cur.disabled !== true ) {
					selMatch = {};
					matches = [];
					jqcur[0] = cur;
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;
						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = (
								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
							);
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;
			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {
					event.data = handleObj.data;
					event.handleObj = handleObj;
					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );
					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}
		return event.result;
	},
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
	fixHooks: {},
	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}
			return event;
		}
	},
	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;
				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}
			return event;
		}
	},
	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
		event = jQuery.Event( originalEvent );
		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}
		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},
	special: {
		ready: {
			setup: jQuery.bindReady
		},
		load: {
			noBubble: true
		},
		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},
		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},
			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},
	simulate: function( type, elem, event, bubble ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};
jQuery.event.handle = jQuery.event.dispatch;
jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};
jQuery.Event = function( src, props ) {
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
	} else {
		this.type = src;
	}
	if ( props ) {
		jQuery.extend( this, props );
	}
	this.timeStamp = src && src.timeStamp || jQuery.now();
	this[ jQuery.expando ] = true;
};
function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;
		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		if ( e.preventDefault ) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;
		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,
		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});
if ( !jQuery.support.submitBubbles ) {
	jQuery.event.special.submit = {
		setup: function() {
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					form._submit_attached = true;
				}
			});
		},
		
		postDispatch: function( event ) {
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},
		teardown: function() {
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}
			jQuery.event.remove( this, "._submit" );
		}
	};
}
if ( !jQuery.support.changeBubbles ) {
	jQuery.event.special.change = {
		setup: function() {
			if ( rformElems.test( this.nodeName ) ) {
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;
				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},
		handle: function( event ) {
			var elem = event.target;
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},
		teardown: function() {
			jQuery.event.remove( this, "._change" );
			return rformElems.test( this.nodeName );
		}
	};
}
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};
		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}
jQuery.fn.extend({
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;
		if ( typeof types === "object" ) {
			if ( typeof selector !== "string" ) { // && selector != null
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}
		if ( data == null && fn == null ) {
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				fn = data;
				data = undefined;
			} else {
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},
	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},
	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},
	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},
	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},
	toggle: function( fn ) {
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
				event.preventDefault();
				return args[ lastToggle ].apply( this, arguments ) || false;
			};
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}
		return this.click( toggler );
	},
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}
	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){
var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});
var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var origContext = context;
	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}
	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );
		if ( m ) {
			soFar = m[3];
			parts.push( m[1] );
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );
	if ( parts.length > 1 && origPOS.exec( selector ) ) {
		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );
		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );
			while ( parts.length ) {
				selector = parts.shift();
				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				set = posProcess( selector, set, seed );
			}
		}
	} else {
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}
		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;
			if ( parts.length > 0 ) {
				checkSet = makeArray( set );
			} else {
				prune = false;
			}
			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;
				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}
				if ( pop == null ) {
					pop = context;
				}
				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}
		} else {
			checkSet = parts = [];
		}
	}
	if ( !checkSet ) {
		checkSet = set;
	}
	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}
	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );
		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}
		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}
	} else {
		makeArray( checkSet, results );
	}
	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}
	return results;
};
Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );
		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}
	return results;
};
Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};
Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};
Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;
	if ( !expr ) {
		return [];
	}
	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );
			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );
				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}
	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}
	return { set: set, expr: expr };
};
Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];
				anyFound = false;
				match.splice(1,1);
				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}
				if ( curLoop === result ) {
					result = [];
				}
				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
					if ( !match ) {
						anyFound = found = true;
					} else if ( match === true ) {
						continue;
					}
				}
				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;
							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;
								} else {
									curLoop[i] = false;
								}
							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}
				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}
					expr = expr.replace( Expr.match[ type ], "" );
					if ( !anyFound ) {
						return [];
					}
					break;
				}
			}
		}
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );
			} else {
				break;
			}
		}
		old = expr;
	}
	return curLoop;
};
Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};
/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";
	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				return elem.innerText.replace( rReturn, '' );
			} else {
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {
		for ( i = 0; (node = elem[i]); i++ ) {
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};
var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],
	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},
	leftMatch: {},
	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},
	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},
	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;
			if ( isTag ) {
				part = part.toLowerCase();
			}
			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}
			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},
		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;
			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				for ( ; i < l; i++ ) {
					elem = checkSet[i];
					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}
			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];
					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}
				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},
		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;
			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}
			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},
		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;
			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}
			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},
	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m && m.parentNode ? [m] : [];
			}
		},
		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );
				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}
				return ret.length === 0 ? null : ret;
			}
		},
		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";
			if ( isXML ) {
				return match;
			}
			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}
					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}
			return false;
		},
		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},
		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},
		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}
				match[2] = match[2].replace(/^\+|\s*/g, '');
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}
			match[0] = done++;
			return match;
		},
		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}
			return match;
		},
		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);
				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
					if ( !inplace ) {
						result.push.apply( result, ret );
					}
					return false;
				}
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			return match;
		},
		POS: function( match ) {
			match.unshift( true );
			return match;
		}
	},
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},
		disabled: function( elem ) {
			return elem.disabled === true;
		},
		checked: function( elem ) {
			return elem.checked === true;
		},
		selected: function( elem ) {
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			return elem.selected === true;
		},
		parent: function( elem ) {
			return !!elem.firstChild;
		},
		empty: function( elem ) {
			return !elem.firstChild;
		},
		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},
		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},
		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},
		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},
		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},
		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},
		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},
		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},
		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},
		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},
		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},
		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},
		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},
		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},
		even: function( elem, i ) {
			return i % 2 === 0;
		},
		odd: function( elem, i ) {
			return i % 2 === 1;
		},
		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},
		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},
		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},
		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];
			if ( filter ) {
				return filter( elem, i, match, array );
			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;
			} else if ( name === "not" ) {
				var not = match[3];
				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}
				return true;
			} else {
				Sizzle.error( name );
			}
		},
		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;
			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}
					if ( type === "first" ) {
						return true;
					}
					node = elem;
					/* falls through */
				case "last":
					while ( (node = node.nextSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}
					return true;
				case "nth":
					first = match[2];
					last = match[3];
					if ( first === 1 && last === 0 ) {
						return true;
					}
					doneName = match[0];
					parent = elem.parentNode;
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}
						parent[ expando ] = doneName;
					}
					diff = elem.nodeIndex - last;
					if ( first === 0 ) {
						return diff === 0;
					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},
		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},
		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},
		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];
			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},
		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];
			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};
var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};
for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
Expr.match.globalPOS = origPOS;
var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );
	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	return array;
};
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];
		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );
		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}
			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}
		return ret;
	};
}
var sortOrder, siblingCheck;
if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}
		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};
} else {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}
		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;
		if ( aup === bup ) {
			return siblingCheck( a, b );
		} else if ( !aup ) {
			return -1;
		} else if ( !bup ) {
			return 1;
		}
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}
		cur = bup;
		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}
		al = ap.length;
		bl = bp.length;
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};
	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}
		var cur = a.nextSibling;
		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}
			cur = cur.nextSibling;
		}
		return 1;
	};
}
(function(){
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;
	form.innerHTML = "<a name='" + id + "'/>";
	root.insertBefore( form, root.firstChild );
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};
		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}
	root.removeChild( form );
	root = form = null;
})();
(function(){
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );
			if ( match[1] === "*" ) {
				var tmp = [];
				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}
				results = tmp;
			}
			return results;
		};
	}
	div.innerHTML = "<a href='#'></a>";
	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {
		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}
	div = null;
})();
if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";
		div.innerHTML = "<p class='TEST'></p>";
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;
			if ( !seed && !Sizzle.isXML(context) ) {
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				if ( context.nodeType === 9 ) {
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );
						if ( elem && elem.parentNode ) {
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
						} else {
							return makeArray( [], extra );
						}
					}
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );
					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}
					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}
					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
			return oldSizzle(query, context, extra, seed);
		};
		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}
		div = null;
	})();
}
(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
	if ( matches ) {
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;
		try {
			matches.call( document.documentElement, "[test!='']:sizzle" );
		} catch( pseudoError ) {
			pseudoWorks = true;
		}
		Sizzle.matchesSelector = function( node, expr ) {
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
			if ( !Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );
						if ( ret || !disconnectedMatch ||
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}
			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();
(function(){
	var div = document.createElement("div");
	div.innerHTML = "<div class='test e'></div><div class='test'></div>";
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}
	div.lastChild.className = "e";
	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};
	div = null;
})();
function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			var match = false;
			elem = elem[dir];
			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}
				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}
				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}
				elem = elem[dir];
			}
			checkSet[i] = match;
		}
	}
}
function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			var match = false;
			elem = elem[dir];
			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}
				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}
					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}
					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}
				elem = elem[dir];
			}
			checkSet[i] = match;
		}
	}
}
if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};
} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};
} else {
	Sizzle.contains = function() {
		return false;
	};
}
Sizzle.isXML = function( elem ) {
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};
var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}
	selector = Expr.relative[selector] ? selector + "*" : selector;
	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}
	return Sizzle.filter( later, tmpSet );
};
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
})();
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.globalPOS,
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};
jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;
		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}
		var ret = this.pushStack( "", "find", selector ),
			length, n, r;
		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );
			if ( i > 0 ) {
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}
		return ret;
	},
	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},
	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				POS.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},
	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;
			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {
					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}
				cur = cur.parentNode;
				level++;
			}
			return ret;
		}
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;
		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];
			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}
		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
		return this.pushStack( ret, "closest", selectors );
	},
	index: function( elem ) {
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}
		return jQuery.inArray(
			elem.jquery ? elem[0] : elem, this );
	},
	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );
		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},
	andSelf: function() {
		return this.add( this.prevObject );
	}
});
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}
jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );
		if ( !runtil.test( name ) ) {
			selector = until;
		}
		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}
		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}
		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});
jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];
		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},
	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;
		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}
		return cur;
	},
	sibling: function( n, elem ) {
		var r = [];
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}
		return r;
	}
});
function winnow( elements, qualifier, keep ) {
	qualifier = qualifier || 0;
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});
	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});
	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});
		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}
	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();
	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}
var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );
wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}
jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}
		if ( this[0] ) {
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}
			wrap.map(function() {
				var elem = this;
				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}
				return elem;
			}).append( this );
		}
		return this;
	},
	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}
		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();
			if ( contents.length ) {
				contents.wrapAll( html );
			} else {
				self.append( html );
			}
		});
	},
	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );
		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},
	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},
	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},
	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},
	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},
	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}
				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}
		return this;
	},
	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}
		return this;
	},
	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},
	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;
			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					null;
			}
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {
				value = value.replace( rxhtmlTag, "<$1></$2>" );
				try {
					for (; i < l; i++ ) {
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}
					elem = 0;
				} catch(e) {}
			}
			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},
	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}
			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}
			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;
				jQuery( this ).remove();
				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},
	detach: function( selector ) {
		return this.remove( selector, true );
	},
	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}
		if ( this[0] ) {
			parent = value && value.parentNode;
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };
			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}
			fragment = results.fragment;
			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}
			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );
				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}
			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						jQuery.ajax({
							type: "GET",
							global: false,
							url: elem.src,
							async: false,
							dataType: "script"
						});
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
					}
					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}
		return this;
	}
});
function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}
function cloneCopyEvent( src, dest ) {
	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}
	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;
	if ( events ) {
		delete curData.handle;
		curData.events = {};
		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}
function cloneFixAttributes( src, dest ) {
	var nodeName;
	if ( dest.nodeType !== 1 ) {
		return;
	}
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}
	nodeName = dest.nodeName.toLowerCase();
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;
	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}
	dest.removeAttribute( jQuery.expando );
	dest.removeAttribute( "_submit_attached" );
	dest.removeAttribute( "_change_attached" );
}
jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
		cacheable = true;
		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}
	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}
	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}
	return { fragment: fragment, cacheable: cacheable };
};
jQuery.fragments = {};
jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;
		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}
			return this.pushStack( ret, name, insert.selector );
		}
	};
});
function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );
	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );
	} else {
		return [];
	}
}
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );
	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}
jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );
		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			cloneFixAttributes( elem, clone );
			srcElements = getAll( elem );
			destElements = getAll( clone );
			for ( i = 0; srcElements[i]; ++i ) {
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );
			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );
				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}
		srcElements = destElements = null;
		return clone;
	},
	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType, script, j,
				ret = [];
		context = context || document;
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}
			if ( !elem ) {
				continue;
			}
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					elem = elem.replace(rxhtmlTag, "<$1></$2>");
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div"),
						safeChildNodes = safeFragment.childNodes,
						remove;
					if ( context === document ) {
						safeFragment.appendChild( div );
					} else {
						createSafeFragment( context ).appendChild( div );
					}
					div.innerHTML = wrap[1] + elem + wrap[2];
					while ( depth-- ) {
						div = div.lastChild;
					}
					if ( !jQuery.support.tbody ) {
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];
						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}
					elem = div.childNodes;
					if ( div ) {
						div.parentNode.removeChild( div );
						if ( safeChildNodes.length > 0 ) {
							remove = safeChildNodes[ safeChildNodes.length - 1 ];
							if ( remove && remove.parentNode ) {
								remove.parentNode.removeChild( remove );
							}
						}
					}
				}
			}
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}
			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}
		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				script = ret[i];
				if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );
				} else {
					if ( script.nodeType === 1 ) {
						var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( script );
				}
			}
		}
		return ret;
	},
	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}
			id = elem[ jQuery.expando ];
			if ( id ) {
				data = cache[ id ];
				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}
				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];
				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}
				delete cache[ id ];
			}
		}
	}
});
var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rupper = /([A-Z]|^ms)/g,
	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
	rrelNum = /^([\-+])=([\-+.\de]+)/,
	rmargin = /^margin/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	curCSS,
	getComputedStyle,
	currentStyle;
jQuery.fn.css = function( name, value ) {
	return jQuery.access( this, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	}, name, value, arguments.length > 1 );
};
jQuery.extend({
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				} else {
					return elem.style.opacity;
				}
			}
		}
	},
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},
	cssProps: {
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},
	style: function( elem, name, value, extra ) {
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];
		name = jQuery.cssProps[ origName ] || origName;
		if ( value !== undefined ) {
			type = typeof value;
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				type = "number";
			}
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				try {
					style[ name ] = value;
				} catch(e) {}
			}
		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}
			return style[ name ];
		}
	},
	css: function( elem, name, extra ) {
		var ret, hooks;
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;
		if ( name === "cssFloat" ) {
			name = "float";
		}
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},
	swap: function( elem, options, callback ) {
		var old = {},
			ret, name;
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
		ret = callback.call( elem );
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
		return ret;
	}
});
jQuery.curCSS = jQuery.css;
if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle, width,
			style = elem.style;
		name = name.replace( rupper, "-$1" ).toLowerCase();
		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}
		if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
			width = style.width;
			style.width = ret;
			ret = computedStyle.width;
			style.width = width;
		}
		return ret;
	};
}
if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;
		if ( ret == null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}
		if ( rnumnonpx.test( ret ) ) {
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}
		return ret === "" ? "auto" : ret;
	};
}
curCSS = getComputedStyle || currentStyle;
function getWidthOrHeight( elem, name, extra ) {
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		i = name === "width" ? 1 : 0,
		len = 4;
	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i += 2 ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
				}
			}
		}
		return val + "px";
	}
	val = curCSS( elem, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ];
	}
	if ( rnumnonpx.test(val) ) {
		return val;
	}
	val = parseFloat( val ) || 0;
	if ( extra ) {
		for ( ; i < len; i += 2 ) {
			val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
			}
		}
	}
	return val + "px";
}
jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWidthOrHeight( elem, name, extra );
				} else {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				}
			}
		},
		set: function( elem, value ) {
			return rnum.test( value ) ?
				value + "px" :
				value;
		}
	};
});
if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},
		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";
			style.zoom = 1;
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {
				style.removeAttribute( "filter" );
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "margin-right" );
					} else {
						return elem.style.marginRight;
					}
				});
			}
		};
	}
});
if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;
		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};
			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}
			return expanded;
		}
	};
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
	_load = jQuery.fn.load,
	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},
	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},
	ajaxLocation,
	ajaxLocParts,
	allTypes = ["*/"] + ["*"];
try {
	ajaxLocation = location.href;
} catch( e ) {
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
function addToPrefiltersOrTransports( structure ) {
	return function( dataTypeExpression, func ) {
		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}
		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {
	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};
	inspected[ dataType ] = true;
	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;
	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	return selection;
}
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}
jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		} else if ( !this.length ) {
			return this;
		}
		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}
		var type = "GET";
		if ( params ) {
			if ( jQuery.isFunction( params ) ) {
				callback = params;
				params = undefined;
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}
		var self = this;
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			complete: function( jqXHR, status, responseText ) {
				responseText = jqXHR.responseText;
				if ( jqXHR.isResolved() ) {
					jqXHR.done(function( r ) {
						responseText = r;
					});
					self.html( selector ?
						jQuery("<div>")
							.append(responseText.replace(rscript, ""))
							.find(selector) :
						responseText );
				}
				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});
		return this;
	},
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();
			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});
jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}
		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});
jQuery.extend({
	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},
	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},
	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/
		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},
		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},
		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},
		converters: {
			"* text": window.String,
			"text html": true,
			"text json": jQuery.parseJSON,
			"text xml": jQuery.parseXML
		},
		flatOptions: {
			context: true,
			url: true
		}
	},
	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),
	ajax: function( url, options ) {
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}
		options = options || {};
		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			callbackContext = s.context || s,
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			statusCode = s.statusCode || {},
			ifModifiedKey,
			requestHeaders = {},
			requestHeadersNames = {},
			responseHeadersString,
			responseHeaders,
			transport,
			timeoutTimer,
			parts,
			state = 0,
			fireGlobals,
			i,
			jqXHR = {
				readyState: 0,
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};
		function done( status, nativeStatusText, responses, headers ) {
			if ( state === 2 ) {
				return;
			}
			state = 2;
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}
			transport = undefined;
			responseHeadersString = headers || "";
			jqXHR.readyState = status > 0 ? 4 : 0;
			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;
			if ( status >= 200 && status < 300 || status === 304 ) {
				if ( s.ifModified ) {
					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}
				if ( status === 304 ) {
					statusText = "notmodified";
					isSuccess = true;
				} else {
					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}
			jqXHR.statusCode( statusCode );
			statusCode = undefined;
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
		if ( state === 2 ) {
			return false;
		}
		fireGlobals = s.global;
		s.type = s.type.toUpperCase();
		s.hasContent = !rnoContent.test( s.type );
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}
		if ( !s.hasContent ) {
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				delete s.data;
			}
			ifModifiedKey = s.url;
			if ( s.cache === false ) {
				var ts = jQuery.now(),
					ret = s.url.replace( rts, "$1_=" + ts );
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				jqXHR.abort();
				return false;
		}
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}
			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				if ( state < 2 ) {
					done( -1, e );
				} else {
					throw e;
				}
			}
		}
		return jqXHR;
	},
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
		} else {
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
		return s.join( "&" ).replace( r20, "+" );
	}
});
function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				add( prefix, v );
			} else {
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});
	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}
	} else {
		add( prefix, obj );
	}
}
jQuery.extend({
	active: 0,
	lastModified: {},
	etag: {}
});
/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		finalDataType = finalDataType || firstDataType;
	}
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}
function ajaxConvert( s, response ) {
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}
	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		current = dataTypes[ 0 ],
		prev,
		conversion,
		conv,
		conv1,
		conv2;
	for ( i = 1; i < length; i++ ) {
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}
		prev = current;
		current = dataTypes[ i ];
		if ( current === "*" ) {
			current = prev;
		} else if ( prev !== "*" && prev !== current ) {
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			if ( conv !== true ) {
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}
var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );
	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {
		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";
		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}
		s.url = url;
		s.data = data;
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};
		jqXHR.always(function() {
			window[ jsonpCallback ] = previous;
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};
		s.dataTypes[ 0 ] = "json";
		return "script";
	}
});
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});
jQuery.ajaxTransport( "script", function(s) {
	if ( s.crossDomain ) {
		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
		return {
			send: function( _, callback ) {
				script = document.createElement( "script" );
				script.async = "async";
				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}
				script.src = s.url;
				script.onload = script.onreadystatechange = function( _, isAbort ) {
					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
						script.onload = script.onreadystatechange = null;
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}
						script = undefined;
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				head.insertBefore( script, head.firstChild );
			},
			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}
function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	createStandardXHR;
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );
if ( jQuery.support.ajax ) {
	jQuery.ajaxTransport(function( s ) {
		if ( !s.crossDomain || jQuery.support.cors ) {
			var callback;
			return {
				send: function( headers, complete ) {
					var xhr = s.xhr(),
						handle,
						i;
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}
					xhr.send( ( s.hasContent && s.data ) || null );
					callback = function( _, isAbort ) {
						var status,
							statusText,
							responseHeaders,
							responses,
							xml;
						try {
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
								callback = undefined;
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}
								if ( isAbort ) {
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										statusText = "";
									}
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},
				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		[ "opacity" ]
	],
	fxNow;
jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;
		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );
		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];
				if ( elem.style ) {
					display = elem.style.display;
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}
					if ( (display === "" && jQuery.css(elem, "display") === "none") ||
						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];
				if ( elem.style ) {
					display = elem.style.display;
					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}
			return this;
		}
	},
	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);
		} else {
			var elem, display,
				i = 0,
				j = this.length;
			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );
					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}
			return this;
		}
	},
	_toggle: jQuery.fn.toggle,
	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";
		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );
		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});
		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}
		return this;
	},
	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},
	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );
		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}
		prop = jQuery.extend( {}, prop );
		function doAnimation() {
			if ( optall.queue === false ) {
				jQuery._mark( this );
			}
			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e, hooks, replace,
				parts, start, end, unit,
				method;
			opt.animatedProperties = {};
			for ( p in prop ) {
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}
				if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
					replace = hooks.expand( prop[ name ] );
					delete prop[ name ];
					for ( p in replace ) {
						if ( ! ( p in prop ) ) {
							prop[ p ] = replace[ p ];
						}
					}
				}
			}
			for ( name in prop ) {
				val = prop[ name ];
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}
				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}
				if ( isElement && ( name === "height" || name === "width" ) ) {
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";
						} else {
							this.style.zoom = 1;
						}
					}
				}
			}
			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}
			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];
				if ( rfxtypes.test( val ) ) {
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}
				} else {
					parts = rfxnum.exec( val );
					start = e.cur();
					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}
						e.custom( start, end, unit );
					} else {
						e.custom( start, val, "" );
					}
				}
			}
			return true;
		}
		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}
		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}
			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}
			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}
function clearFxNow() {
	fxNow = undefined;
}
function genFx( type, num ) {
	var obj = {};
	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});
	return obj;
}
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});
jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
		opt.old = opt.complete;
		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};
		return opt;
	},
	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
		}
	},
	timers: [],
	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;
		options.orig = options.orig || {};
	}
});
jQuery.fx.prototype = {
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}
		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}
		var parsed,
			r = jQuery.css( this.elem, this.prop );
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;
		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}
		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				if ( self.options.hide ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.start );
				} else if ( self.options.show ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.end );
				}
			}
		};
		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;
		if ( dataShow !== undefined ) {
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}
		jQuery( this.elem ).show();
	},
	hide: function() {
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;
		this.custom( this.cur(), 0 );
	},
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;
		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();
			options.animatedProperties[ this.prop ] = true;
			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}
			if ( done ) {
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}
				if ( options.hide ) {
					jQuery( elem ).hide();
				}
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}
				complete = options.complete;
				if ( complete ) {
					options.complete = false;
					complete.call( elem );
				}
			}
			return false;
		} else {
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			this.update();
		}
		return true;
	}
};
jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},
	interval: 13,
	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},
	speeds: {
		slow: 600,
		fast: 200,
		_default: 400
	},
	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},
		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
	if ( prop.indexOf( "margin" ) ) {
		jQuery.fx.step[ prop ] = function( fx ) {
			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
		};
	}
});
if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
function defaultDisplay( nodeName ) {
	if ( !elemdisplay[ nodeName ] ) {
		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();
		if ( display === "none" || display === "" ) {
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}
			body.appendChild( iframe );
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}
			elem = iframeDoc.createElement( nodeName );
			iframeDoc.body.appendChild( elem );
			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}
		elemdisplay[ nodeName ] = display;
	}
	return elemdisplay[ nodeName ];
}
var getOffset,
	rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;
if ( "getBoundingClientRect" in document.documentElement ) {
	getOffset = function( elem, doc, docElem, box ) {
		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}
		var body = doc.body,
			win = getWindow( doc ),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;
		return { top: top, left: left };
	};
} else {
	getOffset = function( elem, doc, docElem ) {
		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;
		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}
			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;
			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;
				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}
				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}
			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}
			prevComputedStyle = computedStyle;
		}
		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}
		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}
		return { top: top, left: left };
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}
	var elem = this[0],
		doc = elem && elem.ownerDocument;
	if ( !doc ) {
		return null;
	}
	if ( elem === doc.body ) {
		return jQuery.offset.bodyOffset( elem );
	}
	return getOffset( elem, doc, doc.documentElement );
};
jQuery.offset = {
	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;
		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}
		return { top: top, left: left };
	},
	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );
		if ( position === "static" ) {
			elem.style.position = "relative";
		}
		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}
		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}
		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}
		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};
jQuery.fn.extend({
	position: function() {
		if ( !this[0] ) {
			return null;
		}
		var elem = this[0],
		offsetParent = this.offsetParent(),
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},
	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );
	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );
			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					jQuery.support.boxModel && win.document.documentElement[ method ] ||
						win.document.body[ method ] :
					elem[ method ];
			}
			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);
			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	var clientProp = "client" + name,
		scrollProp = "scroll" + name,
		offsetProp = "offset" + name;
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};
	jQuery.fn[ type ] = function( value ) {
		return jQuery.access( this, function( elem, type, value ) {
			var doc, docElemProp, orig, ret;
			if ( jQuery.isWindow( elem ) ) {
				doc = elem.document;
				docElemProp = doc.documentElement[ clientProp ];
				return jQuery.support.boxModel && docElemProp ||
					doc.body && doc.body[ clientProp ] || docElemProp;
			}
			if ( elem.nodeType === 9 ) {
				doc = elem.documentElement;
				if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
					return doc[ clientProp ];
				}
				return Math.max(
					elem.body[ scrollProp ], doc[ scrollProp ],
					elem.body[ offsetProp ], doc[ offsetProp ]
				);
			}
			if ( value === undefined ) {
				orig = jQuery.css( elem, type );
				ret = parseFloat( orig );
				return jQuery.isNumeric( ret ) ? ret : orig;
			}
			jQuery( elem ).css( type, value );
		}, type, value, arguments.length, null );
	};
});
window.jQuery = window.$ = jQuery;
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}
})( window );
/** File: /common/javascripts/jquery.wp.js **/
(function ($) {
  
  /**
   * Determines if an object is empty based on it's own properties only.  This does
   * not check the prototype chain to see if it has any data.
   */
  $.isEmptyObject = function (ob) {
    for (var i in ob) {
      if (ob.hasOwnProperty(i)) {
        return false;
      }
    }
    return true;
  };
  $.expr[':'].regex = function(elem, index, match) {
    var matchParams = match[3].split(',');
    var validLabels = /^(data|css):/;
    var attr = {
      method: matchParams[0].match(validLabels) ? matchParams[0].split(':')[0] : 'attr',
      property: matchParams.shift().replace(validLabels,'')
    };
    var regex = new RegExp(matchParams.join('').replace(/^\s+|\s+$/g,''), 'ig');
    return regex.test(jQuery(elem)[attr.method](attr.property));
  }
})(jQuery);
/** File: /common/javascripts/jquery_cookie.js **/
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
/** File: /common/javascripts/json2.js **/
/*
    http://www.JSON.org/json2.js
    2009-09-29
    Public Domain.
    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
    See http://www.JSON.org/js.html
    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html
    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
    This file creates a global JSON object containing two methods: stringify
    and parse.
        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.
            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.
            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.
            This method produces a JSON text from a JavaScript value.
            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value
            For example, this would serialize Dates as ISO strings.
                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        return n < 10 ? '0' + n : n;
                    }
                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };
            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.
            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.
            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.
            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.
            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.
            Example:
            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.
            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.
            Example:
            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });
            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });
    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/
/*jslint evil: true, strict: false */
/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/
if (!this.JSON) {
    this.JSON = {};
}
(function () {
    function f(n) {
        return n < 10 ? '0' + n : n;
    }
    if (typeof Date.prototype.toJSON !== 'function') {
        Date.prototype.toJSON = function (key) {
            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };
        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;
    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }
    function str(key, holder) {
        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];
        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }
        switch (typeof value) {
        case 'string':
            return quote(value);
        case 'number':
            return isFinite(value) ? String(value) : 'null';
        case 'boolean':
        case 'null':
            return String(value);
        case 'object':
            if (!value) {
                return 'null';
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {
                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }
    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {
            var i;
            gap = '';
            indent = '';
            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }
            } else if (typeof space === 'string') {
                indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }
            return str('', {'': value});
        };
    }
    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {
            var j;
            function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }
            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                j = eval('(' + text + ')');
                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }
            throw new SyntaxError('JSON.parse');
        };
    }
}());
/** File: /common/javascripts/common.js **/
/**
 * Crockford's object creation method to support prototypal inheritence.
 */
if (typeof Object.create !== 'function') {
  Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
if (!window.console) {
  window.console = {};
}
$.each("log debug error warn time timeEnd profile profileEnd trace group groupEnd dir dirxml".split(" "), function () {
  if ( window.console[this] === undefined ) {
    window.console[this] =  function () {};
  }
});
whitepages = function() {};
whitepages.version = '1.0';
whitepages.common = function() {};
whitepages.vendor = function() {};
if (!window.console) {
  window.console = {};
}
$.each("log debug error warn time timeEnd profile profileEnd trace group groupEnd dir dirxml".split(" "), function () {
  if ( window.console[this] === undefined ) {
    window.console[this] =  function () {};
  }
});
/**
 * getCookieData gets the value from a cookie name and key
 *
 * @returns {string} the value of the cookie
 */
whitepages.common.getCookieData = function(name, key)
{
  var c = document.cookie.split('; ');
  var i,nvp,j;
  for ( i=0, cl = c.length; i < cl; i++ ) {
    if ( c[i].indexOf(name) > -1 ) {
      nvp = c[i].split('=')[1].split('%26');  // Get the name value pairs
      for ( j=0, nl=nvp.length; j<nl; j++ ) {
        if ( nvp[j].split('%3D')[0] == key ) { return nvp[j].split('%3D')[1]; }
      }
    }
  }
  return '';  /** WP: No cookie with that name */
}; /** WP: end getCookieData */
/**
 * deleteCookieData clear cookie data
 */
whitepages.common.deleteCookieData = function(name, domain)
{
  domain = domain || whitepages.page.data.wildcard_cookie_domain;
  $.cookie(name, null, {domain: domain});
};
/**
 * setCookieData sets a key value pair to a named cookie
 */
whitepages.common.setCookieData = function(name, key, value, pExpires, domain)
{
	var date = new Date();
  var path = '; path=/';
  var cookies = document.cookie.split('; ');
  var cookie_val = '';
  var cookie_domain = (domain && domain != '') ? domain : false
  var hasKey  = false;
  var i = 0;
  var pairs = [];
  var expires = '';
  if (!pExpires) {
    switch (name) {
      case 'wp_perm':
        date.setTime(date.getTime() + (360*24*60*60*1000));
        expires = '; expires=' + date.toGMTString();
        break;
      case 'wp_interstitial':
        date.setTime(date.getTime() + (24*60*60*1000));
        expires = '; expires=' + date.toGMTString();
        break;
      default:
        expires = '';
        break;
    }
  }
  else
  {
    date.setTime(date.getTime() + pExpires*1000);
    expires = '; expires=' + date.toGMTString();
  }
  cookie_domain_for_output = '';
  if (cookie_domain) {
    cookie_domain_for_output = "; domain=" + cookie_domain;
  } else if (whitepages.page.data.wildcard_cookie_domain != null) {
    cookie_domain_for_output = "; domain=" + whitepages.page.data.wildcard_cookie_domain;
  }
  for (i = 0, cl = cookies.length; i < cl; i++) {
    if (cookies[i].indexOf(name + '=') != -1 ) {
      pairs = cookies[i].split('=')[1].split('%26');
      break;
    }
  }
  for (i = 0, pl = pairs.length; i < pl; i++) {
    if (pairs[i].split('%3D')[0] == key) {
      pairs[i] = key + '%3D' + value;
      hasKey = true;
      break;
    }
  }
  if (!hasKey) {
    pairs[pairs.length] = key + '%3D' + value;
  }
  cookie_val = '='
  for (i = 0, pl = pairs.length; i < pl; i++) {
    cookie_val += pairs[i] + '%26';
  }
  cookie_val = cookie_val.replace(/%26$/, '');
  document.cookie = name + cookie_val + expires + path + cookie_domain_for_output;
}
/*
 * cookies_disabled
 *
 * DESCRIPTION: This method checks if cookies are disabled
 *
 * RETURNS:     boolean
 *
 */
whitepages.common.cookies_disabled = function() {
  document.cookie = "wp_cookies_enabled=true;";
  var results = document.cookie.match ( '(^|;) ?wp_cookies_enabled=([^;]*)(;|$)' );
  if (!results) {
    return true;
  }
  else {
    document.cookie = "wp_cookies_enabled=; expires=01/01/2001 00:00:00;";
  }
  return false;
}
/**
 * dump takes a basic JS object and dumps the key's and values out to a string
 *
 * @param pObj {object} is the object you would like to see analyzed.
 * @return {string} a slightly formatted string that shows key value pairs
 */
whitepages.common.dump = function(pObj)
{
  var dump = ''
  for (x in pObj) {
    dump += x + ': ' + pObj[x] + '\n';
  }
  return dump;
}
/**
 * setOriginPage sets the current page into a cookie to be used in "back" links from certain pages
 */
whitepages.common.setOriginPage = function()
{
  whitepages.common.setCookieData('wp_session', 'origin_url', escape(escape(location.href)));
  return true;
}
/** WP:
 * get_rdb_cookie
 *
 * Array returned contains hexadecimal values. Use hex2dec() to convert.
 *
 * BUG: The RDB cookie does not have a different name for each stage (qa, dev, production)
 *      but one does exists in every whitepages.com subdomain (qa.whitpages, dev.whitepages)
 *      so even though the perl code will write to the cookie for the correct domain
 *      the javascript will not necessarily read from the correct one.
 *      One solution for this is to rename the cookie to include a stage name but that
 *      would require significant changes.
 */
whitepages.common.get_rdb_cookie = function(stage)
{
  var name = 'RDB';
  var nameEQ = name + "=";
  var ca = document.cookie.split(';');
  for(var i=0;i < ca.length;i++) {
    var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1,c.length);
    if ( c.indexOf(nameEQ) == 0 ) {
      /** WP: RDB Cookie
                # 0   Original string
        (.{4})  # 1   c802
        (.{6})  # 2   zip
        (.{4})  # 3   zip4
        (.{4})  # 4   country
        (.{2})  # 5   gender
        (.{2})  # 6   primary_usage
        (.{2})  # 7   income_low
        (.{2})  # 8   income_high
        (.{2})  # 9   age_low or business_size_low
        (.{2})  # 10  age_high or business_size_high
        (.{1})  # 11  user trait 0 connection_type
        (.{1})  # 12  user trait 0 purchasing power
        (.{1})  # 13  user trait 1 home_owner + renter + lives_in_apartment + lives_in_house
        (.{1})  # 14  user trait 1 married + single + home > 0k + home > 100k
        (.{1})  # 15  user trait 2 home > 250k + home > 500k + home > 750k + home > 1M
        (.{1})  # 16  user trait 2 home > median + home < median + residency 0-6mo + residency 7-12mo
        (.{1})  # 17  user trait 3 residency 13-24mo + residency > 5y + residency > 10y + residency > 20y
        (.{1})  # 18  user trait 3 children + census pop > 100k + census pop > 250k + census females > males
        (.{8})  # 19  user trait 4-7
        (.{3})  # 20  carrier
        (.{5})  # 21  birth_year
      */
            var rdb_fields = [];
            var rdb_regex =
              /(.{4})(.{6})(.{4})(.{4})(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})(.{1})(.{1})(.{1})(.{1})(.{1})(.{1})(.{1})(.{1})(.{8})(.{3})(.{5})/;
            rdb_fields = c.substring( nameEQ.length,c.length ).match( rdb_regex );
            if (rdb_fields) {
                return rdb_fields;
            }
    }
  }
  return null;
};
/** WP: Decimal to Hexadecimal */
whitepages.common.dec2hex = function(dec)
{
  return dec.toString(16);
};
/** "WP: Hexadecimal to Decimal */
whitepages.common.hex2dec = function(hex)
{
  return parseInt(hex,16);
};
/** WP
* Do not display empty Omniture GIF in the layout --- EXPANDED!
* This must be called after the DOM is ready to accept it, for Propietary sites
* it must be called from within the pre-compiled common.js (one dir down) after
* s_wpn has loaded. For all other sites it's called immediately
*/
whitepages.common.hide_omniture_tracking_img = function(imagename) {
  try {
    var omniname = 's_i_' + imagename;
    var img = document.getElementsByName(omniname);
    if (img.length == 1) {
      /** WP: Hide it from the layout */
      img[0].style.position = 'absolute';
      img[0].style.top = '0';
      img[0].style.left = '0';
    }
  }
  catch (err) {
    /** WP: debug
    alert(err.description);
    */
  }
};
whitepages.common.open_window = function(url, height, width, darken_bg) {
  var left, top, settings;
  if (typeof window.screenLeft != "undefined") {
    left = window.screenLeft;
    top = window.screenTop;
  } else if (typeof window.screenX != "undefined") {
    left = window.screenX;
    top = window.screenY;
  }
  left += (document.documentElement.clientWidth  -  width) / 2;
  top  += (document.documentElement.clientHeight - height) / 2
  win_settings =  "width=" + width + ",height=" + height;
  win_settings += ",left=" + left  + ",top="    + top;
  var popup = window.open(url, 'wp_popup', win_settings);
  if (typeof darken_bg == "undefined" || darken_bg) {
    var dark_cover = document.createElement('div');
    dark_cover['id'] = 'darkCover';
    dark_cover.setAttribute('style', [
      'position:absolute;',
      'top:0px;',
      'left:0px;',
      'padding-right:0px;',
      'padding-bottom:0px;',
      'background-color:#000000;',
      'opacity:0.5;', //standard-compliant browsers
      '-moz-opacity:0.5;',           // old Mozilla
      'filter:alpha(opacity=0.5);',  // IE
      'z-index:10000;',
      'width:100%;',
      'height:100%;'
    ].join(''));
    dark_cover.onclick = function() {
      document.body.removeChild(dark_cover);
    }
    if (popup) {
      var timer = setInterval(function() {
        if (popup.closed) {
          clearInterval(timer);
          document.body.removeChild(dark_cover);
        }
      }, 1000);
    }
    document.body.appendChild(dark_cover);
    if (typeof jQuery != "undefined") {
      jQuery(dark_cover).hide().fadeIn();
    }
  }
  return popup;
}
whitepages.common.track_third_party_login_click = function(elm){
  s_wpn.linkTrackVars = 'events';
  s_wpn.linkTrackEvents = 'event24';
  s_wpn.events = 'event24';
  s_wpn.tl(elm, 'e');
}
whitepages.common.track_business_submit = function()
{
  s_wpn.linkTrackVars = 'events';
  s_wpn.linkTrackEvents = 'event14';
  s_wpn.events = 'event14';
  s_wpn.tl(document.getElementById('omni_business_tracking_link'), 'e');
};
/*
 * Sends a xhr to the external_link_metric controller to log the click
 * of a business search listing website link.
 */
whitepages.common.send_click_to_external_link_metric = function(caller, listing_id, provider, bs_state_token, click_type, wp_prem_campaign_id){
  jQuery.get('/external_link_metric',
    {"listing_id": listing_id, "provider": provider, "t": bs_state_token,
     "click_target": caller.href, "click_type": click_type, "wp_prem_campaign_id": wp_prem_campaign_id});
};
whitepages.common.open_help = function(url) {
  window.open(url,'_blank', 'width=1020,height=600,scrollbars=1,toolbar=yes,menubar=yes,location=yes,resizeable=yes');
}
var common_ad;
if (location.pathname == 'help') {
  self.name = 'WhitepagesHelp';
} else {
  self.name = 'WhitepagesMain';
}
whitepages.common.chunk = function(array, callback, afterFinished, options) {
	options = jQuery.extend({sliceSize: 5, interval: 5}, options);
	var sliceSize       = options.sliceSize;
	var timeoutInterval = options.interval;
	if ( array.length > 0 ){
		callback(array.slice(0, sliceSize));
		setTimeout(function(){
			whitepages.common.chunk(array.slice(sliceSize), callback, afterFinished);
		}, timeoutInterval);
	}
	else {
		jQuery.isFunction(afterFinished) && afterFinished(array);
	}
}
/*
 * Submits person search form by going to SEO friendly url: /name/:firstname/:name/:location
 */
whitepages.common.submit_people_search = function(location, name, firstname, extra_params) {
	location = location || 'location';
  name = name || 'name';
  firstname = firstname || 'firstname';
  var values = $.map([firstname, name, location], function(el, idx) {
		return $('#' + el).val()
      .replace(/^[\W_]+|[\W_]+$/g, '')
      .replace(/[\W_]+/g, '-')
      .replace(/^$/, 'a-z')
      .toLowerCase();
  });
  if (values[2] === 'a-z') {
    values.splice(2,1);
  }
	extra_params ? parameters = ('?' + extra_params) : parameters = '';
  window.location = '/name/' + values.join('/') + parameters;
  return false;
}
whitepages.common.toggle_additional_member_listings = function(that) {
  $(that).text( $(that).text() == 'More' ? 'Less' : 'More' );
  $('.other_member_listings ul').each(function() {
    $(this).find('li').slice(5).toggleClass('hidden');
  });
}
/** File: /common/javascripts/autocomplete.js **/
jQuery.autocomplete = function(input, options) {
  var me = this;
  var $input = $(input).attr("autocomplete", "off");
  if (options.inputClass) {
    $input.addClass(options.inputClass);
  }
  var results = document.createElement("div");
  var $results = $(results).hide().addClass(options.resultsClass).css("position", "absolute");
  if( options.width > 0 ) {
    $results.css("width", options.width);
  }
  $("body").append(results);
  input.autocompleter = me;
  var timeout = null;
  var prev = "";
  var active = -1;
  var cache = {};
  var keyb = false;
  var hasFocus = false;
  var lastKeyPressCode = null;
  var mouseDownOnSelect = false;
  var hidingResults = false;
  function flushCache(){
    cache = {};
    cache.data = {};
    cache.length = 0;
  };
  flushCache();
  if( options.data != null ){
    var sFirstChar = "", stMatchSets = {}, row = [];
    if( typeof options.url != "string" ) {
      options.cacheLength = 1;
    }
    for( var i=0; i < options.data.length; i++ ){
      row = ((typeof options.data[i] == "string") ? [options.data[i]] : options.data[i]);
      if( row[0].length > 0 ){
        sFirstChar = row[0].substring(0, 1).toLowerCase();
        if( !stMatchSets[sFirstChar] ) stMatchSets[sFirstChar] = [];
        stMatchSets[sFirstChar].push(row);
      }
    }
    for( var k in stMatchSets ) {
      options.cacheLength++;
      addToCache(k, stMatchSets[k]);
    }
  }
  $input
  .keydown(function(e) {
    lastKeyPressCode = e.keyCode;
    switch(e.keyCode) {
      case 38: // up
        e.preventDefault();
        moveSelect(-1);
        break;
      case 40: // down
        e.preventDefault();
        moveSelect(1);
        break;
      case 9:  // tab
        if( selectCurrent() ){
          $('input:eq(' + ($('input').index(this) + 1) + ')').focus();
          e.preventDefault();
        }
        break;
      case 13: // return
        if( selectCurrent() ){
          e.preventDefault();
        }
        break;
      default:
        active = -1;
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(function(){onChange();}, options.delay);
        break;
    }
  })
  .focus(function(){
    hasFocus = true;
  })
  .blur(function() {
    hasFocus = false;
    if (!mouseDownOnSelect) {
      hideResults();
    }
  });
  hideResultsNow();
  function onChange() {
    if( lastKeyPressCode == 46 || (lastKeyPressCode > 8 && lastKeyPressCode < 32) ) return $results.hide();
    var v = $input.val();
    if (v == prev) return;
    prev = v;
    var numLetters = v.replace(/[^a-z]/gi, '').length;
    if (numLetters >= options.minChars) {
      requestData(v);
    } else {
      $results.hide();
    }
  };
  function moveSelect(step) {
    var lis = $("li", results);
    if (!lis) return;
    active += step;
    if (active < 0) {
      active = 0;
    } else if (active >= lis.size()) {
      active = lis.size() - 1;
    }
    lis.removeClass("autocomplete_over");
    $(lis[active]).addClass("autocomplete_over");
  };
  function selectCurrent() {
    var li = $("li.autocomplete_over", results)[0];
    if (!li) {
      var $li = $("li", results);
      if (options.selectOnly) {
        if ($li.length == 1) li = $li[0];
      } else if (options.selectFirst) {
        li = $li[0];
      }
    }
    if (li) {
      selectItem(li);
      return true;
    } else {
      return false;
    }
  };
  function selectItem(li) {
    if (!li) {
      li = document.createElement("li");
      li.extra = [];
      li.selectValue = "";
    }
    var v = $.trim(li.selectValue ? li.selectValue : li.innerHTML);
    input.lastSelected = v;
    prev = v;
    $results.html("");
    $input.val(v);
    hideResultsNow();
    if (options.onItemSelect) {
      setTimeout(function() { options.onItemSelect(li) }, 1);
    }
  };
  function createSelection(start, end){
    var field = $input.get(0);
    if( field.createTextRange ){
      var selRange = field.createTextRange();
      selRange.collapse(true);
      selRange.moveStart("character", start);
      selRange.moveEnd("character", end);
      selRange.select();
    } else if( field.setSelectionRange ){
      field.setSelectionRange(start, end);
    } else {
      if( field.selectionStart ){
        field.selectionStart = start;
        field.selectionEnd = end;
      }
    }
    field.focus();
  };
  function showResults() {
    var pos = findPos(input);
    if (options.width > 0) {
      var iWidth = options.width;
    } else {
      var iWidth = $input.width();
      
      iWidth += parseInt($input.css('paddingLeft')) + parseInt($input.css('paddingRight'));
    }
    
    $results.css('borderColor', $input.css('border-left-color'));
    
    $results.css({
      width: parseInt(iWidth) + "px",
      top: (pos.y + input.offsetHeight + options.offsetY) + "px",
      left: (pos.x + options.offsetX) + "px",
      'z-index': 4000
    }).show();
  };
  function hideResults() {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(hideResultsNow, 200);
  };
  function hideResultsNow() {
    if (hidingResults) {
      return;
    }
    hidingResults = true;
  
    if (timeout) {
      clearTimeout(timeout);
    }
    
    var v = $input.val();
    
    if ($results.is(":visible")) {
      $results.hide();
    }
    
    if (options.mustMatch) {
      if (!input.lastSelected || input.lastSelected != v) {
        selectItem(null);
      }
    }
    hidingResults = false;
  };
  function receiveData(q, data) {
    if (data) {
      results.innerHTML = "";
      if( !hasFocus || data.length == 0 ) return hideResultsNow();
      if ($.browser.msie) {
        $results.append(document.createElement('iframe'));
      }
      appendHeader();
      
      results.appendChild(dataToDom(data));
      showResults();
    } else {
      options.no_results_string = q;
      hideResultsNow();
    }
  };
  function parseData(data) {
    if (!data) return null;
    var parsed = [];
    var rows = data.split(options.lineSeparator);
    for (var i=0; i < rows.length; i++) {
      var row = $.trim(rows[i]);
      if (row) {
        parsed[parsed.length] = row.split(options.cellSeparator);
      }
    }
    return parsed;
  };
  function appendHeader() {
    if (options.header) {
      $results.append("<p>" + options.header + "</p>");
    }            
  }
  
  function dataToDom(data) {
    var ul = document.createElement("ul");
    var num = data.length;
    if( (options.maxItemsToShow > 0) && (options.maxItemsToShow < num) ) num = options.maxItemsToShow;
    for (var i=0; i < num; i++) {
      var row = data[i];
      if (!row) continue;
      var li = document.createElement("li");
      if (options.formatItem) {
        li.innerHTML = options.formatItem(row, i, num);
        li.selectValue = row[0];
      } else {
        li.innerHTML = row[0];
        li.selectValue = row[0];
      }
      var extra = null;
      if (row.length > 1) {
        extra = [];
        for (var j=1; j < row.length; j++) {
          extra[extra.length] = row[j];
        }
      }
      li.extra = extra;
      ul.appendChild(li);
      
      $(li).hover(
        function() { $("li", ul).removeClass("autocomplete_over"); $(this).addClass("autocomplete_over"); active = $("li", ul).indexOf($(this).get(0)); },
        function() { $(this).removeClass("autocomplete_over"); }
      ).click(function(e) { 
        e.preventDefault();
        e.stopPropagation();
        selectItem(this)
      });
      
    }
    $(ul).mousedown(function() {
      mouseDownOnSelect = true;
    }).mouseup(function() {
      mouseDownOnSelect = false;
    });
    return ul;
  };
  function requestData(q) {
    if (!options.matchCase) q = q.toLowerCase();
    var data = options.cacheLength ? loadFromCache(q) : null;
    if (data) {
      receiveData(q, data);
    } else if( (typeof options.url == "string") && (options.url.length > 0) ){
      if (options.no_results_string) {
        var no_results_regex = new RegExp('^' + options.no_results_string);
        if (q.match(no_results_regex))
        {
          return false;
        }
      }
      $.get(makeUrl(q), function(data) {
        data = parseData(data);
        if (data && data.length < options.maxItemsReturned)
        {
          addToCache(q, data);
        }
        receiveData(q, data);
      });
    }
  };
  function makeUrl(q) {
    var sep = options.url.indexOf('?') == -1 ? '?' : '&'; 
    var url = options.url + sep + "q=" + encodeURI(q);
    for (var i in options.extraParams) {
      url += "&" + i + "=" + encodeURI(options.extraParams[i]);
    }
    return url;
  };
  function loadFromCache(q) {
    if (!q) return null;
    if (cache.data[q]) return cache.data[q];
    if (options.matchSubset) {
      for (var i = q.length - 1; i >= options.minChars; i--) {
        var qs = q.substr(0, i);
        var c = cache.data[qs];
        if (c) {
          var csub = [];
          for (var j = 0; j < c.length; j++) {
            var x = c[j];
            var x0 = x[0];
            if (matchSubset(x0, q)) {
              csub[csub.length] = x;
            }
          }
          return csub;
        }
      }
    }
    return null;
  };
  function matchSubset(s, sub) {
    if (!options.matchCase) s = s.toLowerCase();
    var i = s.indexOf(sub);
    if (i == -1) return false;
    return i == 0 || options.matchContains;
  };
  this.flushCache = function() {
    flushCache();
  };
  this.setExtraParams = function(p) {
    options.extraParams = p;
  };
  this.findValue = function(){
    var q = $input.val();
    if (!options.matchCase) q = q.toLowerCase();
    var data = options.cacheLength ? loadFromCache(q) : null;
    if (data) {
      findValueCallback(q, data);
    } else if( (typeof options.url == "string") && (options.url.length > 0) ){
      $.get(makeUrl(q), function(data) {
        data = parseData(data)
        addToCache(q, data);
        findValueCallback(q, data);
      });
    } else {
      findValueCallback(q, null);
    }
  }
  function findValueCallback(q, data){
    var num = (data) ? data.length : 0;
    var li = null;
    for (var i=0; i < num; i++) {
      var row = data[i];
      if( row[0].toLowerCase() == q.toLowerCase() ){
        li = document.createElement("li");
        if (options.formatItem) {
          li.innerHTML = options.formatItem(row, i, num);
          li.selectValue = row[0];
        } else {
          li.innerHTML = row[0];
          li.selectValue = row[0];
        }
        var extra = null;
        if( row.length > 1 ){
          extra = [];
          for (var j=1; j < row.length; j++) {
            extra[extra.length] = row[j];
          }
        }
        li.extra = extra;
      }
    }
    if( options.onFindValue ) setTimeout(function() { options.onFindValue(li) }, 1);
  }
  function addToCache(q, data) {
    if (!data || !q || !options.cacheLength) return;
    if (!cache.length || cache.length > options.cacheLength) {
      flushCache();
      cache.length++;
    } else if (!cache[q]) {
      cache.length++;
    }
    cache.data[q] = data;
  };
  function findPos(obj) {
    var curleft = obj.offsetLeft || 0;
    var curtop = obj.offsetTop || 0;
    while (obj = obj.offsetParent) {
      curleft += obj.offsetLeft
      curtop += obj.offsetTop
    }
    return {x:curleft,y:curtop};
  }
}
jQuery.fn.autocomplete = function(url, options, data) {
  options = options || {};
  options.url = url;
  options.data = ((typeof data == "object") && (data.constructor == Array)) ? data : null;
  
  options.no_results_string = null;
  options = $.extend({
    inputClass: "autocomplete_input",
    resultsClass: "autocomplete_results",
    lineSeparator: "\n",
    cellSeparator: "|",
    minChars: 3,
    delay: 150,
    matchCase: 0,
    matchSubset: 1,
    matchContains: 0,
    cacheLength: 500,
    mustMatch: 0,
    extraParams: {},
    selectFirst: false,
    selectOnly: false,
    maxItemsToShow: 14,
    width: 0,
    offsetX: 0,    
    offsetY: 0,    
    maxItemsReturned: 100, // Maximum items returned from the server when the
    header: null  // Optional header to show at the top of the results
  }, options);
  options.width = parseInt(options.width, 10);
  this.each(function() {
    var input = this;
    new jQuery.autocomplete(input, options);
  });
  return this;
}
jQuery.fn.autocompleteArray = function(data, options) {
  return this.autocomplete(null, options, data);
}
jQuery.fn.indexOf = function(e){
  for( var i=0; i<this.length; i++ ){
    if( this[i] == e ) return i;
  }
  return -1;
};
/** File: /common/javascripts/ui.js **/
if (typeof(whitepages.ui) == 'undefined') { whitepages.ui = function() {}; }
whitepages.ui.show_div = function(div) {
  $('.shown_div').hide();
  $('#body').unbind();
  fulldiv = '#' + div;
  $('#body').bind('click', function() {
      if ($(fulldiv).css('display') == 'none') {
        $(fulldiv).show();
      } else {
        $(fulldiv).hide();
        $('#body').unbind();
      }
    });
};
whitepages.ui.add_child = function(from, to) {
  var cloned = $(from).clone();
  $(from).removeClass();
  cloned.insertBefore(to);
};
whitepages.ui.listingToSend = function(listing) {
  var content = listing.split('<br />');
  var display = '';
  for ( i=0; i < content.length; i++ ) {
    if (content[i] != '') {
      display += content[i] + "\n";
    }
  }
  $("#message_text").val( display );
};
/*
 *=== Description
 *  send_message_to_listing is used to send email or sms messages to a listing.
 *  This is to be attached to the submit event of the form element.
 *=== Parameters
 * form_el (DomElementReference): a referance to the form element this method is attached to.
 *
 */
whitepages.ui.send_message_to_listing = function(form_el){
  var action_path = $(form_el).attr('action');
  var q_params = $(form_el).serialize(); /* this will create a name/value query string from the input elements in the form */
  $(form_el).find(':input').attr('disabled','disabled')
  $.post(action_path + "?" + q_params,'', function(data){
      $(".contact_cl_popup_content").replaceWith(data)
        });
};
whitepages.ui.char_remaining = function(total, field) {
  if (document.getElementById(field)) {
    var sig = document.getElementById(field).value;
    var char_left = $("#char_count").html(); // the input-field, where the chars left will be shown
    if(sig.length > total) {
      var x = sig.substring(0, total);
      document.getElementById(field).value = x;
      char_left = 0;
      setTimeout("whitepages.ui.char_remaining('" + total + "', '" + field + "')",100);
    } else {
      $("#char_count").text( total - sig.length );
      setTimeout("whitepages.ui.char_remaining('" + total + "', '" + field + "')",100);
    }
    if (document.getElementById('char_count')) {
      if (char_left > 0) {
        $("#char_count").css( "color", "#333" );
        $("#red_alert").css( "color", "#333" );
      } else {
        $("#char_count").css( "color", "red" );
        $("#red_alert").css( "color", "red" );
      }
    }
  }
};
whitepages.ui.validateSelect = function(input_field, error_field) {
  var error = '';
  var errFld = $(error_field);
  var inpFld = $(input_field);
  if (input_field.value == '') {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("This is required.");
    error = 'true';
  } else {
    inpFld.removeClass('input_error_border');
    errFld.removeClass('error_on');
    errFld.html("");
    error = ''
  }
  return error;
};
whitepages.ui.validatePhone = function(input_field, error_field) {
  var error = '';
  var errFld = $(error_field);
  var inpFld = $(input_field);
  var stripped = input_field.value.replace(/[\(\)\.\-\ ]/g, '');
  if (input_field.value == '') {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("Cell Phone number is required.");
    error = 'true';
  } else if (stripped.match(/^0/)) {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("This looks like an international number - US only please.");
    error = 'true';
  } else if (!(stripped.length == 10) || isNaN(parseInt(stripped))) {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("Cell numbers must contain 10 digits.");
    error = 'true';
  } else {
    inpFld.removeClass('input_error_border');
    errFld.removeClass('error_on');
    errFld.html("");
    error = '';
  }
  return error;
};
whitepages.ui.validateName= function(input_field, error_field) {
  var error = '';
  var errFld = $(error_field);
  var inpFld = $(input_field);
  if (input_field.value == '') {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("This is required.");
    error = 'true';
  } else {
    inpFld.removeClass('input_error_border');
    errFld.removeClass('error_on');
    errFld.html("");
    error = ''
  }
  return error;
};
whitepages.ui.validateEmail = function(input_field, error_field) {
  var error = '';
  var errFld = $(error_field);
  var inpFld = $(input_field);
  var emailFilter = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
  if (input_field.value == '') {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("Email address is required.");
    error = 'true';
  } else if (emailFilter.test(input_field.value) != true) {
    inpFld.addClass('input_error_border');
    errFld.addClass('error_on');
    errFld.html("Email addresses must be formatted like this: name@place.abc.");
    error = 'true';
  } else {
    inpFld.removeClass('input_error_border');
    errFld.removeClass('error_on');
    errFld.html("");
    error = ''
  }
  return error;
};
whitepages.ui.validateText = function(input_field, error_field) {
  var error = '';
  var errFld = $(error_field);
  var inpFld = $(input_field);
  var stripped = input_field.value.replace(/[\s+][\n+][\r+]/g, '');
  if (stripped == '') {
    inpFld.addClass('input_error_border');
    $('#innerTextArea').addClass('text_error');
    errFld.addClass('error_on');
    errFld.html("This is required.");
    if ($('#scroll_cover')) {
      $('#scroll_cover').addClass('scroll_cover_error');
    }
    error = 'true';
  } else {
    inpFld.removeClass('input_error_border');
    $('#innerTextArea').removeClass('text_error');
    errFld.removeClass('error_on');
    errFld.html('');
    if ($('#scroll_cover')) {
      $("#scroll_cover").removeClass('scroll_cover_error');
    }
    error = '';
  }
  return error;
};
whitepages.ui.close_claim_example = function() {
  if ($('#claim_example_listing').css('display', 'block')) {
    $('#claim_example_listing').css('display','none')
  }
  return true;
};
/*
 * === Description
 * Fade the background color of an element
 *
 * === Parameters
 * [element_id] - The id of the element
 * [color] - Background color to fade to
 * [duration] - Time in milliiseconds to fade the element to opacity zero
 */
whitepages.ui.fade_element_bg = function(element_id, color, duration) {
  var duration = duration == '' ? 400 : duration;
  if (element_id == '') {
    return false;
  }
  $('#'+element_id).animate({ backgroundColor: color}, duration);
};
/*
 * === Description
 *	Slide an element until it is no longer visible
 *
 * === Parameters
 * [element_id] - The id of the element
 * [options] - Parameters to customize the slide and fade effects
 *   [slide]    - Determines whether to slide the element up or down
 *   [duration] - Time is takes for the slide animation to complete
 */
whitepages.ui.slide_element = function(element_id, options) {
  var direction = options.direction ? options.direction : 'up';
  var duration = options.duration ? options.duration : 400;
  if (direction == 'down') {
    $('#'+element_id).slideDown();
  } else {
    $('#'+element_id).slideUp();
  }
};
whitepages.ui.preload_images = function() {
  whitepages.ui.preload_image_cache = whitepages.ui.preload_image_cache || [];
  for (var i = 0, args_len = arguments.length, cacheImage; i < args_len; i++) {
    cacheImage = document.createElement('img');
    cacheImage.src = arguments[i];
    whitepages.ui.preload_image_cache.push(cacheImage);
  }
};
whitepages.ui.showModalDialog = function(url) {
  $('#wpn_ad_content_top_rail, #wpn_ad_content_right_rail').css('visibility', 'hidden');
  $('#modal_iframe').css('visibility', 'hidden')
                    .unbind('load')
                    .attr('src', url)
                    .bind('load', function() {
    this.style.visibility = 'visible';
  });
  $('#modal').show();
  return false;
};
whitepages.ui.closeModalDialog = function() {
  $('#modal').hide();
  $('#wpn_ad_content_top_rail, #wpn_ad_content_right_rail').css('visibility', '');
  return false;
};
/** File: /common/javascripts/popup.js **/
(function($, ui) {
  /*
   * anchor - that to which the pop-up points
   * content - a file name (for ajax), a div class/id (for inline), or a string
   * options is a hash containing:
   *   type - ajax/inline/string:
          ajax is a page to call,
          inline is a div on the page (class, id, or jquery selector),
          string is a string of text.
   *   position - the position of the box:
          caller - will attempt to place to the top right of the anchor, flipping horizontally & vertically if necessary
          center - will center in the browser window.
                   if centerReference is given, will horizontally center in that element instead.
                   it's best to not use the arrow for this type of positioning
          coords - will absolutely position the popup in the page given these coordinates.
   *   force_edge - the edge of the anchor to attempt to build the pop up off of
          none - a vertical flip will switch top and bottom edges
          top - a vertical flip will stay aligned with the top edge
   *   centerReference - jquery selector for the div you want the popup centered within (horizontally only). when using the 'center' position.
   *   arrow - does this box need an arrow : true/false. Default false.
   *   arrow_position - 'x_axis' | 'y_axis': Placement of arrow on the box. Default is y_axis, on the left & right side of the box.
   *   arrow_offset - how many pixels the arrow should move away from it's corner, Default 0
   *   close - should there be a close link in the top right corner : true/false. Default true.
   *   details - if type is ajax, then this is a callback that may manipulate the contents of the popup.
   *   staticLeft - distance from left of browser you want, a number.
   *   staticTop  - distance from top of browser you want, a number.
   *   image_path - path to find images otherwise will determine the page to be /four_one_one/images/ or /common/images/forms/
   *   ele_class - Add a class to the popup div
  */
  ui.Popup = function(anchor, content, options, doLoader) {
    this.anchor = $(anchor);
    this.content = content;
    this.options = $.extend({
      type: 'string',
      position: 'caller',
      centerReference: 'body',
      arrow: false,
      arrow_position: 'y_axis',
      arrow_offset: 0,
      close: true,
      details: null,
      staticLeft: 0,
      staticTop: 0,
      arrow_ext: 'png',
      ele_class: 'standard_box',
      loader: true,
      force_edge: 'none'
    }, options);
		this.convert_booleans();
    if (!(options && options.image_path)) {
      this.options.image_path = (options && options.site === '411') ?
        '/four_one_one/images/' : '/common/images/forms/';
      this.options.arrow_ext = 'gif';
    }
    
    this.popup = $(
      '<div id="wp_popup_outer" style="visibility: hidden; z-index: 4199;">'+
        '<div id="wp_popup" class="'+this.options.ele_class+'" style="position: relative;">'+
          '<div id="wp_popup_inner"></div>'+
        '</div>'+
      '</div>'
    );
    this.outer = $('#wp_popup', this.popup);
    this.inner = $('#wp_popup_inner', this.popup);
    ui.closePopup();
  };
	ui.Popup.prototype.convert_booleans = function() {
		if (!this.options.arrow || this.options.arrow.toString() != 'true') {
			this.options.arrow = false;
		} else {
			this.options.arrow = true;
		}
	};
  ui.Popup.prototype.runLoader =  function() {
    var loader_options = $.extend({}, this.options, { type: 'string', loader: false });
    this.loader = new ui.Popup(this.anchor, '<img src="/common/images/Loader_vertical_ani.gif" />', loader_options);
    this.loader.place();
  };
  ui.Popup.prototype.cancelLoader = function() {
    this.loader.popup.remove();
  };
  
  ui.Popup.prototype.place = function() {
    var self = this;
    this.options.loader && this.runLoader();
    this.options.arrow && this.addArrow();
    this.options.close && this.addClose();
    this.popup.appendTo('body');
    if (this.options.type == 'ajax') { // content MUST be the location of the file to load.
      $(this.inner).load(this.content, function(response, status, xhr) {
        $.isFunction(self.options.details) && self.options.details.call(this, response, status, xhr);
        self.options.loader && self.cancelLoader();
        self.position();
      });
    } else if (this.options.type == 'iframe') {
      $('<iframe src="' + this.content + '" width="330px" scroll="none" height="325px" frameborder="0" scrolling="none"></iframe>').wrap('<div id="popup_content">').parent().appendTo(this.inner);
      this.options.loader && this.cancelLoader();
      this.position();
    } else if (this.options.type == 'inline') { // content MUST be a jQuery selector that exists on the page.
      $(this.content).clone().show().wrap('<div id="popup_content">').parent().appendTo(this.inner);
      this.options.loader && this.cancelLoader();
      this.position();
    } else if (this.options.type == 'string') { // content WILL be whatever is
      $('<div id="popup_content">').html(this.content).appendTo(this.inner);
      this.options.loader && this.cancelLoader();
      this.position();
    }
  };
  
  ui.Popup.prototype.addArrow = function() {
    $('<div id="wp_popup_arrow"><img style="width: 0; height: 0;" /></div>').prependTo(this.popup);
  };
  
  ui.Popup.prototype.addClose = function() {
	if (this.options.ele_class == "details_box")
		$('<div class="close"><a href="#">X</a></div>')
	      .prependTo(this.outer)
	      .click(function() {
	        ui.closePopup();
	      });
	else
    	$('<div id="close_wp_popup">close</div>')
	      .prependTo(this.outer)
	      .click(function() {
	        ui.closePopup();
	      });
  }
  
  ui.Popup.prototype.position = function() {
    this.popup.css({position: 'absolute', left: 0, top: 0});
    
    var left = 0, top = 0, flippedHoriz = false, flippedVert = false;
    if (this.options.position == 'caller') {
      left = Math.round(this.anchor.offset().left + this.anchor.outerWidth());
      if ((left + this.popup.width() - $(window).scrollLeft() > $(window).width()) || this.options.forceFlipHoriz) {
        var newLeft = Math.round(this.anchor.offset().left - this.popup.width());
        if (newLeft >= 0) {
          left = newLeft;
          flippedHoriz = true;
        }
      }
      top = Math.round(this.anchor.offset().top - this.popup.height());
      if (top - $(window).scrollTop() < 0 || this.options.forceFlipVertical) {
        if (this.options.force_edge == 'top') {
          top = Math.round(this.anchor.offset().top);
        } else {
          top = Math.round(this.anchor.offset().top + this.anchor.outerHeight());
        }
        flippedVert = true;
      }
    } else if (this.options.position == 'coords') {
      left = this.options.staticLeft;
      top = this.options.staticTop;
    } else if (this.options.position === 'center') {
      var $center = $(this.options.centerReference);
      left = Math.max(0, ($center.outerWidth() - this.popup.width()) / 2 + $center.offset().left);
      top = Math.max(0, ($(window).height() - this.popup.height()) / 2 + $(window).scrollTop());
    }
    
    if (this.options.arrow) {
      var dir = 'l', side = 'b';
      if (this.options.arrow_position === 'y_axis') {
        dir = flippedVert ? 'u' : 'd';
        side = flippedHoriz ? 'r' : 'l';
      } else { // x_axis
        dir = flippedHoriz ? 'r' : 'l';
        side = flippedVert ? 't' : 'b';
      }
      this.positionArrow(dir, side, left, top);
    } else {
      this.popup.css({left: left, top: top, visibility: ''});
    }
  };
  ui.Popup.prototype.positionArrow = function(dir, side, popupLeft, popupTop) {
    var self = this;
    var popupWidth = this.popup.width(), popupHeight = this.popup.height();
    $('#wp_popup_arrow img')
      .hide()
      .bind('load', function() {
        var imgLeft = 0, imgTop = 0, imgWidth = $(this).width(), imgHeight = $(this).height();
        if (side === 't') {
          popupTop += imgHeight;
          imgTop -= imgHeight;
        } else if (side === 'b') {
          popupTop -= imgHeight;
          imgTop += popupHeight;
        } else if (side === 'l') {
          popupLeft += imgWidth;
          imgLeft -= imgWidth;
        } else if (side === 'r') {
          popupLeft -= imgWidth;
          imgLeft += popupWidth;
        }
        
        if (dir === 'l') {
          popupLeft -= self.options.arrow_offset;
          imgLeft += self.options.arrow_offset;
        } else if (dir === 'r') {
          popupLeft += self.options.arrow_offset;
          imgLeft += popupWidth - imgWidth - self.options.arrow_offset;
        } else if (dir === 'u') {
          popupTop -= self.options.arrow_offset;
          imgTop += self.options.arrow_offset;
        } else if (dir === 'd') {
          popupTop += self.options.arrow_offset;
          imgTop += popupHeight - imgHeight - self.options.arrow_offset;
        }
        
        var hadToReposition = false;
        if (self.options.position === 'caller') {
          if (side === 'l' && popupLeft + popupWidth - $(window).scrollLeft() > $(window).width()) {
            var newLeft = self.anchor.offset().left - popupWidth;
            if (newLeft >= 0) {
              popupLeft = newLeft;
              self.popup.css('left', popupLeft);
              self.positionArrow(dir, 'r', popupLeft, popupTop);
              hadToReposition = true;
            }
          } else if (side === 'b' && popupTop - $(window).scrollTop() < 0) {
            popupTop = self.anchor.offset().top + self.anchor.outerHeight();
            self.popup.css('top', popupTop);
            self.positionArrow(dir, 't', popupLeft, popupTop);
            hadToReposition = true;
          }
        }
        
        self.popup.css({left: popupLeft, top: popupTop});
        $(this).css({position: 'absolute', left: imgLeft, top: imgTop}).show();
        if (!hadToReposition) {
          self.popup.css('visibility', '');
        }
      })
      .css({width: 'auto', height: 'auto'})
      .attr('src', this.options.image_path + 'nimbleWindow_' + dir + side + '.' + this.options.arrow_ext);
  }
  ui.createPop = function(anchor, content, options) {
    new ui.Popup(anchor, content, options).place();
  }
  ui.closePopup = function() {
    $('#wp_popup_outer', document.body).remove();
  }
}(jQuery, whitepages.ui));
/** File: /common/javascripts/results.js **/
whitepages.results = function() {};
$(document).ready(function() {
  var categories_div_max_height = 180;
  var categories = $('#business_more_categories');
  if (categories) {
    if (categories.height() > categories_div_max_height) {
      categories.height(categories_div_max_height + 'px');
    }
  }
  var filters_div_max_height = 180;
  var filters = $('#biz_location_filters');
  if (filters) {
    if (filters.height() > filters_div_max_height) {
      filters.height(filters_div_max_height + 'px');
    }
  }
});
whitepages.results.sort_chosen = function(token)
{
  var selected = $('#s_b option:selected').val();
  if (selected != '')
  {
    var url = $.query.set('s_b', selected).set('page', '1').set('token', token);
    window.location.href = url.toString();
  }
}
whitepages.results.sort_chosen_business_track = function(sender)
{
 	var tracking_desc = sender[sender.selectedIndex].innerHTML;
  whitepages.analytics.track_click(this, {events:['general_interaction'], evars:{'listing_interaction_evar':'BS: Sort: ' + tracking_desc}});
}
whitepages.results.listingToSend = function(listing) {
  var content = listing.split('<br />');
  var display = '';
  for ( i=0; i < content.length; i++ ) {
    if (content[i] != '') {
      display += content[i] + "\n";
    }
  }
  $("#message_text").val( display );
}
whitepages.results.validateListingToSend = function(myForm) {
  var errors = '';
  if (myForm.to_phone) {
	  errors += whitepages.ui.validatePhone(myForm.to_phone, '#to_error_message');
	  errors += whitepages.ui.validatePhone(myForm.from_phone, '#from_error_message');
  } else {
	  errors += whitepages.ui.validateEmail(myForm.to_cell, '#to_error_message');
	  errors += whitepages.ui.validateEmail(myForm.from_cell, '#from_error_message');
  }
  errors += whitepages.ui.validateText(myForm.message_text, '#text_error_message');
  if (errors != '') {
    return false;
  }
  return true;
}
whitepages.results.sendListing = function(type, send_listing_url, thank_you_url) {
  var send = document.getElementById('send');
  var to_cell   = send.to_phone.value;
  var from_cell = send.from_phone.value;
  var message   = escape( send.message_text.value.replace(/\n/g,"\r\n") );
  var h = $("#sendListingDiv").height();
  var w = $("#sendListingDiv").width();
  $("#sendListingDiv").empty();
	$("#sendListingDiv").height(h).width(w);
  $("#wp_popup_inner").load(thank_you_url, '', function() {
    $("#listing_type").html( type );
    var url_and_data = send_listing_url.split('?');
    $.ajax({
      type: "GET",
      url: url_and_data[0],
      data: "to=" + to_cell + "&from=" + from_cell + "&message=" + message + url_and_data[1]
      });
  });
}
whitepages.results.save_contact_to_address_book = function(elm,search_id,upper,lower){
	var has_used_this = whitepages.common.getCookieData('wp_perm', 'has_used_save_contact_from_people_search');
	
	$(elm).fadeOut('fast',function(){
    $(elm).html('<span class="bold">Adding...</span>').fadeIn();
  }).attr('onclick','').blur()
	$.ajax({url: '/save_contacts/add', type: 'POST', data: {search_id: search_id ,upper: upper,lower: lower, s_cid: '09010002'},
		success: function(data, status){
			console.log(data);
			var json = $.parseJSON(data)
			if(json.result === 'success'){
			  $(elm).removeClass('saving').fadeOut('fast',function(){
			    $(elm).html('<span class="bold">Added</span> successfully!').fadeIn('fast')
			  }).attr('href','/hiya?s_cid=09010002#/labels_promo');
			  $('#view_contacts_disabled').hide();
			  $('#view_contacts').fadeIn('fast');		
			  whitepages.common.setCookieData('wp_perm', 'has_used_save_contact_from_people_search', true);
			}else{
			  $(elm).removeClass('saving').fadeOut('fast', function(){
			    $(elm).html('<span class="bold">Unable to add this contact at this time.</span>').fadeIn('fast')
			  });
			}
		}
	});
}
whitepages.results.sendBusinessListing = function(){
  var send_form = $('form#send');
  var action = send_form.attr('action');
  
  var data = {};
  data.to_cell = $('#to_cell_val').val();
  data.from_cell = $('#from_cell_val').val();
  data.to_email = $('#to_email_val').val();
  data.from_email = $('#from_email_val').val();
  data.uid = $('#uid').val();
  
  var h = $("#sendListingDiv").height();
  var w = $("#sendListingDiv").width();
  $("#sendListingDiv").empty();
  $("#sendListingDiv").append('<div id="loading_top_margin"></div><div id="loading_icon"><img src="/common/images/Loader_vertical_ani.gif" alt="Loading" /></div>');
  $("#sendListingDiv").height(h).width(w);
  $("#wp_popup_inner").load(action, data);
};
whitepages.results.toggle_more_business_categories = function(caller)
{
  whitepages.ui.show_div('business_more_categories');
  var pos = $(caller).position();
  var height = $(caller).height();
  $("#business_more_categories").css( { "left": (pos.left) + "px", "top":(pos.top + height) + "px" } );
}
whitepages.results.toggle_show_business_location_filters = function(caller)
{
  whitepages.ui.show_div('biz_location_filters');
}
whitepages.results.social_link_click = function(e,linktype) {
  evar_value = 'Facebook';
  if(linktype == 'twitter'){
    evar_value = 'Twitter';
  }else if(linktype == 'linkedin'){
    evar_value = 'LinkedIn';  
  }
  
  whitepages.analytics.track_click(e, {events:['social_link'], evars: {'social_link_evar': evar_value}, link_type: 'e'});
}
whitepages.results.track_print = function(tracking_url)
{
  (new Image).src = tracking_url;
};
/*
 * delete_photo
 *
 * REQUIRES:    jquery
 * DESCRIPTION: This method calls the action that will delete a photo
 *
 * PARAMETERS:
 *   url - URL to delete a photo
 *   redirect - URL to redirect to after the response returns a success
 *   message_id - Element id where message is displayed
 *
 */
whitepages.results.delete_photo = function(url, redirect, message_id) {
	$('#'+message_id).css('color','#54B948').html('Removing photo... Please wait while we<br/>update your listing.');
	$('#'+message_id).css('display','block');
  $.ajax({
    url: '/listing/delete_photo?listing_id=' + url,
    success: function(data) {
      var status = JSON.parse(data).status;
			if (status == 'success') {
				window.location.href=redirect;
			} else {
				$('#'+message_id).css('color','red').html('There was a problem removing your photo.  Please try again later.');
			}
    }
  });
}
/*
 * check_photo_status
 *
 * REQUIRES:    jquery
 * DESCRIPTION: This method calls the action to check the status of a photo
 *
 * PARAMETERS:
 *
 */
whitepages.results.check_photo_status = function(redirect_url) {
	var refreshId = setInterval(function() {
		$.ajax({
		  url: '/listing/check_photo',
		  success: function(data, status) {
        if (status == 'success') {
          window.location.href=redirect_url;
          return false;
        }
		  }
		});
	}, 2000);
  setTimeout("clearInterval("+refreshId+")",300000);
}
/*
 * report_inappropriate_photo
 *
 * REQUIRES:    jquery
 * DESCRIPTION: This method calls the action to mark a photo as inappropriate in the logs.
 *
 * PARAMETERS:
 *	photo_url - ID path of photo that translates to location on LASS
 *  listing_id - ID of listing the photo is associated with
 *
 */
whitepages.results.report_inappropriate_photo = function(photo_url, listing_id) {
	$('#mark_photo').addClass('marked');
	$.ajax({
		url: '/report_photo/?listing_id=' + listing_id + '&photo_url=' + photo_url,
	  success: function(data) {
      var status = JSON.parse(data).status;
      var msg_class = 'failed';
      var error = '';
      switch(status) {
        case 'failed': message = 'There was an error while trying to flag photo as not appropriate. Please try again later.'; error=1; break;
        default:       message = 'Successfully flagged photo as not appropriate.'; msg_class='success';
      }
      $('#inappropriate_wrapper .inappropriate_flag').addClass(msg_class).html(message);
	  }
	});
}
/*
 * report_inappropriate_photo
 *
 * REQUIRES:    jquery
 * DESCRIPTION: This method checks width/height and resizes the photo to the
 *              specified dimensions.
 *
 * PARAMETERS:
 *  image_id -  The id of the image element
 *	options  -  A hash of CSS attributes for the image (width, height)
 *    width     -  [required] Width of image
 *    height    -  [required] Height of image
 *    overflow  -  [optional] Overflow value
 *    display   -  [optional] Display value
 *
 */
whitepages.results.resize_photo = function(container_id, image_id, options) {
  var img = $('#'+image_id);
  if ($.browser.msie) {
    var width = parseInt( img.width() +4);
    var height = parseInt( img.height() +2);
  } else {
    var width = parseInt( img.width() );
    var height = parseInt( img.height() );
  }
  var new_height = options.height ? parseInt(options.height) : '100';
  var new_width = options.width ? parseInt(options.width) : '100';
  var overflow = options.overflow ? options.overflow : 'hidden';
  var display = options.display ? options.display : 'inline';
  var m = Math.ceil;
  var field_wrapper = options.field_wrapper ? options.field_wrapper : '';
  if ( isNaN(width) || isNaN(height) || image_id == '' ) {
    return false;
  }
  if (width > height) {
    new_height = m(height / width * new_height);
  } else {
    new_width = m(width / height * new_width);
  }
  img.css('height',new_height+'px')
  img.css('width',new_width+'px');
  $('#'+container_id).css('overflow', overflow);
  $('#'+container_id).css('visibility', 'visible');
  if (field_wrapper != '') {
    $('.'+field_wrapper).css('height', new_height);
  }
}
/*
 * user_found_listing
 *
 * REQUIRES:    jquery
 * DESCRIPTION: Logs user feedback after submission
 *
 * PARAMETERS:
 *  element_id  - The id of the element where the content will be updated
 *	message     - Confirmation messsage
 *  search_type - Search type
 *  options     - Configurable options for a slide effect
 *    slide     - True/false, slide effect toggle
 *    duration  - Duration of the slide effect in ms
 *    direction - Slide direction
 *
 */
whitepages.results.user_found_listing = function(element_id, message, options) {
  var options = options === undefined ? {} : options;
  var direction = options.direction ? options.direction : 'up';
  var duration = options.duration ? options.duration : 400;
  var slide = options.slide ? options.slide : true;
  var url = options.url;
  $('#'+element_id).html(message);
  $.ajax({
    url: url,
    success: function(data) { }
  });
  if (slide == true) {
    setTimeout("whitepages.ui.slide_element('user_feedback',{'duration':1000,'slide':''})", 4000);
    whitepages.ui.closePopup();
  }
}
/** File: /common/javascripts/omniture.js **/
/** WP
 * Omniture helper JavaScript.
 */
var omni_link_filters = [
	'javascript:',
	'address.com', 'phonenumber.com', 'whitepages.ca', 'whitepages411.com'
].join(',') + ',411.com/' + [
	2321, 5138, 5153, 10002, 10668, 10786, 10789, 10815, 14874, 14957
].join(',411.com/') + ',whitepages.com/' + [
	2321, 5138, 5153, 9900, 9901, 10001, 10002, 10583, 10592, 10668, 10786, 10789, 10815, 14867, 14874, 14957
].join(',whitepages.com/');
var omni_wpn_refer    = null;
function omni_refer (referer) {
	/** WP: Updated domain list logic: */
	omni_wpn_refer = referer;
	
	var wp_match = omni_wpn_refer.match(/^https?\:\/\/.*\.(\w+\.\w+)(?::[0-9]+)?(?:\/([0-9]+)\b)?/);
	
	if (wp_match != null) {
		if (wp_match[1] == 'whitepages.com') {
			if (wp_match[2] == null) {
				omni_wpn_refer = null;
			} else if (wp_match[2].match(/^(?:2321|5138|5153|9900|9901|10001|10002|10583|10592|10668|10786|10789|10815|14867|14874|14957)$/)) {
				omni_wpn_refer = null;
			}
		} else if (wp_match[1] == '411.com') {
			if (wp_match[2] == null) {
				omni_wpn_refer = null;
			} else if (wp_match[2].match(/^(?:2321|5138|5153|10668|10002|10786|10789|10815|14874|14957)$/)) {
				omni_wpn_refer = null;
			}
		} else if (wp_match[1] == 'whitepages.ca') {
			omni_wpn_refer = null;
		} else if (wp_match[1].match(/^(?:address|phonenumber|whitepages411)\.com$/)) {
			omni_wpn_refer = null;
		}
	}
}
function omni_settings (pagename, server, channel, pagetype, section, validity, events) {
	if (server == ''){ server = 'No server set'};
	
	s_wpn.pageName = pagename;
	s_wpn.server   = server;
	s_wpn.channel  = channel;
	s_wpn.pageType = pagetype;
	s_wpn.prop1    = section;
	s_wpn.prop2    = validity;
	s_wpn.prop3    = s_wpn.prop2  + ':' + s_wpn.pageName;
	s_wpn.prop4    = s_wpn.server + ':' + s_wpn.pageName;
	s_wpn.prop5    = (omni_wpn_refer ? (omni_wpn_refer + ':') : '') + s_wpn.pageName;
	s_wpn.hier1    = s_wpn.channel + '|' + s_wpn.prop1;
	s_wpn.eVar3    = s_wpn.server;
	s_wpn.eVar4    = s_wpn.eVar3;
  s_wpn.events = events;
	if(s_wpn.prop2 == 'Valid'){
		if(events && events.indexOf('event4') == -1){
      if (events.indexOf(',')){
        s_wpn.events += ',event4';
      }else{
        s_wpn.events += 'event4'
      }
		}
	}
		
	s_wpn.linkTrackVars = "eVar3,eVar4"; /** WP: per aHill 2006-10-09 */
}
var omni_debug_fields = "pageName,channel,server,pageType,prop1,prop2,prop3,prop4,prop5,hier1,eVar3,eVar4,eVar5,events";
function omni_debugging ( ) {
	var show = document.getElementById('omni_debug');
	
	if (show) {
		var field = omni_debug_fields.split(',');
		var stuff = '<table><tr><th style="font-weight:bold">Omniture:</th></tr>'  
				  + '<tr><td style="text-align:right">account:</td><td>&nbsp;</td><td style="text-align:left"><tt>'
				  +  omni_wpn_account
				  +  '</tt></td></tr>';
		
		for (var i = 0; i < field.length; i++) {
			stuff += '<tr><td style="text-align:right">'
			      +     field[i]
			      + ':</td><td>&nbsp;</td><td style="text-align:left"><tt>'
			      +     s_wpn[field[i]]
			      + '</tt></td></tr>';
		}
		
		stuff += '</table>';
		
		show.innerHTML     = stuff;
	}
}
function omni_execute ( ) {
	try {
		var s_wpn_code = s_wpn.t();
		
		if (s_wpn_code)
			document.write( s_wpn_code )
	}
	catch (err) {
	}
}
/** File: /common/javascripts/query.js **/
new function(settings) {
  var $separator = settings.separator || '&';
  var $spaces = settings.spaces === false ? false : true;
  var $suffix = settings.suffix === false ? '' : '[]';
  var $prefix = settings.prefix === false ? false : true;
  var $hash = $prefix ? settings.hash === true ? "#" : "?" : "";
  var $numbers = settings.numbers === false ? false : true;
  jQuery.query = new function() {
    var is = function(o, t) {
      return o != undefined && o !== null && (!!t ? o.constructor == t : true);
    };
    var parse = function(path) {
      var m, rx = /\[([^[]*)\]/g, match = /^([^[]+)(\[.*\])?$/.exec(path), base = match[1], tokens = [];
      while (m = rx.exec(match[2])) tokens.push(m[1]);
      return [base, tokens];
    };
    var set = function(target, tokens, value) {
      var o, token = tokens.shift();
      if (typeof target != 'object') target = null;
      if (token === "") {
        if (!target) target = [];
        if (is(target, Array)) {
          target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));
        } else if (is(target, Object)) {
          var i = 0;
          while (target[i++] != null);
          target[--i] = tokens.length == 0 ? value : set(target[i], tokens.slice(0), value);
        } else {
          target = [];
          target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));
        }
      } else if (token && token.match(/^\s*[0-9]+\s*$/)) {
        var index = parseInt(token, 10);
        if (!target) target = [];
        target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);
      } else if (token) {
        var index = token.replace(/^\s*|\s*$/g, "");
        if (!target) target = {};
        if (is(target, Array)) {
          var temp = {};
          for (var i = 0; i < target.length; ++i) {
            temp[i] = target[i];
          }
          target = temp;
        }
        target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);
      } else {
        return value;
      }
      return target;
    };
    var queryObject = function(a) {
      var self = this;
      self.keys = {};
      if (a.queryObject) {
        jQuery.each(a.get(), function(key, val) {
          self.SET(key, val);
        });
      } else {
        jQuery.each(arguments, function() {
          var q = "" + this;
          q = q.replace(/^[?#]/,''); // remove any leading ? || #
          q = q.replace(/[;&]$/,''); // remove any trailing & || ;
          q = q.replace(/[+]/g,' '); // replace +'s with spaces
          jQuery.each(q.split(/[&;]/), function(){
            var key = decodeURIComponent(this.split('=')[0] || "");
            var val = decodeURIComponent(this.split('=')[1] || "");
            if (!key) return;
            if ($numbers) {
              if (/^[+-]?[0-9]+\.[0-9]*$/.test(val)) // simple float regex
                val = parseFloat(val);
              else if (/^[+-]?[0-9]+$/.test(val)) // simple int regex
                val = parseInt(val, 10);
            }
            val = (!val && val !== 0) ? true : val;
            if (val !== false && val !== true && typeof val != 'number')
              val = val;
            self.SET(key, val);
          });
        });
      }
      return self;
    };
    queryObject.prototype = {
      queryObject: true,
      has: function(key, type) {
        var value = this.get(key);
        return is(value, type);
      },
      GET: function(key) {
        if (!is(key)) return this.keys;
        var parsed = parse(key), base = parsed[0], tokens = parsed[1];
        var target = this.keys[base];
        while (target != null && tokens.length != 0) {
          target = target[tokens.shift()];
        }
        return typeof target == 'number' ? target : target || "";
      },
      get: function(key) {
        var target = this.GET(key);
        if (is(target, Object))
          return jQuery.extend(true, {}, target);
        else if (is(target, Array))
          return target.slice(0);
        return target;
      },
      SET: function(key, val) {
        var value = !is(val) ? null : val;
        var parsed = parse(key), base = parsed[0], tokens = parsed[1];
        var target = this.keys[base];
        this.keys[base] = set(target, tokens.slice(0), value);
        return this;
      },
      set: function(key, val) {
        return this.copy().SET(key, val);
      },
      REMOVE: function(key) {
        return this.SET(key, null).COMPACT();
      },
      remove: function(key) {
        return this.copy().REMOVE(key);
      },
      EMPTY: function() {
        var self = this;
        jQuery.each(self.keys, function(key, value) {
          delete self.keys[key];
        });
        return self;
      },
      load: function(url) {
        var hash = url.replace(/^.*?[#](.+?)(?:\?.+)?$/, "$1");
        var search = url.replace(/^.*?[?](.+?)(?:#.+)?$/, "$1");
        return new queryObject(url.length == search.length ? '' : search, url.length == hash.length ? '' : hash);
      },
      empty: function() {
        return this.copy().EMPTY();
      },
      copy: function() {
        return new queryObject(this);
      },
      COMPACT: function() {
        function build(orig) {
          var obj = typeof orig == "object" ? is(orig, Array) ? [] : {} : orig;
          if (typeof orig == 'object') {
            function add(o, key, value) {
              if (is(o, Array))
                o.push(value);
              else
                o[key] = value;
            }
            jQuery.each(orig, function(key, value) {
              if (!is(value)) return true;
              add(obj, key, build(value));
            });
          }
          return obj;
        }
        this.keys = build(this.keys);
        return this;
      },
      compact: function() {
        return this.copy().COMPACT();
      },
      toString: function() {
        var i = 0, queryString = [], chunks = [], self = this;
        var encode = function(str) {
          str = str + "";
          return encodeURIComponent(str);
        };
        var addFields = function(arr, key, value) {
          if (!is(value) || value === false) return;
          var o = [encode(key)];
          if (value !== true) {
            o.push("=");
            o.push(encode(value));
          }
          arr.push(o.join(""));
        };
        var build = function(obj, base) {
          var newKey = function(key) {
            return !base || base == "" ? [key].join("") : [base, "[", key, "]"].join("");
          };
          jQuery.each(obj, function(key, value) {
            if (typeof value == 'object')
              build(value, newKey(key));
            else
              addFields(chunks, newKey(key), value);
          });
        };
        build(this.keys);
        if (chunks.length > 0) queryString.push($hash);
        queryString.push(chunks.join($separator));
        return queryString.join("");
      }
    };
    return new queryObject(location.search, location.hash);
  };
}(jQuery.query || {}); // Pass in jQuery.query as settings object
/** File: /common/javascripts/xps.js **/
/** WP
 * static/results/xps.js version 1.1
 *
 * IMPORTANT:
 *
 *   The version number above needs to be incremented each time this file
 *   is edited.  In addition, it needs to be updated in each template
 *   wherein it is referenced.  This should include:
 *
 *        wpn/templates/common/includes/ads.xslt
 */
function xps_acquire( div_name, creative, atlas_url ) {
  var request = getHTTPObject();
  if ( request ) {
    request.onreadystatechange = function() {
      parseResponse( request, div_name );
    };
    var url = '/search/PublicSearch?dp=USSearch&creative=' + creative + 
              '&oas_url=' + encodeURI( atlas_url ) + 
              '&ad=' + div_name;
    for ( var i = 3; i < arguments.length; i++ ) {
      var arg = arguments[i].split( '=' );
      if ( arg[0] == 'name' && arg.slice(1) == '' ) {
         xps_fallback( document.getElementById( div_name ) );
         return false;
      }      
      url += '&' +  arg[0]
        +  '=' +  encodeURIComponent( arg.slice(1).join('=') );
    }    
    request.open( "GET", url, true );
    request.send( null );
    return true;
  } else {
    xps_fallback( document.getElementById( div_name ) );
    return false;
  }
}
function parseResponse( request, div_name ) {
  if ( request.readyState == 4 ) {
    if ( request.status == 200 || request.status == 304 ) {
      var xps_div = document.getElementById( div_name );
      xps_div.innerHTML = '';
      var newdiv = document.createElement( 'div' );
      newdiv.innerHTML = request.responseText;
      xps_div.appendChild( newdiv ); 
      xps_div.style.display = 'block';
    }
    xps_fallback( document.getElementById( div_name ) );    
  }
}
function getHTTPObject() {
  var xhr = false;
  if ( window.XMLHttpRequest ) {
    xhr = new XMLHttpRequest();
  } else if ( window.ActiveXObject ) {
    try {
      xhr = new ActiveXObject( "Msxml2.XMLHTTP" );
    } catch( e ) {
      try { 
        xhr = new ActiveXObject( "Microsoft.XMLHTTP" );
      } catch( e ) {
        xhr = false;
      }
    }
  }
  return xhr;
}
function xps_fallback( xps_div ) {
  xps_div.style.display = 'block'; 
}
/** File: /common/javascripts/analytics.js **/
if (typeof(whitepages.analytics) == 'undefined') { whitepages.analytics = function() {}; }
/* === Description
 * Tracks a custom click event.
 * Example: <a href="#" onclick="whitepages.analytics.track_click(
 *   this,
 *   {
 *     events: ['single_result_listing_interaction'],
 *     evars: {listing_interaction: 'send listing to phone'}
 *   }
 * );">send</a>
 *
 * === Parameters
 * calling_dom_object  - the DOM object calling this function. Typically will
 *                       be "this"
 * params              - JavaScript hash of various params for link tracking
 * params.events       - array of Omniture events
 * params.evars        - JavaScript hash of Omniture evars
 * params.link_type    - string value for link_type to pass to tl() function
 *                       "e" - exit link (links that go to other sites)
 *                       "d" - download link (ex: save-to-outlook vcard link)
 *                       "o" - other link (most clicks we track will be this)
 *                       "c" - WP specfic type to bypass tl() function and
 *                             use custom cookie code for link tracking
 */
/* track_impression: takes a single param, impression type, and then passes necessary
                     default values to our track_click function to allow ads to track
                     impressions after page load via sitecatalyst.  Normally these types
                     of events can only be tracked by adding events/evars before the
                     site catalyst code on the page renders.
*/
whitepages.analytics.track_impression = function(type){
  type = type || 'default ad type'
  s_wpn.events = null
  this.track_click( this, { events:['ad_impressions'], link_type: 'e', evars: {'ad_impression_type': type}})
}
/* track_event: takes a params hash that includes events and evars to be tracked
                sets the link type so that an event can be tracked after page load
    hash must include events and another hash of evars like:
    { events:['ad_impressions'], evars: {'ad_impression_type': type}}
*/
whitepages.analytics.track_event = function( params ){
 params.link_type = 'e'
 s_wpn.events = null
 this.track_click( this, params )
}
whitepages.analytics.ga_track_click = function( params ){
	_gaq.push(['_trackEvent', params.category, params.action, params.label, 0, true]);
	_gaq.push(['rollup._trackEvent', params.category, params.action, params.label, 0, true]);
}
whitepages.analytics.track_click = function(calling_dom_object, params)
{
  if ( s_wpn === undefined || omniture_friendly_names === undefined)
  {
    console.log( 's_wpn not defined, click from ' + calling_dom_object + ' not tracked via siteCatalyst.');
    return true;
  }
  var cookie_tracking = {};
  var link_name = 'no defined name';
  if( params.link_name !== undefined ){ link_name = params.link_name; }
  var link_type = 'c';
  if( params.link_type === 'e' || params.link_type === 'o' || params.link_type === 'd'){
      link_type = params.link_type;
    }
  if ( params.events !== undefined ){
    for (var i = 0, len = params.events.length; i < len; i++){
      var friendly_name = params.events[i];
      var event_name = omniture_friendly_names.events[friendly_name];
     
      if (event_name){ s_wpn.events = s_wpn.apl( s_wpn.events, event_name, ',', true ); }
    }
    
    cookie_tracking["events"] = params.events;
    s_wpn.linkTrackEvents = s_wpn.events;
    s_wpn.linkTrackVars = s_wpn.apl( s_wpn.linkTrackVars, 'events', ',', true );
  }
  if ( params.evars != undefined){
    var cookie_evars = {};
    for (var evar_friendly_name in params.evars){
      var evar_name = omniture_friendly_names.evars[evar_friendly_name];
      if (evar_name){
        cookie_evars[evar_friendly_name] = params.evars[evar_friendly_name];
        
        s_wpn[evar_name] = params.evars[evar_friendly_name];
        s_wpn.linkTrackVars = s_wpn.apl( s_wpn.linkTrackVars, evar_name, ',', true );
      
      }
    }
    cookie_tracking["evars"] = cookie_evars;
  }
  if (typeof(params.props) != 'undefined')
  {
    var cookie_props = {};
    for (var prop_friendly_name in params.props){
      var prop_name = omniture_friendly_names.props[prop_friendly_name];
      if (prop_name){
        s_wpn[prop_name] = params.props[prop_friendly_name];
        s_wpn.linkTrackVars = s_wpn.apl( s_wpn.linkTrackVars, prop_name, ',', true );
        
        cookie_props[prop_friendly_name] = params.props[prop_friendly_name];
      }
    }
    cookie_tracking["props"] = cookie_props;
  }
  
  if (link_type == 'c'){
    whitepages.common.setCookieData("wp_session", "analytics_data", escape(JSON.stringify(cookie_tracking)));
  }else{
    
    s_wpn.tl(true, link_type, link_name);
  }
};
/** File: /common/javascripts/search.js **/
/*
 * Submits person search form by going to SEO friendly url: /dir/:location/:name/:firstname
 */
$(document).ready(function() {
  $('form.wp_person_search').submit(function() {
    var $form = $(this), url = 'name';
    if( !this.action.match(/search\/FindPerson$/) ) return
    var keys = ['where', 'name', 'firstname'],
        values = {}
    $.map(keys, function(el, idx) {
      values[el] = ($form.find('[name=' + el + ']').val() || '')
        .replace(/^[\W_]+|[\W_]+$/g, '')
        .replace(/[\W_]+/g, '-')
        .toLowerCase()
    })
    if( values.name === '' || values.name.indexOf('-') > -1 || values.firstname.indexOf('-') > -1 || window.location.host.match(/^names./) != undefined ){
      var terms = $.map(keys,function(ele) {
            if(values[ele] === '') {
                return 'a-z'
            }
            return values[ele]
      })
      url = $form.attr('action').replace(/search\/FindPerson/i, 'dir/' + terms.join('/'))
    } else {
      var fname = values.firstname.substr(0, 1).toUpperCase() + values.firstname.substr(1)
          lname = values.name.substr(0, 1).toUpperCase() + values.name.substr(1)
           name = fname === '' ? lname : fname + '-' + lname,
          where = values.where.toUpperCase(),
         swhere = values.where.split(/-/),
           slen = swhere.length
      if(slen > 1 || where.length > 2) {
        swhere[0] = swhere[0].substr(0,1).toUpperCase() + swhere[0].substr(1)
        swhere[slen-1] = (swhere[slen-1].length == 2) ? swhere[slen-1].toUpperCase() : swhere[slen-1].substr(0,1) + swhere[slen-1].substr(1)
        where = swhere.join('-')
      }
      url = '/name/' + name + '/' + where
    }
    window.location = url
    return false
  });
  $('form#names_search').submit(function() {
    var form = $(this);
    var keys = ['firstname', 'lastname', 'state_id'], values = {}
    $.map(keys, function(el, idx) {
      field = form.find('[name='+el+']');
      value = (field.val() || '')
        .replace(/^[\W_]+|[\W_]+$/g, '')
        .replace(/[\W_]+/g, '-')
        .toLowerCase()
      field.val(value);
    })
    
    form.submit()
  });
});
/*
 * Submits a reverse address form using an SEO friendly URL: /phone/1-123-456-7890
 */
$(document).ready( function () {
  $('form#reverse_phone_search').submit( function () {
    var phone;
    if ( !this.action.match(/search\/ReversePhone/) ) return;
    phone = $(this).find('[name=full_phone]').val().replace(/[^\d]+/g, '');
    if (phone.length == 10) {
      phone = '1'+phone;
    }
    if(phone.length == 11) {
      phone = phone.replace(/^(1)(\d{3})(\d{3})(\d{4})$/, "$1-$2-$3-$4" )
    }
    window.location = $(this).attr('action').replace(/search\/ReversePhone/i, 'phone/' + phone)
    return false;
  });
});
/** File: /common/javascripts/rsi.js **/
var segQS = '';
function getRSISegs()
{
  var rsi_segs = [];
  var segs_beg = document.cookie.indexOf('rsi_segs=');
  if (segs_beg >= 0) {
    segs_beg = document.cookie.indexOf('=', segs_beg) + 1;
    if (segs_beg > 0) {
      var segs_end = document.cookie.indexOf(';', segs_beg);
      if (segs_end == -1) segs_end = document.cookie.length;
      rsi_segs = document.cookie.substring(segs_beg, segs_end).split('|');
    }
  }
  return rsi_segs;
}
function getRSIDataFromCookie()
{
  try {
    var rsi_regex = /(?:A06546|(\w{1})\d+)_(\d+)/,
        seg_len = 0,
        rsi_data = []
    rsi_segs = getRSISegs()
    seg_len = rsi_segs.length < 20 ? rsi_segs.length : 20
    for (var i = 0; i < seg_len; i++) {
      rsi_data.push(rsi_segs[i].replace(rsi_regex, '$1$2'))
    }
  }
  catch (e) {
  }
  return rsi_data.join(',')
}
var rsi_data = getRSIDataFromCookie();
/** File: /common/javascripts/jquery.infieldlabel.js **/
/*
 * In-Field Label jQuery Plugin
 * http://fuelyourcoding.com/scripts/infield.html
 *
 * Copyright (c) 2009 Doug Neiner
 * Dual licensed under the MIT and GPL licenses.
 * Uses the same license as jQuery, see:
 * http://docs.jquery.com/License
 *
 * @version 0.1.2
 */
(function(a){a.InFieldLabels=function(c,e,b){var d=this;d.$label=a(c);d.label=c;d.$field=a(e);d.field=e;d.init=function(){d.options=a.extend({},a.InFieldLabels.defaultOptions,b);d.$label.bind({mouseup:d.focusField});d.$field.bind({"focus blur change onPropertyChange paste keyup":d.fadeOnChange,keydown:d.hideOnChange});d.fadeOnChange()};d.focusField=function(){d.$field.focus();return false};d.setOpacity=function(f){d.$label.stop().show().animate({opacity:f},d.options.fadeDuration)};d.setColor=function(f){d.$label.stop().show().animate({color:f},d.options.fadeDuration)};d.fadeOnChange=function(f){if(d.field.value!==""){d.hideLabel();return}if(d.options.changeOpacity){d.setOpacity((f&&f.type==="focus")?d.options.fadeOpacity:d.options.fullOpacity)}if(d.options.changeColor){d.setColor((f&&f.type==="focus")?d.options.fadeColor:d.options.fullColor)}};d.hideOnChange=function(f){if((f.which===9)||(f.which===12)||(f.which===16)||(f.which===17)||(f.which===18)||(f.which===20)||(f.which===27)||(f.which===91)||(f.which===93)||(f.which>=33&&f.which<=40)){return}d.hideLabel()};d.hideLabel=function(){d.$label.stop().hide();d.options.changeOpacity&&d.$label.css("opacity",d.options.fadeOpacity);d.options.changeColor&&d.$label.css("color",d.options.fadeColor)};d.init()};a.InFieldLabels.defaultOptions={changeOpacity:true,fullOpacity:1,fadeOpacity:0.5,changeColor:false,fullColor:"#666",fadeColor:"#ccc",fadeDuration:300};a.fn.inFieldLabels=function(b){return this.each(function(){var d=a(this).attr("for"),c;if(!d){return}c=a("input#"+d+"[type='text'],input#"+d+"[type='search'],input#"+d+"[type='tel'],input#"+d+"[type='url'],input#"+d+"[type='email'],input#"+d+"[type='password'],textarea#"+d);if(c.length===0){return}(new a.InFieldLabels(this,c[0],b))})}}(jQuery));
/** File: /common/javascripts/pse_tracking.js **/
$(document).ready(function() {
  $(document).delegate(".pse_track", "mousedown", function() {
    var search_id = $('body').attr('data-search_id');
    if (search_id !== undefined && search_id !== '') {
      document.cookie = 'pse=' + search_id + '; path=/'
    }
  });
});
/** File: /common/javascripts/loginpopover.js **/
$(function(){
  $('.signin-link').click(function(e){
    e.stopPropagation();
    whitepages.common.open_window($(this).attr('href'), 600, 700);
    $('.bubble-wrapper').hide();
    return false;
  });
    
  if($('.claim_box .bubble-wrapper').length !== 0){
    var claim_link = $('.claim_box a');
    claim_link.click(function(e){
      e.stopPropagation();
      $('.claim_box .bubble-wrapper').toggle();
      return false;
    });
  }
  $('.bubble-wrapper .close-link').click(function(e){
    e.stopPropagation();
    $('.bubble-wrapper').hide(); 
    return false;
  });
});
