/**
 * Some extensions to the Array object
 */

Array.implement({
    /**
     * Searches for the minimum value, and returns the index.
     * @param {Number|Integer} [start] If specified, only a subset of the array will be searched.
     * @param {Number|Integer} [length] If specified, only a subset of the array will be searched.
     * @param {Number|Integer} [threshold] An optional value which specifies the minimum difference in value required during comparison. 
     * @return {Number|Integer}
     */
    minIndex: function(start, length, threshold){
        // Determine the start/end:
        if (start === undefined)
            start = 0;
        var end;
        if (length === undefined)
            end = this.length;
        else
            end = start + length;
        threshold = threshold || 0;

        if (start < 0 || end <= start)
            return null;

        // Search:
        var min = this[start], minIndex = start;
        while ((++start) < end) {
            if (min > this[start] + threshold){
                min = this[start];
                minIndex = start;
            }
        }
        return minIndex;
    }

    ,
	/**
     * Searches for the maximum value, and returns the index.
     * @param {Number|Integer} [start] If specified, only a subset of the array will be searched.
     * @param {Number|Integer} [length] If specified, only a subset of the array will be searched.
     * @return {Number|Integer}
     */
	maxIndex: function(start, length) {
        // Determine the start/end:
        if (start === undefined)
            start = 0;
        var end;
        if (length === undefined)
            end = this.length;
        else
            end = start + length;

        if (start < 0 || end <= start)
            return null;

        // Search:
        var max = this[start], maxIndex = start;
        while ((++start) < end) {
            if (max < this[start]){
                max = this[start];
                maxIndex = start;
            }
        }
        return maxIndex;
    }

	,
	/**
	 * Erases all of the items from the array.
	 * @param {Array|Object} items
	 */
	exclude: function(items) {
		Array.each(items, function(item) {
			this.erase(item);
		}, this);
	}
});
/**
 * Callbacks - an alternative to using Events.
 * When implementing Events, you typically "broadcast" the event so that anyone can listen to it.
 * Callbacks, on the other hand, are designed for private access between a parent and a child.
 * This class behaves similarly to Options -- simply call 'this.setCallbacks(callbacks)'
 * to merge the callbacks into 'this.callbacks'.
 *
 * This method also logs error messages if any of the callbacks are left null,
 * and also if any extra (unrecognized) callbacks are passed in.
 *
 * To allow "optional" callbacks, you should supply any non-null value (preferably an empty function).
 */
window.Callbacks = new Class({

	/**
	 * Appends the callbacks to "this.callbacks",
	 * and verifies that all expected callbacks
	 * were supplied.
	 */
	setCallbacks: function (callbacks) {
		// Ensure no callbacks are null and that no extras were supplied:
		if (Uverse.console.enabled) {
			var messages = [];
			if (!this.callbacks) {
				Uverse.console.warn('[Callbacks]', 'Could not find "this.callbacks".');
			} else {
				var suppliedKeys = Object.keys(callbacks);
				var missingKeys = [];
				for (var expected in this.callbacks){
					if (this.callbacks[expected] === null && !callbacks[expected])
						missingKeys.push(expected);
					else
						suppliedKeys.erase(expected);
				}
				if (missingKeys.length) {
					messages.push('[Callbacks]', 'Required callbacks were not supplied (', missingKeys.join(', '), ')');
				}
				if (suppliedKeys.length) {
					if (messages.length)
						messages.push(', and ');
					else
						messages.push('[Callbacks]');
					messages.push('Extra callbacks were supplied but not used (', suppliedKeys.join(', '), ')');
				}
			}

			if (messages.length) {
				if (Uverse.console.error.apply)
					Uverse.console.error.apply(Uverse.console, messages);
				else
					Uverse.console.error(messages); // Grrr, IE9!
			}
		}

		// Do the actual merge:
		this.callbacks = Object.merge({}, this.callbacks, callbacks);
	}
});
DOMEvent.implement({
	/**
	 * Returns the name of the mouse button that was clicked (left/middle/right).
	 * @return {String}
	 *
	 * Note: in IE8, the 'click' event is always reported as 'left', so use 'mouseup' instead
	 */
	getMouseButton: function() {
		if ('which' in this.event) {
			// The 'which' event is most consistent across browsers.
			switch (this.event.which) {
				case 3:
					return 'right';
				case 2:
					return 'middle';
				case 1:
				default:
					return 'left';
			}
		} else {
			// IE8:
			switch (this.event.button) {
				case 2:
					return 'right';
				case 4:
					return 'middle';
				case 1:
				case 0: // 'click' event always reports 0
				default:
					return 'left';
			}
		}
	}

	/**
	 * Returns true if `ev.preventDefault` was called
	 * during any of this event's handlers, including nested handlers.
	 */
	, wasDefaultPrevented:
		(Browser.ie8 || Browser.ie7) ? function() {
			return (this.event.returnValue === false);
		} : function() {
			return this.event.$wasDefaultPrevented === true;
		}
});

Class.refactor(DOMEvent, {
	/**
	 * Prevents the default behavior.
	 * You can later use `ev.wasDefaultPrevented()` to determine if this method was called.
	 */
	preventDefault:
		(Browser.ie8 || Browser.ie7) ? function() {
			return this.previous();
		} : function() {
			this.event.$wasDefaultPrevented = true;
			return this.previous();
		}
});



/**
 * Define some pseudo-filters for the mouse events:
 */
Object.each({
	/**
	 * Filters mouse events by button.
	 * Valid values include 'left', 'middle', and 'right'.
	 * Multiple buttons can be applied by including a space.
	 *
	 * Note: in IE8, the 'click' event is always reported as 'left', so use 'mouseup' instead
	 */
	'button': function (split, fn, args) {
		if (split.event.match(/^(click|mouse)/)) {
			var event = args[0]
				,button = event.getMouseButton()
				,validButtons=split.value.split(' ');
			var isValidButton = validButtons.contains(button);
			if (!isValidButton)
				return; // Filtered
		}
		fn.apply(this, args);
	}
}, function (fn, key) {
	DOMEvent.definePseudo(key, fn);
});
Element.extend({
	/**
	 * Merges the values from several objects.
	 * If the same key exists, instead of overwriting the value,
	 * the values are added to an array.
	 *
	 * @param {Object} result The item to merge values into
	 * @param {...Object} _values The values to merge into result
	 * @return {Object}
	 */
	mergeInputValues: function(result, _values) {
		Array.each(arguments, function(values, ix) {
			if (ix === 0) return;
			for (var v in values) {
				if (v in result) // Merge the duplicate results into an array:
					result[v] = Array.append(Array.from(result[v]), Array.from(values[v]));
				else
					result[v] = values[v];
			}
		});
		return result;
	}
});

Element.implement({

	/**
	 * Finds all input elements, and serializes all values into an object.
	 * @return {Object}
	 */
	serializeInputs: function() {
		var result = {};

		this.getElements('input, select, textarea').each(function(el) {

			// Filter out unserialized elements:
			var type = el.type;
			if (!el.name || el.disabled || type == 'submit' || type == 'reset' || type == 'file' || type == 'image')
				return;

			var values = el.serializeInput();
			Element.mergeInputValues(result, values);
		});

		return result;
	}

	/**
	 * Serializes the input element's `name` and `value` into an object.
	 *
	 * If multiple `select` items are chosen, the `value` will be an Array.
	 * It is also possible that the result will be an empty object (in the case of selects, checkboxes, radios, and elements without a name).
	 *
	 * NOTE: This method is a modified version of MooTools' Element.toQueryString().
	 */
	, serializeInput: function() {
		var el = this
			, type = el.type
			, result = {};

		if (!el.name || type == 'reset' || type == 'file')
			return result;

		var values = (el.get('tag') == 'select') ? el.getSelected().map(function(opt){
			// IE
			return document.id(opt).get('value');
		}) : ((type == 'radio' || type == 'checkbox') && !el.checked) ? [] : [el.get('value')];

		// Ignore 0, flatten 1, use an array for 2+:
		if (values.length)
			result[el.name] = (values.length === 1) ? values[0] : values;

		return result;
	}

	/**
	 * Deserializes all inputs' values from an object.
	 *
	 * This method is the inverse of `serializeInputs`.
	 */
	, deserializeInputs: function(values){
		this.getElements('input, select, textarea').each(function(el){
			el.deserializeInput(values);
		});
	}

	/**
	 * Deserializes the input's value from an object.
	 *
	 * This method is the inverse of `serializeInput`.
	 */
	, deserializeInput: function(values){
		var el = this
			, type = el.type;

		if (!el.name || type === 'submit' || type === 'reset' || type === 'file' || type === 'image')
			return;

		var value = values[el.name];
		if (typeOf(value) === 'object') // Could be caused by parsing a query string
			value = Object.values(value);
		value = Array.from(value);

		if (el.get('tag') === 'select') {
			el.getElements('option').each(function(opt){
				var val = opt.get('value');
				opt.selected = value.contains(val);
			});
		} else if (type === 'radio' || type === 'checkbox') {
			var val = el.get('value');
			el.checked = value.contains(val) || value.contains(true);
		} else {
			el.set('value', value.join(""));
		}
	}



	/**
	 * Returns the closest self-or-ancestor that matches the selector.
	 * @param {String} selector Any Slick selector
	 * @returns {Element}
	 */
	, getClosest: function(selector) {
		var cur = this;
		while (cur && !cur.match(selector)) {
			cur = cur.getParent();
		}
		return cur;
	}



	/**
	 * Returns the closest parent element that has
	 * a 'overflow' of 'auto' or 'scroll'.
	 * @returns {Element}
	 */
	, getScrollParent: function () {
		var isVerticalScrollContainer = function (el) {
			var o = el.getStyle('overflow'), oy = el.getStyle('overflow-y');
			return (o === 'scroll' || o === 'auto' || oy === 'scroll' || oy === 'auto');
		};

		var el = this;
		while (el && !isVerticalScrollContainer(el))
			el = el.getParent();

		if (el == null || el === document.body || el === document.html) {
			return window;
		}
		return el;
	}

});

Class.refactor(Element, {
	/**
	 * Sets the tween transition before fading.
	 * @param {String|Number} how - Can be 'hide', 'show', 'in', 'out', or an opacity value
 	 * @param {String} [transition] - The name of a transition, such as 'quint:in', 'quint:out'
	 */
	fade: function(how, transition) {
		if (transition) {
			this.set('tween', { transition: transition });
		}
		return this.previous(how);
	}
});


/**
 * TransitionOptions describes a transition, including a set of properties to transition.
 *
 * @name TransitionOptions
 *
 * @property {String[]}                             [props] - An array of CSS properties to animate.  Optional if you use `elements` instead.
 * @property {String|Function}                      [transition] - (Optional) The type of easing
 * @property {Number|String}                        [duration] - (Optional) The animation duration
 * @property {Object<Selector, TransitionOptions>}  [elements] - (Optional) A hash of sub-elements that should also be transitioned.
 */


Element.implement({
	/**
	 * Animates a set of properties by measuring before and after for each element.
	 *
	 * @param {TransitionOptions|String[]|String}  transitionOptions - One of the following: Name of a CSS property, array of CSS properties, or Options object.
	 * @param {Function}                prepare - This function should change the element from the "before" state to the "after" state.
	 * @param {Object}                  [bind]
	 */
	transition: function(transitionOptions, prepare, bind) {
	var elements = new Elements([this]);
	elements.transition(transitionOptions, prepare, bind);
	return this;
}

});


Elements.implement({
	/**
	 * Animates a set of properties by measuring before and after for each element.
	 *
	 * @param {TransitionOptions|String[]|String}  transitionOptions - One of the following: Name of a CSS property, array of CSS properties, or <see TransitionOptions> object.
	 * @param {Function}                prepare - This function should change the element from the "before" state to the "after" state.
	 * @param {Object}                  [bind]
	 */
	transition: function(transitionOptions, prepare, bind) {
		bind = bind || this;
		transitionOptions = normalizeTransitionOptions(transitionOptions);
		if (!transitionOptions) {
			prepare.call(bind);
			return this;
		}

		var els = this;

		var morphOptions = null;
		if (transitionOptions.transition || transitionOptions.duration) {
			morphOptions = Object.subset(transitionOptions, ['transition', 'duration']);
			els.set('morph', morphOptions);
		}

		if (transitionOptions.elements) {
			prepare = getChainedElementTransitions(transitionOptions.elements, els, bind, prepare, morphOptions);
		}

		if (!(transitionOptions.props && transitionOptions.props.length)) {
			prepare.call(bind);
			return this;
		}

		var props = transitionOptions.props;

		// Measure everything before:
		var befores = els.map(function(el) {
			var before = {};
			props.each(function(prop){
				before[prop] = el.getStyle(prop);
			});
			return before;
		});

		prepare.call(bind);

		els.each(function(el, i) {
			var before = befores[i];

			// Reset:
			props.each(function(prop) {
				el.setStyle(prop, null);
			});

			// Measure after:
			var morph = {}, morphIsEmpty = true;
			props.each(function(prop) {
				var after = el.getStyle(prop);
				if (before[prop] !== after) {
					morph[prop] = [ before[prop], after ];
					morphIsEmpty = false;
				}
			});

			// Start the Morph:
			if (!morphIsEmpty) {
				el.setStyles(before);
				el.morph(morph);
			} else {
				el.get('morph').cancel();
			}
		});

		return this;

		// Private functions:
		function getChainedElementTransitions(childElements, els, bind, prepare, morphOptions) {
			// Chain together all the transitions for "elements":
			Object.each(childElements, function(transitionOptions, selector) {
				prepare = (function(originalPrepare) {
					return function() {
						var childElements = new Elements(els.getElements(selector).flatten());
						transitionOptions = normalizeTransitionOptions(transitionOptions);
						if (morphOptions) transitionOptions = Object.append(morphOptions, transitionOptions);
						childElements.transition(transitionOptions, originalPrepare, bind);
					};
				})(prepare);
			});
			return prepare;
		}
		function normalizeTransitionOptions(transitionOptions) {
			switch (typeOf(transitionOptions)) {
				case 'string':
					transitionOptions = { props: [ transitionOptions ]};
					break;
				case 'array':
					transitionOptions = { props: transitionOptions };
					break;
			}
			return transitionOptions;
		}
	}
});
(function () {

	/**
	 * Define a custom 'changing' event for input Elements
	 * that fires when the input's value is changing.
	 *
	 * This event normalizes the unusual behavior of the "change" event,
	 * and always fires as changes are made (instead of on blur).
	 *
	 * For example, a text box will fire the 'changing' event for each of the following events:
	 * User types a letter
	 * User pastes a value with the mouse
	 * User clicks on a "form history" value
	 *
	 * Note, this is a MooTools port of following the jQuery plugin:
	 * https://github.com/scottrippey/jquery.event.changing
	 *
	 */
    Object.append(Element.Events, {
		'changing': {
			onAdd: function (fn) {
				addChangingEvent(this, fn);
			}
			, onRemove: function (fn) {
				removeChangingEvent(this, fn);
			}
		}
	});



	/* Private functions */



	function addChangingEvent(el, fn) {
		var lastValue = getValue(el);
		el.store('lastValue', lastValue);

		var eventTypes = determineEventTypes(el);
		addEachEvent(el, eventTypes.normal, handleNormal);
		addEachEvent(el, eventTypes.delayed, handleDelayed);
		addEachEvent(el, eventTypes.radio, handleRadio);
	}
	function removeChangingEvent(el, fn) {
		el.eliminate('lastValue');

		var eventTypes = determineEventTypes(el);
		removeEachEvent(el, eventTypes.normal, handleNormal);
		removeEachEvent(el, eventTypes.delayed, handleDelayed);
		removeEachEvent(el, eventTypes.radio, handleRadio);
	}
	function addEachEvent(el, events, handler) {
		events.each(function(event){
			el.addEvent(event, handler);
		});
	}
	function removeEachEvent(el, events, handler) {
		events.each(function(event){
			el.removeEvent(event, handler);
		});
	}


	/** Determines the events that are necessary to normalize the 'changing' event */
	function determineEventTypes(el) {
		var tag = el.get('tag'), type = el.get('type');
		var eventTypes = { normal: [], delayed: [], radio: [] };
		if (tag === 'select') {
			eventTypes.normal.push('change', 'keyup', 'click');
		} else if (tag === 'textarea' || type == 'text' || type == 'password') {
			// Notes: blur is necessary because some actions don't fire change events: (eg: clicking a "form history" item; "right-click > delete" in IE)
			eventTypes.normal.push('change', 'keyup', 'blur');
			eventTypes.delayed.push('cut', 'paste', 'input');
		} else if (type == 'checkbox') {
			// In IE, checkboxes only change on blur
			eventTypes.normal.push('change', 'click');
		} else if (type == 'radio') {
			eventTypes.radio.push('change');
		} else {
			eventTypes.normal.push('change');
		}
		return eventTypes;
	}

	function handleNormal(ev) {
		fireIfChanged.apply(this, [ev]);
	}
	function handleDelayed(ev) {
		fireIfChanged.delay(25, this, [ev]);
	}
	function handleRadio(ev) {
		// Check all radios for changes
		var el = this;
		var radiosInGroup = getRadiosInGroup(el);
		radiosInGroup.each(function(radio) {
			fireIfChanged.apply(radio, [ev]);
		});
	}
	function getRadiosInGroup(el) {
		var groupContext = el.getParent('form') || document.body;
		var radiosInGroup = groupContext.getElements('input[type=radio][name="' + el.name + '"]');
		return radiosInGroup;
	}

	function fireIfChanged(ev) {
		var el = this
		  , newValue = getValue(el)
		  , oldValue = el.retrieve('lastValue');
		if (newValue !== oldValue) {
			el.store('lastValue', newValue);
			el.fireEvent('changing', [ev, el, newValue, oldValue]);
		}
	}

	function getValue(el) {
		// This code was partially copied from Element.toQueryString().
		var values = (el.get('tag') == 'select') ? el.getSelected().map(function(opt){
			// IE
			return document.id(opt).get('value');
		}) : ((el.type == 'radio' || el.type == 'checkbox') && !el.checked) ? [null] : [el.get('value')];
		return values.join('|');
	}



})();

(function () {

	/**
	 * Define a custom 'scrolling' event for an Element
	 * that fires when the element goes in and out of view.
	 *
	 * The handler is called with 4 parameters:
	 * actions, direction, position, lastPosition
	 * 
	 */
    Object.append(Element.Events, {
		'scrolling': {
			onAdd: function (fn) {
				addScrollingEvent(this, fn);
			}
			, onRemove: function (fn) {
				removeScrollingEvent(this, fn);
			}
		}
	});

	/**
	 * Define some pseudo-filters for the 'scrolling' event.
	 */
	Object.each({
		/**
		 * Filters the 'scrolling' event by action.
		 * Valid values include any combination of:
		 * 'scrollingIn', 'scrolledIn', 'scrollingOut', 'scrolledOut'
		 */
		'action': function (split, fn, args) {
			if (split.event === 'scrolling') {
				var actions = args[0];
				var validActions = split.value.split(' ');
				var isValidAction = actions.some(function (a) { return validActions.contains(a); });
				if (!isValidAction)
					return; // Filtered.
			}
			fn.apply(this, args);
		}

		/**
		 * Filters the 'scrolling' event by the direction of the element.
		 * Valid values include: 'up' or 'down'
		 */
		, 'direction': function (split, fn, args) {
			if (split.event === 'scrolling') {
				var direction = args[1];
				if (split.value !== direction)
					return; // Filtered.
			}
			fn.apply(this, args);
		}

		/**
		 * Filters the 'scrolling' event by the new position of the element.
		 * Valid values include any combination of:
		 * 'above', 'top', 'inside', 'bottom', 'below'
		 */
		, 'position': function (split, fn, args) {
			if (split.event === 'scrolling') {
				var position = args[2];
				var validPositions = split.value.split(' ');
				if (!validPositions.contains(position))
					return; // Filtered.
			}
			fn.apply(this, args);
		}
	}, function (fn, key) {
		DOMEvent.definePseudo(key, fn);
	});



	Element.implement({
		/**
		 * Returns the position of the element, relative to the current view.
		 * Will be one of the following values:
		 * 'above', 'top', 'inside', 'bottom', 'below'
		 * @returns String
		 */
		getScrollingPosition: function (scrollingOptions) {
			return getScrollingPosition(this, scrollingOptions);
		}
	});











	// CONSTANTS:
	var POSITIONS = {
		 'above': 4
		,'top': 3
		,'inside': 2
		,'bottom': 1
		,'below': 0
	};
	var ACTION_SEQUENCE = ['scrollingIn', 'scrolledIn', 'scrollingOut', 'scrolledOut'];




	/* Private functions */



	function addScrollingEvent(el, fn) {

		// Since MooTools can't pass options into the "addEvent" method,
		// we must store and retrieve them instead:
		var scrollingOptions = el.retrieve('scrollingOptions');
		if (scrollingOptions && !scrollingOptions.persistOptions)
			el.eliminate('scrollingOptions');

		// Initialize the scrollParent:
		var scrollParent = el.getScrollParent();
		var scrollWatcher = scrollParent.retrieve('$scrollWatcher', { initialized: false });
		if (scrollWatcher.initialized == false) {
			Object.merge(scrollWatcher, {
				initialized: true
				, watched: []
				, lastBottom: 0
				// Keep a reference to the attached events:
				, onScroll: function () { updateScroll(scrollParent); }
				, onResize: function () { updateScroll(scrollParent); }
			});

			scrollParent.addEvent('scroll:pace(100)', scrollWatcher.onScroll);
			window.addEvent('resize:pace(100)', scrollWatcher.onResize);
		}

		mergeEventIntoScrollWatcher(scrollWatcher, el, fn, scrollingOptions);
	}


	/* Inserts or merges the event information into the scrollWatcher */
	function mergeEventIntoScrollWatcher(scrollWatcher, el, fn, scrollingOptions) {
		// Find existing elementInfo:
		var elementInfo = null;
		for (var i = 0; i < scrollWatcher.watched.length; i++) {
			var ei = scrollWatcher.watched[i];
			if (ei.el === el && ei.scrollingOptions === scrollingOptions) {
				// Exact match!
				elementInfo = ei;
				break;
			}
		}
		if (elementInfo == null) {
			// Create a new elementInfo:
			elementInfo = {
				el: el
				, scrollingOptions: scrollingOptions
				, lastPosition: ''
				, handlers: []
			};
			scrollWatcher.watched.push(elementInfo);
		}

		elementInfo.handlers.push(fn);
	}



	function removeScrollingEvent(el, fn) {
		var scrollParent = el.getScrollParent();
		var scrollWatcher = scrollParent.retrieve('$scrollWatcher');
		if (scrollWatcher) {
			for (var i = 0, length = scrollWatcher.watched.length; i < length; i++) {
				// Find the correct matching element and callback:
				var elementInfo = scrollWatcher.watched[i];
				if (elementInfo.el !== el)
					continue;

				// Remove the callback:
				elementInfo.handlers.erase(fn);

				// Optimizations:
				// TODO: if all events are cleared, remove the element.
				// TODO: if all elements are cleared, remove the scrollWatcher and 'scroll' event.
			}
		}
	}

	function updateScroll(scrollParent) {

		var scrollWatcher = scrollParent.retrieve('$scrollWatcher');
		if (!scrollWatcher)
			return;

		var viewBounds = getViewBounds(scrollParent);

		var direction = (viewBounds.bottom >= scrollWatcher.lastBottom) ? 'up' : 'down'; // (Direction of the ELEMENT movement, not the view)
		scrollWatcher.lastBottom = viewBounds.bottom;

		for (var i = 0, length = scrollWatcher.watched.length; i < length; i++) {
			var elementInfo = scrollWatcher.watched[i];

			var elBounds = getElementBounds(elementInfo.el, scrollParent, elementInfo.scrollingOptions);

			var position = getPosition(viewBounds, elBounds);
			
			// If our position changed, fire the event:
			if (elementInfo.lastPosition !== position) {
				var actions = getPositionChangeActions(elementInfo.lastPosition, position);
				fireEvents(elementInfo, [actions, direction, position, elementInfo.lastPosition]);
				elementInfo.lastPosition = position;
			}
		}
	}

	function getScrollingPosition(el, scrollingOptions) {
		var scrollParent = el.getScrollParent();

		// Determine if we're already watching this item:
		var scrollWatcher = scrollParent.retrieve('$scrollWatcher');
		if (scrollWatcher) {
			for (var i = 0; i < scrollWatcher.watched.length; i++) {
				var elementInfo = scrollWatcher.watched[i];
				if (elementInfo.el === el && elementInfo.scrollingOptions === scrollingOptions) {
					// Let's update this item's position and return it!
					updateScroll(scrollParent);
					return elementInfo.lastPosition;
				}
			}
		}

		// Calculate the position for this element:
		var viewBounds = getViewBounds(scrollParent);
		var elBounds = getElementBounds(el, scrollParent, scrollingOptions);

		var position = getPosition(viewBounds, elBounds);

		return position;
	}

	function getViewBounds(scrollParent) {
		var viewTop = scrollParent.getScrollTop()
		  , viewBottom = viewTop + scrollParent.getHeight();
		return { top: viewTop, bottom: viewBottom };
	}

	function getElementBounds(el, scrollParent, scrollingOptions) {
		var elTop = getRelativeOffsetTop(el, scrollParent), elBottom = elTop + el.getHeight();

		// Apply the scrolling options:
		if (scrollingOptions) {
			// Apply the distance:
			if (scrollingOptions.distance) {
				if (scrollingOptions.distance.top)
					elTop -= scrollingOptions.distance.top;
				if (scrollingOptions.distance.bottom)
					elBottom += scrollingOptions.distance.bottom;
			}
		}

		return { top: elTop, bottom: elBottom };
	}



	


	/* Returns the top of the element relative to the parent */
	function getRelativeOffsetTop(el, relative) {
		if (relative === window) {
			// Use MooTools' default behavior:
			return el.getOffsets().y;
		}
		var offsetTop = 0;
		while (el && el !== relative) {
			// NOTE: this will FAIL if "relative" isn't an offsetParent
			// TODO: improve this function to accommodate.
			offsetTop += el.offsetTop;
			el = el.getOffsetParent();
		}

		if (!el && window.console && window.console.warn)
			window.console.warn('[event.scrolling]', 'Could not find the correct relative parent.');

		return offsetTop;
	}





	/* Determines the item's position, based on the view location */
	function getPosition(viewBounds, elBounds){
		if (elBounds.bottom < viewBounds.top) {
			return 'above';
		} else if (elBounds.top > viewBounds.bottom) {
			return 'below';
		} else if (elBounds.top < viewBounds.top) {
			if (elBounds.bottom > viewBounds.bottom)
				return 'inside'; // this only happens if the element is larger than the view.
			else
				return 'top';
		} else if (elBounds.bottom > viewBounds.bottom) {
			return 'bottom';
		}
		return 'inside';
	}






	/* Returns all the actions corresponding to an element's position change */
	function getPositionChangeActions(oldPosition, newPosition) {
		if (newPosition === oldPosition || oldPosition === '')
			return [];
		// Lookup the position numbers:
		newPosition = POSITIONS[newPosition];
		oldPosition = POSITIONS[oldPosition];

		var positionDir = (newPosition < oldPosition) ? -1 : 1;
		var actions = [];
		for (var s = oldPosition, stop = newPosition; s != stop; s += positionDir) {
			var index = (positionDir > 0) ? s : ACTION_SEQUENCE.length - s;
			actions.push(ACTION_SEQUENCE[index]);
		}

		return actions;
	}

	/* Fires all handlers */
	function fireEvents(elementInfo, args) {
		for (var i = 0, length = elementInfo.handlers.length; i < length; i++) {
			var handler = elementInfo.handlers[i];
			handler.apply(elementInfo.el, args);
		}
	}




	/* TODO: Optimization: Keep elements sorted, 
	 * so that we can reduce the number of position-checks.
	 * "binarySearch" will help with this.
	 */
	
	/*
	* Returns the index of the item whose value 
	* is equal to or less than the given item's value.
	* If multiple items match, the last matching item's index will be returned.
	*/
	function binarySearch(items, value, getValue) {
		var x = 0, w = items.length;
		while (w > 1) {
			var pivot = Math.floor(w / 2);
			var valuePivot = getValue(items[x + pivot]);
			if (value < valuePivot) {
				w = pivot;
			} else {
				x += pivot;
				w -= pivot;
			}
		}
		return x;
	}
})();
/*
---
description: Provides a fallback for the placeholder property on input elements for older browsers.

license:
  - MIT-style license

authors:
  - Matthias Schmidt (http://www.m-schmidt.eu)

version:
  - 1.2

requires:
  core/1.2.5: '*'

provides:
  - Form.Placeholder

...
*/
(function(){

	if (!this.Form) this.Form = {};

	var supportsPlaceholder = ('placeholder' in document.createElement('input'));
	if (!('supportsPlaceholder' in this) && this.supportsPlaceholder !== false && supportsPlaceholder) {
		this.Form.Placeholder = new Class({});
		return;
	}

	this.Form.Placeholder = new Class({
		Implements: Options,
		options: {
			placeholderClass: 'has-placeholder',
			clearOnSubmit: true
		},
		initialize: function(element, options) {
			this.setOptions(options);
			this.element = $(element);

			this.placeholder = this.element.get('placeholder');
			this.is_password = this.element.get('type') == 'password' ? true : false;

			this.activatePlaceholder();

			this.element.addEvents({
				'focus': this.deactivatePlaceholder.bind(this),
			    'blur': this.activatePlaceholder.bind(this)
			});

			if (this.element.getParent('form') && this.options.clearOnSubmit) {
				this.element.getParent('form').addEvent('submit', function(e){
					if (this.element.get('value') == this.placeholder) {
						this.element.set('value', '');
					}
				}.bind(this));
			}
		},
		activatePlaceholder: function() {
			if (this.element.get('value') == '') {
				if (this.is_password) {
					this.element.set('type', 'text');
				}
				this.element.addClass(this.options.placeholderClass);
				this.element.set('value', this.placeholder);
			}
		},
		deactivatePlaceholder: function() {
			if (this.element.get('value') == '') {
				if (this.is_password) {
					this.element.set('type', 'password');
				}
				this.element.set('value', '');
				this.element.removeClass(this.options.placeholderClass);
			}
		}
	});

	Class.refactor(Element, {
		get: function(prop) {
			var value = this.previous(prop);
			if (prop === 'value' && value !== '' && this.match('input[placeholder]') && value === this.get('placeholder') ) {
				value = '';
			}
			return value;
		}
	});

})();/**
 * These function helpers behave the exact same way as the event-pseudos.
 */
Function.implement({
	/**
	 * The function will only be invoked after the specified interval has passed.
	 * Calling the function multiple times will reset the timer.
	 * @param {Number|Integer} interval
	 * @param {Object} [bind]
	 * @return {Function}
	 */
	pause: function(interval, bind) {
		var fn = this, paused;
		return function() {
			clearTimeout(paused);
			paused = fn.delay(interval || 250, bind, arguments);
		};
	}
	,
	/**
	 * The function will only be invoked once per interval.
	 * Calling the function multiple times within the interval will be ignored,
	 * but the last call is always guaranteed to be invoked.
	 * @param {Number|Integer} interval
	 * @param {Object} [bind]
	 * @return {Function}
	 */
	pace: function(interval, bind) {
		var fn = this, throttled, throttledArgs;
		return function() {
			if (!throttled) {
				fn.apply(bind, arguments);
				throttledArgs = null;
				throttled = setInterval(function () {
					if (throttledArgs == null) {
						throttled = clearInterval(throttled);
					} else {
						fn.apply(bind, throttledArgs);
						throttledArgs = null;
					}
				}, interval || 250);
			} else {
				throttledArgs = arguments;
			}
		};
	}

	,
	/**
	 * Binds the function, just like bind.
	 * However, the first parameter will always be the "true this",
	 * and all other arguments will be shifed to the right.
	 *
	 * This is useful for event handlers, where you need a reference to the actual element.
	 * @param bind
	 * @return {Function}
	 */
	bindAndPassThis: function(bind) {
		var fn = this;
		return (function() {
			var args = Array.from(arguments);
			args.unshift(this);
			return fn.apply(bind, args);
		});
	}
});

// Set animation defaults:
Fx.implement({
	options: {
		transition: 'quint:out'
		,link: 'cancel'
	}
});
/**
 * MemoryEvents
 * Extends the MooTools Events functionality.
 * It remembers the last time each event was fired.
 * When you add an event handler, if the event has previously fired,
 * then the handler will be called immediately with the
 * same arguments.
 *
 * This provides an easy to use interface for dealing
 * with async event handlers.
 */
window.MemoryEvents = new Class({
	$memoryEvents: new Events()
	, $memoryEventArgs: {}

	/**
	 * Adds a callback for the specified event.
	 * If the event has previously fired,
	 * the callback will fire immediately.
	 */
	, addMemoryEvent: function (eventName, callback) {

		// Strip any pseudos:
		var type = eventName;
		if (type.indexOf(':') != -1){
			type = type.substr(0, type.indexOf(':'));
		}

		// Fire immediately if ready:
		var args = this.$memoryEventArgs[type];
		if (!args) {
			this.$memoryEvents.addEvent(eventName, callback);
		} else {
			// We want to fire ONLY this individual callback,
			// and NOT the existing ones, so we need to be tricky:

			var newEvents = new Events();
			// Add just this event:
			newEvents.addEvent(eventName, callback);
			// Fire the event:
			newEvents.fireEvent(type, args);

			// Let's merge the newEvents with the existingEvents.
			// We must manually do this, just in case the event
			// was removed (eg. ":once")
			var existingEvents = this.$memoryEvents;
			Object.each(newEvents.$events, function(handlers, eventName) {
				var existingHandlers = existingEvents.$events[eventName];
				if (!existingHandlers) {
					existingEvents.$events[eventName] = handlers;
				} else {
					// We MUST use handlers.each, because it's the only one that skips over deleted arrays!
					handlers.each(function(h){ existingHandlers.push(h); });
				}
			});

		}
	}

	/**
	 * Adds a callback for each of the specified events.
	 */
	, addMemoryEvents: function(events) {
		for (var type in events)
			this.addMemoryEvent(type, events[type]);
	}

	/**
	 * Fires the event.
	 * The event data will be remembered,
	 * so new callbacks will be immediately called.
	 */
	, fireMemoryEvent: function (eventName, args) {
		args = Array.from(args); // (Ensure it's an array)

		// Store the data:
		this.$memoryEventArgs[eventName] = args;

		// Fire the event:
		this.$memoryEvents.fireEvent(eventName, args);
	}

	/**
	 * Removes the attached callback.
	 */
	, removeMemoryEvent: function (eventName, callback) {
		this.$memoryEvents.removeEvent(eventName, callback);
	}

	/**
	 * Clears the last-fired event data.
	 */
	, clearMemoryEvent: function (eventName) {
		delete this.$memoryEventArgs[eventName];
	}

});

// This file detects and fixes bugs found in
// mootools-core-1.4.5.js or mootools-more-1.4.0.1.js

var Bugs = {
	tests: []
	,
	/**
	 * Runs the test
	 * @param {Function(Object)} test - The test will be run, and will be passed an object that should be used to store the results of the test.
	 */
	runTest: function(test) {
		this.tests.push(test);
		test.call(this, this);
	}
	,
	/**
	 * Runs the tests again, but returns the results as a new object.
	 * This should be used to verify that the bugs are fixed.
	 * @return {Object}
	 */
	runTestsAgain: function() {
		var results = {};
		this.tests.each(function(test){
			test.call(results, results);
		});
		return results;
	}
};

/*<ltIE9>*/
(function(){
	var bp = 'background-position', bP = 'backgroundPosition', bPX = bP + 'X', bPY = bP + 'Y';

	Bugs.runTest(function(Bugs) {
		var div = new Element('div')
			,initialBackgroundPosition = div.getStyle(bp)
			,resetBackgroundPosition = div.setStyle(bp, null).getStyle(bp);

		/**
		 * Fails when the "background-position" is not reset, because it's interpreted as "background-position-x" and "-y" in IE8
		 */
		Bugs.failsToResetBackgroundPosition = (initialBackgroundPosition !== resetBackgroundPosition);

		/**
		 * Fails when the "background-position" in a CSS rule is interpreted as "background-position-x" and "-y" in IE8
		 * Don't know how to test for this, so let's just assume it goes with the previous test.
		 */
		Bugs.failsToReadCSSBackgroundPosition = Bugs.failsToResetBackgroundPosition;
	});

	if (Bugs.failsToResetBackgroundPosition) {
		Class.refactor(Element, {
			setStyle: function(property, value) {
				if (!value && (property === bp || property === bP)) {
					this.previous(bPX, value);
					return this.previous(bPY, value);
				}
				return this.previous(property, value);
			}
		});
	}

	if (Bugs.failsToReadCSSBackgroundPosition) {
		Class.refactor(Element, {
			getStyle: function(property) {
				var value = this.previous(property);
				if (!value && (property === bp || property === bP)) {
					var x = this.previous(bPX), y = this.previous(bPY);
					if (x && y)
						value = x + ' ' + y;
				}
				return value;
			}
		});
	}
})();
/*</ltIE9>*/



// Test to see if all the bugs were fixed:
// TODO: Use Uverse.console instead of window.console
(function(){
	if (window.console) {
		var fixedResults = Bugs.runTestsAgain(), bugsFixed = [], bugsNotFixed = [];

		Object.each(fixedResults, function(bugStillExists, bugName) {
			var hasOriginalBug = Bugs[bugName];
			if (hasOriginalBug) {
				if (bugStillExists) {
					bugsNotFixed.push(bugName);
				} else {
					bugsFixed.push(bugName);
				}
			}
		});

		if (bugsFixed.length) {
			//window.console.log("[mootools.Bugs]", "The following bugs were fixed: ", bugsFixed.join(", "));
		}
		if (bugsNotFixed.length) {
			window.console.error("[mootools.Bugs]", "The following bugs were NOT fixed: ", bugsNotFixed.join(", "));
		}
	}
})();
/**
 * Extends the `Options` class with the ability to read options from Element attributes.
 */
window.OptionsFromAttributes = new Class({
	Extends: Options

	/**
	 * Sets the options by reading the "data-" attributes of an element.
	 * See `getOptionsFromAttributes` for more info.
	 */
	, setOptionsFromAttributes: function(settings) {
		return this.setOptions(this.getOptionsFromAttributes(settings));
	}

	/**
	 * Creates an Object from the "data-" attributes of an element, or from a custom attribute map.
	 * @param {Object} [settings]
	 * @param {Element} [settings.source] (defaults to `this.el`) The source element to read from
	 * @param {Object} [settings.map] (defaults loaded from `this.options`) An object that specifies the mapping from keys to attributes.
	 * @param {Object} [settings.options] (defaults to `this.options`) If there's no map, then this object's keys will be used to create the map.
	 * @return {Object}
	 */
	, getOptionsFromAttributes: function(settings) {
		settings = Object.append({
			source: this.el
			,options: this.options
			,map: null
		}, settings);
		var source = settings.source
			, options = settings.options
			, map = settings.map;

		// Create our default map from the "data-" attributes:
		if (!map) {
			map = {};
			for (var key in options) {
				map[key] = 'data-' + key.hyphenate();
			}
		}

		// Read all the attributes:
		var results = {};
		Object.each(map, function(attr, key){
			var attrVal = source.get(attr);
			if (attrVal !== null)
				results[key] = attrVal;
		});
		return results;
	}
});

(function(){


	/**
	 * This pseudo is a combination of "throttle" and "pause";
	 * it throttles the continuous firing of events, 
	 * but makes sure the last event is still fired.
	 * This is perfect for events like "scroll" and "resize".
	 * 
	 * Example:
	 * window.addEvent('resize:pace(500)', fn);
	*/
	Events.definePseudo('pace', pace);
	DOMEvent.definePseudo('pace', pace);


	function pace(split, fn, args) {
		if (!fn._throttled) {
			// First event
			var self = this;
			fn.apply(self, args);

			fn._throttledArgs = null;
			fn._throttledCount = 0;
			fn._throttled = setInterval(function(){
				if (fn._throttledCount === 0) {
					clearInterval(fn._throttled);
					fn._throttled = false;
				} else {
					fn.apply(self, fn._throttledArgs);
					fn._throttledArgs = null;
					fn._throttledCount = 0;
				}
			}, split.value || 250);
		} else {
			// Track if any events have been throttled:
			fn._throttledArgs = args;
			fn._throttledCount += 1;
		}
	}

})();
/**
 * This class is identical to `Request.HTML`,
 * except that it allows for "deferred" parsing
 * of the HTML response.
 *
 * This enables very lightweight background requests,
 * that don't "hiccup" the UI until the UI is needed.
 *
 * All features of Request.HTML are supported (update, append, filter, etc).
 */
Request.HTMLDeferred = new Class({
	Extends: Request.HTML
	,
	deferredResultsEnabled: false
	,
	deferredResults: null
	,
	success: function(text) {
		if (this.deferredResultsEnabled) {
			this.deferredResults = text;
		} else {
			this.parent(text);
		}
	}
	,
	/**
	 * Call this method to enable/disable the deferring of results.
	 *
	 * When defer is enabled, the parsing the HTML
	 * and the firing of the "success" event
	 * will be deferred until defer is disabled.
	 *
	 * @param {Boolean} enabled Determines if deferring is enabled.
	 */
	deferResults: function(enabled) {
		this.deferredResultsEnabled = enabled;
		if (!enabled && this.deferredResults !== null) {
			var text = this.deferredResults;
			this.deferredResults = null;
			this.success(text);
		}
	}
});
window.addEvent('domready', function () {
	var pageOptions = Uverse.config.pageOptions;
	Uverse.page = new Uverse.PageControl(pageOptions);
	Uverse.page.initializePageObjects();
	var loadedWidgets = Uverse.loader.processQueue();
	loadedWidgets.load(); // Not likely, but just in case.
});/**
 * Creates new instances of classes
 */
Uverse.Loader = new Class({
	queuedModules: []
	, loadedModules: []

	, initialize: function() {}
        
    /* Public methods */

    /**
     * Instantiates a new object of type module. The script is already loaded.
     * @param {object} data - see below
     * @param {object} data.loadOptions - general options to handle initialization of the object
     * @param {string} data.moduleName - namespaced string of class name
     * @param {string} data.id - element id
     * @param {object} data.options - module custom options
     */
	, load: function(data) {
		var loadOptions = data.loadOptions || {};
		var element = this._isModuleLoadErrorOrReturnElement(data.id);
		
		if(element) {
			var module = {
					loadOptions: loadOptions
					, name: data.moduleName
					, element: element
					, options: data.options
			};
			this.queuedModules.push(module);
		}
	}

	/**
	 * Processes the queue, returning all widgets.
	 *
	 * @param {Object} [options]
	 * @param {Boolean} [options.preventLazyLoad]  Prevents lazy-loading of any modules; errors will be thrown if lazy loading is attempted.
	 *                                             This is used by the Modal, because we don't support lazy-loading of modal content,
	 *                                             because it won't be canceled properly if the modal is closed.
	 *
	 * @return {Uverse.utils.LoadableList}
	 */
	, processQueue: function(options) {
		var preventLazyLoad = options && options.preventLazyLoad;
		var results = this.queuedModules.map(function(module) {
			return this._createModuleObjOrLoadScriptAndCreateModuleObj(module.loadOptions, module.name, module.element, module.options, preventLazyLoad);
		}, this);
		this.queuedModules.empty();
		this.loadedModules.empty();
		return new Uverse.utils.LoadableList(results);
	}
	
	, _createModuleObjOrLoadScriptAndCreateModuleObj: function(loadOptions, moduleName, element, options, preventLazyLoad) {
		var packages = moduleName.split('.');

		var constructor = this._createConstructorFromPackages(packages);

		if (!constructor) {
			this._warnIfNotLazyLoadableScript(loadOptions, moduleName, element, preventLazyLoad);
			return this._lazyLoadScriptAndCreateModuleObj(packages, element, options);
		} else {
			this._warnIfLazyLoadableScript(loadOptions, moduleName, element);
			return this._createModuleObj(constructor, element, options);
		}

	}

	, _lazyLoadScriptAndCreateModuleObj: function(packages, element, options) {
		var scriptPath = Uverse.config.scriptPath + packages.join("/") + '.js';

		var result = {
			request: null
			,widget: null
		};

		result.request = Asset.javascript(scriptPath, {
			onLoad: function() {
				var constructor = this._createConstructorFromPackages(packages);
				result.widget = this._createModuleObj(constructor, element, options);
			}.bind(this)
		});

		return result;
	}

	, _warnIfNotLazyLoadableScript: function(loadOptions, moduleName, element, preventLazyLoad) {
		if(!loadOptions.lazyLoadAllowed) {
			Uverse.console.error('[Loader]', 'Lazy Loading is not allowed for this module (' + moduleName + ' for element: ' + element.id + '). Please permanently add the module to the compiled script.');
		} else if (preventLazyLoad) {
			Uverse.console.error('[Loader]', 'Lazy Loading is not allowed for Modal contents!');
		}
	}
	    
	, _warnIfLazyLoadableScript: function(loadOptions, moduleName, element) {
		if(loadOptions.lazyLoadAllowed) {
			Uverse.console.error('[Loader]', 'Lazy Loading has been configured for this module (' + moduleName + ' for element: ' + element.id + ') but it\'s already compiled into the script');
		}
	}
	    
	, _createModuleObj: function(constructor, element, options) {
		return new constructor(element, options);
	}
	    
	, _createConstructorFromPackages: function(packages) {
		var constructor = window;
		try {
			packages.each(function(p) {
				constructor = constructor[p];
			});
			return constructor;
		} catch (e) {
			throw new Error('The package name (' + packages.join('.') + ') does not exist.');
		}
	}
	    
	, _isModuleLoadErrorOrReturnElement: function(id) {
		var element = $(id);
		if(this._isModuleAlreadyInitialized(id) || !this._doesModuleExistInDom(element, id)) {
			return null;
		}
	
		this.loadedModules.push(id);
		return element;
	}
	
	, _isModuleAlreadyInitialized: function(id) {
		if(this.loadedModules.contains(id)) {
			Uverse.console.error('[Loader]', 'Class for element (' + id + ') has already been initialized. There are duplicate IDs.');
			return true;
		}

		return false;
	}
	
	, _doesModuleExistInDom: function(element, id) {
		if(!element) {
			Uverse.console.error('[Loader]', 'Element (id: ' + id + ') does not exist in DOM');
			return false;
		}
	
		return true;
	}

});
    
Uverse.loader = new Uverse.Loader();
Uverse.load = Uverse.loader.load.bind(Uverse.loader);
Uverse.PageControl = new Class({
	Implements: [
		Options
		, MemoryEvents
	]

	, options: {
		pageContainerId: null
		,modalManagerOptions: {
			modalContainerId: null
			,modalShadowId: null
		}
	}

	, constantsCache: {}
	
	, personalization: null
	, elves: null
	, dvr: null
	, favorite: null
	, notification: null
	, shiny: null
	, unsupportedBrowsers: null
	, clickTracking: null
	, modalManager: null
	, deepLink: null
	, history: null

	, initialize: function (options) {
		this.setOptions(options);
	}

	, initializePageObjects: function () {
		this._createPersonalization();
		this._createDvr();
		this._createFavorite();
		this._createNotification();
		this._addWebtrends();
		this._addForesee();
		this._addGoogleAnalytics();
		this._createUnsupportedBrowsersDetection();
		this._createClickTracking();
		this._createModalManager();
		this._addPlaceholders();
		this._setupPageContainer();
		this._setupPlayerLoader();
		this._setupDeepLink();
		this._setupHistory();
	}

	, _addPlaceholders: function() {
		var support = ('placeholder' in document.createElement('input'));
		if(!support) {
			Uverse.console.log('[PageControl]', 'Adding support for placeholders');
			Object.each($$('input[placeholder]'), function(el) {
				try {
					new Form.Placeholder(el); 
				} catch(e) {
					Uverse.console.log('[PageControl]', 'Could not add placeholder for ' + el);
				}
			});
		}
	}

	, _setupPageContainer: function () {
		var pageContainerId = this.options.pageContainerId;
		var pageWidthOptions = {};

		new Uverse.widgets.PageWidth(pageContainerId, pageWidthOptions);
	}
	
	, _createPersonalization: function() {
		this.personalization = new Uverse.utils.Personalization({
			userDataComplete: this._onPersonalizationUserDataComplete.bind(this)
			, uverseDataComplete: this._onPersonalizationUverseDataComplete.bind(this)
		});
	}
	
	, _onPersonalizationUserDataComplete: function() {
		this._processCommonLocalization();
		this._fireUserDataLoggedInEvents();
		this.fireMemoryEvent('Personalization-userData', this.personalization.userData);
		this._addGoogleAnalyticsPersonalizationData(this.personalization.userData);
	}
	
	, _onPersonalizationUverseDataComplete: function() {
		this._fireUverseDataLoggedInEvents();
		this.fireMemoryEvent('Personalization-uverseData', this.personalization.uverseData);
		this.fireMemoryEvent('Notification-showList');
		this.fireMemoryEvent('Notification-userEmail');
		this.fireMemoryEvent('Favorite-assetList');
		this.fireMemoryEvent('Bookmarks-ready');
	}

	, getVideoBookmark: function(safeVideoKey) {
		return this.personalization.getVideoBookmark(safeVideoKey);
	}

	, setVideoBookmark: function(safeVideoKey, bookmark) {
		return this.personalization.setVideoBookmark(safeVideoKey, bookmark);
	}

	, _fireUserDataLoggedInEvents: function() {
		if(this.personalization.isLoggedIn()) {
			this._updateBodyTagUserStatus();
		}
	}
	
	, _fireUverseDataLoggedInEvents: function() {
		if(this.personalization.isLoggedIn()) {
			this._fireDvrTokenEvent();
		}
	}
	
	, isUserLoggedIn: function() {
		return this.personalization.isLoggedIn();
	}
	
	, isUverseUser: function() {
		return this.personalization.isUverseUser();
	}
	
	, _getPersonalizationData: function(name) {
		return this.personalization.getPersonalizationData(name);
	}
	
	, _fireDvrTokenEvent: function() {
		var dvrToken = this._getDvrToken();
		if(dvrToken) { this.fireMemoryEvent('Personalization-dvrToken', dvrToken); }
	}
	
	, _createDvr: function() {
		this.dvr = new Uverse.utils.Dvr({
			dvrRequestComplete: this._onDvrRequestComplete.bind(this)
			,dvrRequestFailure: this._onDvrRequestFailure.bind(this)
		});
	}
	
	, _onDvrRequestComplete: function() {
		this.fireMemoryEvent('Dvr-dvrItems');
	}
	, _onDvrRequestFailure: function() {
		this.fireMemoryEvent('Dvr-dvrItemsFailure');
	}

	, _getDvrToken: function() {
		return this.personalization.getPersonalizationData('dvrToken');
	}
	
	, getDvrRecordStateForItem: function(normalizedTitle, isSeries) {
		return this.dvr.getRecordStateForItem(normalizedTitle, isSeries);
	}
	
	, addDvrItem: function(epgInfo) {
		this.dvr.addNewItem(epgInfo);
		this.fireMemoryEvent('Dvr-dvrItems');
	}
	
	, _createFavorite: function() {
		this.favorite = new Uverse.utils.Favorite();
	}

	, getFavoriteStateForItem: function(favoriteID) {
		return this.favorite.getFavoriteStateForItem(favoriteID);
	}
	
	, favoriteAddItem: function(favoriteID) {
		this.personalization.favoriteAddItem(favoriteID);
		this.fireMemoryEvent('Favorite-assetList');
	}
	
	, favoriteRemoveItem: function(favoriteID) {
		this.personalization.favoriteRemoveItem(favoriteID);
		this.fireMemoryEvent('Favorite-assetList');
	}

	, updateUserSetting: function(key, value) {
		this.personalization.setPersonalizationData(key, value);
		this.fireMemoryEvent('Personalization-uverseData', this.personalization.uverseData);
	}

	, _createNotification: function() {
		this.notification = new Uverse.utils.Notification();
	}
	
	, getNotificationStateForItem: function(categoryPath) {
		return this.notification.getNotificationStateForItem(categoryPath);
	}
	
	, getNotificationUserEmail: function() {
		return this.notification.getUserEmail();
	}

	, notificationUserEmailChanged: function(email) {
		this.personalization.setNotificationUserEmail(email);
		this.fireMemoryEvent('Notification-userEmail');
	}
	
	, notificationAddCategoryPath: function(categoryPath) {
		this.personalization.notificationAddCategoryPath(categoryPath);
		this.fireMemoryEvent('Notification-showList');
	}
	
	, _updateBodyTagUserStatus: function() {
		document.body.addClass('userLoggedIn');
	}
	
	, _processCommonLocalization: function() {
		new Uverse.utils.CommonLocalization({ userZip: this.personalization.getUserZip() });
	}
	
	, getUserEntitlement: function() {
		return this.personalization.getUserEntitlement();
	}
	
	, isLoggedIn: function() {
		return this.personalization.isLoggedIn();
	}

	, _createShiny: function (){
		this.shiny = new Uverse.widgets.Shiny(document);
	}
	
	, _addWebtrends: function() {
		if(Uverse.config.webtrends) {
			new Uverse.utils.WebtrendsAPI();
		}
	}
	
	, _addForesee: function() {
		var foreseeEnabled = Uverse.config.foresee;
		if (foreseeEnabled) {
			new Uverse.utils.ForeseeAPI();
		}
	}
	/**
	 * Indicates that the splash screen is done (either suppressed or closed)
	 */
	, splashScreenIsDone: function(splashScreenWasDisplayed) {
		var foreseeEnabled = Uverse.config.foresee;
		if (foreseeEnabled && !splashScreenWasDisplayed) {
			new Uverse.utils.ForeseeAPI();
		}
	}
	
	, _addGoogleAnalytics: function() {
		if(Uverse.config.google_analytics) {
			this.googleAnalytics = new Uverse.utils.GoogleAnalyticsAPI();
		}
	}
	
	, googleAnalyticsPush: function(methodName, args) {
		if(Uverse.config.google_analytics) {
			this.googleAnalytics.api(methodName, args);
		}
	}
	
	,_addGoogleAnalyticsPersonalizationData: function(data) {
		this.googleAnalyticsPush('_setCustomVar', [1, 'User Type', (data.isLoggedIn ? (data.isUverse() ? 'Uverse User' : 'Non-Uverse User') : 'Non-User'), 2]);
		this.googleAnalyticsPush('_setCustomVar', [2, 'HSIA User', (data.isHSIA() ? 'HSIA User' : 'Non-HSIA User'), 1]);
		this.googleAnalyticsPush('_setDomainName', ['none']);
		this.googleAnalyticsPush('_setAllowHash', [false]);
		this.googleAnalyticsPush('_trackPageview');
	}

	, _createUnsupportedBrowsersDetection: function() {
		this.unsupportedBrowsers = new Uverse.utils.UnsupportedBrowsers;
	}
	
	, _createClickTracking: function() {
		if(Uverse.config.clickTracking && Uverse.config.clickTracking.enable) {
			this.clickTracking = new Uverse.utils.ClickTracking();
		}
	}

	/**
	 * @param {Object} [options]
	 * @param {Function} [options.callback]
	 * @param {String} [options.addCategory]
	 * @param {String} [options.addSubcategory]
	 * @param {String} [options.addAction]
	 * @param {String} [options.addLabel]
	 */
	, clickTrack: function(element, options) {
		if(!element || !this.clickTracking) { return; }
		
		var clickTrackOptions = {
			callback: function(){}
			, addCategory: null
			, addSubcategory: null
			, addAction: null
			, addLabel: null
		};
		
		this.clickTracking.track(element, Object.merge(clickTrackOptions, options));
	}
	
	, updateClickTrackAttribute: function(element, attributeNameSuffix, attributeValue) {
		if(!element || !this.clickTracking || !attributeNameSuffix) { return; }
		this.clickTracking.updateAttribute(element, attributeNameSuffix, attributeValue);
	}
	
	, getConstant: function(singletonName, constantPath) {
		if(this[singletonName]) {
			if(!this.constantsCache[singletonName + '_' + constantPath]) {
				var variablePath = this._iterateConstantPathToBuildVariable(singletonName, constantPath);
				this.constantsCache[singletonName + '_' + constantPath] = variablePath;
			}
			
			return this.constantsCache[singletonName + '_' + constantPath];
		}
		
		return null;
	}
	
	, _iterateConstantPathToBuildVariable: function(singletonName, constantPath) {
		var pathNames = constantPath.split('.');
		var objectPath = this[singletonName];
		pathNames.each(function(pathName) {
			objectPath = objectPath[pathName];
		});
		
		return objectPath;
	}

	, _createModalManager: function() {
		var options = this.options.modalManagerOptions;
		var callbacks = {
			'modalClosed': this._onModalClosed.bind(this)
		};
		this.modalManager = new Uverse.widgets.ModalManager(options, callbacks);
	}
	, _onModalClosed: function() {
		if (!this.history.historyChanging) {
			this.history.pushToHistory(null);
		}
		this.fireMemoryEvent('modalClosed');
	}
	, loadModal: function(modal) {
		this.modalManager.loadModal(modal);
		this.fireMemoryEvent('modalLoaded');
	}

	, _setupPlayerLoader: function() {
		var playerTemplate = $('playerTemplate').dispose();
		var options = {};
		var callbacks = {
			'loadModal': this.loadModal.bind(this)
		};
		this.playerLoader = new Uverse.widgets.PlayerLoader(playerTemplate, options, callbacks);
	}
	, _playVideo: function(videoInfo) {
		this.playerLoader.playVideo(videoInfo);
	}


	, _setupDeepLink: function() {
		var callbacks = {
			'deepLinkAction': this._onDeepLinkAction.bind(this)
		};
		this.deepLink = new Uverse.utils.DeepLink(callbacks);
	}
	, _onDeepLinkAction: function(deepLinkAction) {
		switch (deepLinkAction.action) {
			case 'playVideo':
				var videoInfo = Object.merge({}, deepLinkAction.data, deepLinkAction.historyData);
				this._playVideo(videoInfo);
				break;
			case 'base':
				this.modalManager.closeCurrentModal();
				break;
			default:
				Uverse.console.error("[PageControl]", "Not sure how to handle this deep link information: ", deepLinkAction);
				break;
		}
	}

	, _setupHistory: function() {
		var callbacks = {
			'historyChanged': this._onHistoryChanged.bind(this)
		};
		this.history = new Uverse.utils.History(callbacks);
		this.history.checkInitialUrl();
	}
	, _onHistoryChanged: function(urlInfo, historyData) {
		this.deepLink.processUrlInfo(urlInfo, historyData);
	}


	/**
	 * Pushes the URL to history, and processes the link information
	 * @param {String|Element|Location} url The url to parse, or a link element.
	 * @param {Object} [historyData] Additional information about the new state.  This information is not guaranteed to persist long.
	 * @param {Object} [historyOptions]
	 * @param {Boolean} [historyOptions.windowTitle]
	 * @param {Boolean} [historyOptions.replaceHistory] Determines whether the url gets added or replaces the browser's history
	 */
	, loadDeepLink: function(url, historyData, historyOptions) {
		var urlInfo = this.history.pushToHistory(url, historyData, historyOptions);
		this.deepLink.processUrlInfo(urlInfo, historyData);
	}
	/**
	 * Reloads the current url by processing the link information.
	 * The URL does not get pushed to history.
	 */
	, reloadCurrentUrl: function() {
		this.history.reloadCurrentUrl();
	}

});


(function(){

	var uverseConsole = getUverseConsole();

	Uverse.console = uverseConsole;
	if (Uverse.config.consoleEnabled) {
		Uverse.console.enable();
	}

	function getUverseConsole() {
		return extend(getEmptyConsole(), {
			enabled: false
			,
			enable: function(filterOptions) {
				if (window.console) {
					var windowConsole = window.console;
					if (filterOptions) {
						windowConsole = getFilteredConsole(filterOptions);
					}
					Uverse.console = extend(windowConsole, { enabled: true }, uverseConsole);
				} else {
					Uverse.console = uverseConsole;
				}
			}
			,
			disable: function() {
				Uverse.console = uverseConsole;
			}
			,
			/**
			 * Throws the error in a separate thread, so that execution can continue.
			 * @param {*} ex
			 */
			throwAway: function(ex) {
				setTimeout(function(){ throw ex; }, 1);
			}
		});
	}

	function getEmptyConsole() {
		return {
			/**
             * Same as debug
             * @param {...*} messages
             */
			log: function(messages){}
			,
			/**
             * Writes a message to the console, including a hyperlink to the line where it was called.
             * @param {...*} messages
             */
			debug: function(messages){}
			,
			/**
             * Writes a message to the console with the visual "info" icon and color coding and a hyperlink to the line where it was called.
             * @param {...*} messages
             */
			info: function(messages){}
			,
			/**
             * Writes a message to the console with the visual "warning" icon and color coding and a hyperlink to the line where it was called.
             * @param {...*} messages
             */
			warn: function(messages){}
			,
			/**
             * Writes a message to the console with the visual "error" icon and color coding and a hyperlink to the line where it was called.
             * @param {...*} messages
             */
			error: function(messages){}
			,
			/**
             * Tests that an expression is true. If not, it will write a message to the console and throw an exception.
             * @param {*} expression
             * @param {...*} messages
             */
			assert: function(expression, messages){}
			,
			/**
             * Clears the console.
             */
			clear: function(){}
			,
			/**
             * Prints an interactive listing of all properties of the object. This looks identical to the view that you would see in the DOM tab.
             * @param {*} object
             */
			dir: function(object){}
			,
			/**
             * Prints the XML source tree of an HTML or XML element. This looks identical to the view that you would see in the HTML tab. You can click on any node to inspect it in the HTML tab.
             * @param {Node} node
             */
			dirxml: function(node){}
			,
			/**
             * Prints an interactive stack trace of JavaScript execution at the point where it is called.
			 * The stack trace details the functions on the stack, as well as the values that were passed as arguments to each function. You can click each function to take you to its source in the Script tab, and click each argument value to inspect it in the DOM or HTML tabs.
             */
			trace: function(){}
			,
			/**
             * Writes a message to the console and opens a nested block to indent all future messages sent to the console. Call console.groupEnd() to close the block.
             * @param {...*} messages
             */
			group: function(messages){}
			,
			/**
             * Like console.group(), but the block is initially collapsed.
             * @param {...*} messages
             */
			groupCollapsed: function(messages){}
			,
			/**
             * Closes the most recently opened block created by a call to console.group() or console.groupCollapsed()
             */
			groupEnd: function(){}
			,
			/**
             * Creates a new timer under the given name. Call console.timeEnd(name) with the same name to stop the timer and print the time elapsed..
             * @param {String} name
             */
			time: function(name){}
			,
			/**
             * Stops a timer created by a call to console.time(name) and writes the time elapsed.
             * @param {String} name
             */
			timeEnd: function(name){}
			,
			/**
             * Creates a time stamp, which can be used together with HTTP traffic timing to measure when a certain piece of code was executed.
             * @param {String} name
             */
			timeStamp: function(name){}
			,
			/**
             * Turns on the JavaScript profiler. The optional argument title would contain the text to be printed in the header of the profile report.
             * @param {String} [title]
             */
			profile: function(title){}
			,
			/**
             * Turns off the JavaScript profiler and prints its report.
             */
			profileEnd: function(){}
			,
			/**
             * Writes the number of times that the line of code where count was called was executed. The optional argument title will print a message in addition to the number of the count.
             * @param {String} [title]
             */
			count: function(title){}
			,
			/**
             * Prints an error message together with an interactive stack trace of JavaScript execution at the point where the exception occurred.
             * @param {*} errorObject
             * @param {...*} [messages]
             */
			exception: function(errorObject, messages){}
			,
			/**
             * Allows to log provided data using tabular layout.
             * The method takes one required parameter that represents table like data (array of arrays or list of objects).
             * The other optional parameter can be used to specify columns and/or properties to be logged (see more here).
             * @param {*[]} data
             * @param {String[]} [columns]
             */
			table: function(data, columns){}

		};
	}

	function getFilteredConsole(filterOptions) {
		var filteredConsole = { filtered: true, filter: filterOptions };
		Object.each(uverseConsole, function(method, methodName) {
			// Don't filter uverseConsole methods:
			if (window.console[methodName] === uverseConsole[methodName])
				return;

			filteredConsole[methodName] = function() {
				var firstMessage = arguments[0];
				if (shouldFilter(filterOptions, methodName, firstMessage))
					return; // Filtered

				if (window.console[methodName]) {
					if (window.console[methodName].apply) {
						window.console[methodName].apply(window.console, arguments);
					} else {
						// IE cannot "apply" any console functions, so here's a workaround for up to 10 parameters:
						var a = arguments;
						window.console[methodName](a[0] || "", a[1] || "", a[2] || "", a[3] || "", a[4] || "", a[5] || "", a[6] || "", a[7] || "", a[8] || "", a[9] || "");
					}
				}
			}
		});
		return filteredConsole;
	}

	function extend() {
		var result = arguments[0];
		Array.each(arguments, function(obj, i) {
			if (i === 0) return;
			Object.each(obj, function (method, methodName) {
				if (!(methodName in result))
					result[methodName] = method;
			});
		});
		return result;
	}

	function shouldFilter(filterOptions, methodName, firstMessage) {
		if (filterOptions.include && !arrayContainsText(filterOptions.include, firstMessage)) {
			return true;
		}
		if (filterOptions.exclude && arrayContainsText(filterOptions.exclude, firstMessage)) {
			return true;
		}
		if (filterOptions.methods && !arrayContainsText(filterOptions.methods, methodName)) {
			return true;
		}

		return false;
	}

	function arrayContainsText(array, text) {
		return array.some(function(stringOrRegex) {
			return (stringOrRegex.exec ? !!stringOrRegex.exec(text) : stringOrRegex === text);
		});
	}

})();
Uverse.controls.BaseControl = new Class({
	Implements: [ OptionsFromAttributes ]

	, options: {
	}
	, el: null

	/** Overridable */
	, checkState: function() {
		// Do nothing.
	}

	/**
	 * Retrieves the `name` attribute of the control.
	 * If the control represents multiple inputs, then an array of names will be returned.
	 * @returns {String|String[]}
	 */
	, getName: function() {
		var input = this.input || (this.el.match('input, select, textarea') ? this.el : null);
		if (input) {
			return input.get('name');
		}
		input = this.el.getElements('input, select, textarea');
		if (input.length === 1) {
			return input[0].get('name');
		} else if (input.length > 1) {
			return input.get('name'); // Returns an array
		}
		return null;
	}

	/** Overridable
	 * Retrieves a hash of the control's current values.
	 * @return {Object}
	 */
	, serialize: function() {
		return this.el.serializeInputs();
	}

	/**
	 * Binds common events, if implemented in a subclass.
	 * If your class has any "on___" methods, they will be bound.
	 * @param {Object} [settings]
	 * @param {Boolean} [settings.spacePerformsClick] If true, then the element will be treated as a button:
	 *                                                hitting "space" will depress the button, and releasing
	 *                                                it will execute `this.onClick`.
	 */
	, setupBaseEventHandlers: function(settings) {
		['onClick','onMouseDown','onMouseUp','onKeyPress','onKeyDown','onKeyUp','onFocus','onBlur'].each(function(onEventName){
			var eventName = onEventName.substr(2).toLowerCase(); // Trim "on"
			if (this[onEventName]) {
				this[onEventName] = this[onEventName].bind(this); // Handle all binding
				this.el.addEvent(eventName, this[onEventName]);
			}
		}, this);

		if (settings && settings.spacePerformsClick) {
			var el = this.el;
			var self = this;

			addKeyDown();
		}

		function addKeyDown(){
			el.addEvent('keydown:keys(space):once', function(ev){
				self.setState('depressed', true);
				addKeyUp();
			});
		}
		function addKeyUp(){
			el.getDocument().addEvent('keyup:keys(space):once', function(ev){
				self.setState('depressed', false);
				addKeyDown();
				if (self.onClick && (el.match(ev.target) || el.contains(ev.target))) {
					self.onClick(ev);
				}
			});
		}
	}

	/**
	 * Automatically adds the 'hovered','focused', and 'depressed' classes to the control.
	 */
	, setupBaseStateHandlers: function() {
		var el = this.el;
		var self = this;

		el.addEvents({
			'mouseenter': function(ev) {
				self.setState('hovered', true);
			}
			,'mouseleave': function(ev) {
				self.setState('hovered', false);
			}
			,'focus': function(ev) {
				self.setState('focused', true);
			}
			,'blur': function(ev) {
				self.setState('focused', false);
			}
			,'mousedown': function(ev) {
				self.setState('depressed', true);
				el.getDocument().addEvent('mouseup:once', function(ev){
					self.setState('depressed', false);
				});
			}
		});
	}

	/**
	 * (Overridable)
	 * Provides a common interface for setting the control state.
	 */
	, setState: function(stateName, enabled){
		this.el[(enabled ? 'addClass' : 'removeClass')](stateName);
	}

	/**
	 * Returns the current state of the control.
	 * @param {String} [stateName] The name of the state.  If not supplied, returns a Hash of common states ('hovered','focused','depressed').
	 */
	, getState: function(stateName) {
		if (stateName) {
			return this.el.hasClass(stateName);
		}
		// Return a Hash of common states:
		var states = {};
		['hovered','focused','depressed'].each(function(stateName){
			states[stateName] = this.el.hasClass(stateName);
		}, this);
		return states;
	}

	/**
	 * Finds the element's parent form,
	 * and attempts to submit it,
	 * simulating the browser's default submit behavior.
	 * @return {Boolean} Returns True if the form was submitted, False otherwise.
	 */
	, submitForm: function(submitButton) {
		var parentForm = this.el.getClosest('form');
		if (parentForm) {
			// Create a mock event, so that we can tell if "stop" was called:
			var mockEv = {
				prevented: false
				,type: 'submit'
				,target: this.el
				,submitButton: submitButton
				,stop: function(){ this.prevented = true; }
				,preventDefault: function(){ this.prevented = true; }
				,stopPropagation: function(){ }
			}

			// Submit the form, simulating an actual submit by manually firing the event:
			parentForm.fireEvent('submit', [mockEv]);
			if (!mockEv.prevented) {
				parentForm.submit();
				return true;
			}
		}
		return false;
	}
});
Uverse.controls.Button = new Class({
	Extends: Uverse.controls.BaseControl
	, Implements: [ Callbacks ]
	, Binds: ['_onButtonClick']

	, options: {
	}
	, callbacks: {
		'changing': false
	}

	, el: null

	, initialize: function(el, callbacks) {
		this.el = $(el);
		this.setCallbacks(callbacks);

		// BaseControl methods:
		this.setupBaseEventHandlers({ spacePerformsClick: true });
		this.setupBaseStateHandlers();
	}

	/** Overrides base */
	, serialize: function() {
		return this.el.serializeInput(); // Buttons don't normally get serialized
	}

	/** Bound by base */
	, onClick: function(ev) {
		ev.preventDefault();
		var submitButton = this.el;
		var isSubmitting = this.submitForm(submitButton);
	}

});
Uverse.controls.Checkbox = new Class({
	Extends: Uverse.controls.BaseControl
	, Implements:[ Callbacks ]

	, options: {
	}

	, callbacks: {
		/**
		 * @param {Event} ev
		 * @param {BaseControl} control
		 * @param {Boolean} newValue
		 * @param {Boolean} oldValue
		 */
		'changing': null
	}

	, transitions: {
		'.control-favorites': {
			elements: { '.U-control-checkbox-check': { props: [ 'background-position' ] } }
		}
	}

	, el: null
	, input: null

	, initialize: function(el, callbacks) {
		this.el = $(el);
		this.input = this.el.getElement('input');
		this.setCallbacks(callbacks);

		// BaseControl methods:
		this.setupBaseStateHandlers();
		this.setupBaseEventHandlers({ spacePerformsClick: true });

		this.checkState();
	}

	/** Overrides base */
	, checkState: function() {
		this.setState('checked', this.input.checked);
	}

	/** Overrides base */
	, setState: function(stateName, enabled) {
		// Determine if there's a transition:
		var transition = null;
		Object.each(this.transitions, function(value, key) {
			if (this.el.match(key)) {
				transition = value;
			}
		}, this);

		this.el.transition(transition, function(){
			this.el[enabled ? 'addClass' : 'removeClass'](stateName);
		}, this);
	}



	/* Event Handlers */

	/** Bound by base */
	, onClick: function(ev){
		ev.preventDefault(); // Prevents duplicate events caused by labels
		this._toggle(ev);
	}

	, _toggle: function(ev) {
		this.input.checked = !this.input.checked;
		this.setState('checked', this.input.checked);

		this.callbacks['changing'](ev, this, this.input.checked, !this.input.checked);
	}

	/** Bound by base */
	, onMouseDown: function(ev){
		ev.preventDefault();
	}

});
Uverse.controls.DropDown = new Class({
	Extends: Uverse.controls.BaseControl
	, Implements: [ Callbacks ]
	, Binds: [ '_onLabelClick', '_openDropDown', '_closeDropDown', '_onDocumentClick', '_onControlsChanging', '_onControlsListItemSelected' ]

	, options: {
	}
	, callbacks: {
		/**
		 * @param {Event} ev
		 * @param {BaseControl} control
		 * @param {Boolean} newValue
		 * @param {Boolean} oldValue
		 */
		'changing': null
	}

	, el: null
	, dropDownSelection: null
	, dropDownContainer: null
	, dropDownControls: null
	, dropDownIsOpen: false

	, initialize: function(el, callbacks) {
		this.el = $(el);
		this.setCallbacks(callbacks);

		this._setupSelection();
		this._setupDropDownControls();

		// BaseControl methods:
		this.setupBaseEventHandlers({ spacePerformsClick: false });
		this.setupBaseStateHandlers();


	}

	, _setupSelection: function() {
		this.dropDownSelection = this.el.getElement('.U-control-dropdown-selection');
		this.dropDownSelection.addEvent('click', this._onLabelClick);
		this.el.addEvents({
			'mouseenter': this._openDropDown
			,'mouseleave': this._closeDropDown
		});
	}

	, _setupDropDownControls: function() {
		this.dropDownContainer = this.el.getElement('.U-control-dropdown-container');
		var commonCallbacks = {
			'changing': this._onControlsChanging
			,'listItemSelected': this._onControlsListItemSelected
		};
		var dropDownControls = this.dropDownContainer.getChildren();
		this.dropDownControls = dropDownControls.map(function(el){
			return Uverse.controls.Form.createControl(el, commonCallbacks);
		}, this);

		this.dropDownContainer.fade('hide');
	}

	, _onControlsChanging: function(ev, control, newValue, oldValue) {
		this.callbacks['changing'](ev, this, newValue, oldValue);
	}
	, _onControlsListItemSelected: function(ev, control, selectedText, selectedValue, isDefault) {
		this.dropDownSelection.getElement('.contents-go-here').set('text', selectedText);
		this.dropDownSelection.toggleClass('control-dropdown-selection-default', isDefault);
		this._closeDropDown();
	}

	, _onLabelClick: function(ev) {
		ev.preventDefault(); // Prevents duplicate events caused by labels
		this._openDropDown();
	}
	, _onDocumentClick: function(ev) {
		var target = $(ev.target);
		if (!this.el.contains(target)) {
			this._closeDropDown();
		}
	}

	, _toggleDropDown: function() {
		if (!this.dropDownIsOpen) {
			this._openDropDown();
		} else {
			this._closeDropDown();
		}
	}

	, _openDropDown: function() {
		if (this.dropDownIsOpen)
			return;
		this.dropDownIsOpen = true;

		this.el.addClass('dropdown-open');
		this.dropDownContainer.addClass('dropdown-container-open');
		this.dropDownContainer.set('tween', { transition: 'quad:out' }).fade('in');


		this.el.getDocument().addEvent('click', this._onDocumentClick);
	}

	, _closeDropDown: function() {
		if (!this.dropDownIsOpen)
			return;
		this.dropDownIsOpen = false;

		this.dropDownContainer.removeClass('dropdown-container-open');
		this.dropDownContainer.set('tween', { transition: 'quad:in' }).fade('out');
		this.el.removeClass('dropdown-open');

		this.el.getDocument().removeEvent('click', this._onDocumentClick);
	}

});/**
 * This control is the master control.
 * It should be used to initialize all sub-controls.
 * It manages all Uverse controls, and provides a common interface for them.
 */
Uverse.controls.Form = new Class({
	// Extends, Implements
    Implements: [
		Options
		, Callbacks
    ]
	, Binds: [
		'_onControlChanging'
		, '_onFormSubmit'
	]

    // Instance members
	, callbacks: {
		/**
		 * [Optional]
		 * Fires when any of the form's inputs are changing.
		 *
		 * @param {Event} ev - The actual Event that caused the change
		 * @param {BaseControl} control - The JS control that caused the changing event
		 * @param {String} newValue - The new value of the input
		 * @param {String} oldValue - The previous value of the input
		 */
		'changing': false

		/**
		 * [Optional]
		 * Fires when the user hits "Enter" or clicks a submit button.
		 * The submission will be prevented, unless the callback returns === `true`.
		 *
		 * @param {Event} ev - The event that caused the submission
		 * @param {Object} formValues - The serialized form values.
		 *
		 * @return {Boolean} If this callback returns === `true`, then the form will actually be submitted.
		 */
		,'submit': false
	}
	, options: {
		/*
		 * @param {String} [separator] When multiple inputs have the same name
		 * (eg, checkboxes or a multi-select), the values will be
		 * combined using this separator.
		 * If null, the values will be returned as an array.
		 */
		separator: null

		/*
		 * @param {String} [options.filterEmpty] If true, then elements with
		 * empty values will be ignored.
		 */
		, filterEmpty: false
	}

	, formElement: null
	, controls: null

	// Constructor
	, initialize: function (formElement, callbacks, options) {
		this.formElement = $(formElement);
		this.setCallbacks(callbacks);
		this.setOptions(options);

		this._setupForm();
		this._setupControls();
    }

	, _setupForm: function() {
		Uverse.console.assert(this.formElement.match('form'), "[Form]", "A Form element is required!");

		this.formElement.addEvent('submit', this._onFormSubmit);
	}

	, _setupControls: function() {
		var commonCallbacks = {
			'changing': this._onControlChanging
		};
		var controlElements = this.formElement.getElements('.U-control');
		this.controls = controlElements.map(function(el){
			return Uverse.controls.Form.createControl(el, commonCallbacks);
		}, this);
	}


	, _onControlChanging: function(ev, control, newValue, oldValue) {
		if (this.callbacks['changing']) {
			this.callbacks['changing'](ev, control, newValue, oldValue);
		}
	}
	, _onFormSubmit: function(ev) {
		if (this.callbacks['submit']) {
			var formValues = this.getValues();

			if (ev.submitButton) {
				// Augment "values" with the clicked button's value:
				var buttonValue = ev.submitButton.serializeInput();
				Element.mergeInputValues(formValues, buttonValue);
			}

			var result = this.callbacks['submit'](ev, formValues);
			if (result === true) {
				// Allow the form to be submitted (by doing nothing)
			} else {
				ev.preventDefault();
			}
		}
	}

	/**
	 * Bypasses the "submit" event, and immediately submits the form.
	 *
	 * Does not yet support "submit" buttons (which are normally serialized in the POST).
	 */
	, submit: function() {
		this.formElement.submit();
	}




	/**
	 * Returns the value of all input elements as an object of key-value pairs.
	 * @param {Object} [options]
	 * @param {String} [options.separator] When multiple inputs have the same name (eg, checkboxes or a multi-select), the values will be combined using this separator.
	 * @param {String} [options.filterEmpty] If true, then elements with empty values will be ignored
	 * @return {Object}
	 */
	, getValues: function(options) {
		var values = this.formElement.serializeInputs();

		// Apply the options:
		if (options) {
			options = Object.merge({}, this.options, options);
			if (options.filterEmpty) {
				values = Object.filter(values, function(value,key){
					return (!!value || value === 0);
				});
			}
			if (options.separator) {
				values = Object.map(values, function(value,key){
					if (typeOf(value) === 'array')
						return value.join(options.separator);
					return value;
				});
			}
		}
		return values;
	}

	/**
	 * Finds the input with the specified name and sets its value.
	 * @param {String} name - The name of the input
	 * @param {String|String[]} value - The value of the input
	 */
	, setValue: function(name, value) {
		var values = {};
		values[name] = value;
		this.setValues(values);
	}

	/**
	 * Deserializes all inputs using the specified serialized values.
	 * @param {Object|Hash} values - The serialized names and values
	 */
	, setValues: function(values) {
		this.formElement.deserializeInputs(values);

		// Make each control check for updated values:
		this.controls.each(function(control) {
			control.checkState();
		});
	}

}).extend({
	createControl: function(el, commonCallbacks) {
		// Create the appropriate control:
		if (el.hasClass('U-control-dropdown')) {
			return new Uverse.controls.DropDown(el, commonCallbacks);
		} else if (el.hasClass('U-control-list')) {
			return new Uverse.controls.List(el, commonCallbacks);
		} else if (el.hasClass('U-control-checkbox')) {
			return new Uverse.controls.Checkbox(el, commonCallbacks);
		} else if (el.hasClass('U-control-button')) {
			return new Uverse.controls.Button(el, commonCallbacks);
		} else if (el.hasClass('U-control-textbox')) {
			return new Uverse.controls.Textbox(el, commonCallbacks);
		}
		return null;
	}
});
Uverse.controls.List = new Class({
	Extends: Uverse.controls.BaseControl
	, Implements: [ Callbacks ]

	, options: {
	}
	, callbacks: {
		/**
		 * @param {Event} ev
		 * @param {BaseControl} control
		 * @param {Boolean} newValue
		 * @param {Boolean} oldValue
		 */
		'changing': null
		/**
		 * Called when an item was selected (by click or keyboard).
		 * Could be used to close a DropDown.
		 * @param {Event} ev
		 * @param {BaseControl} control
		 * @param {String} selectedText
		 * @param {String} selectedValue
		 * @param {Boolean} isDefault
		 */
		,'listItemSelected': false
	}

	, el: null
	, input: null

	, initialize: function(el, callbacks) {
		this.el = $(el);
		this.setCallbacks(callbacks);

		this.input = this.el.getElement('select');

		// BaseControl methods:
		this.setupBaseEventHandlers({ spacePerformsClick: false });
		this.setupBaseStateHandlers();
	}

	/** Bound by base */
	, onClick: function(ev) {
		// Figure out which item was clicked:
		var listItem = $(ev.target).getClosest('.U-control-list-item');

		if (listItem) {
			var isDisabled = listItem.hasClass('control-item-disabled');
			var isDefault = listItem.hasClass('control-item-default');
			if (!isDisabled) {
				var newValue = listItem.get('data-value');
				if (!listItem.hasClass('control-item-selected')) {
					this.el.getElements('.U-control-list-item.control-item-selected').removeClass('control-item-selected');
					listItem.addClass('control-item-selected');

					var oldValue = this.input.get('value');
					this.input.set('value', newValue);

					this.callbacks['changing'](ev, this, newValue, oldValue);
				}

				if (this.callbacks['listItemSelected']) {
					var selectedText = listItem.get('text');
					this.callbacks['listItemSelected'](ev, this, selectedText, newValue, isDefault);
				}
			}
		}

	 }

});
Uverse.controls.ScrollBar = new Class({
	Extends: Uverse.controls.BaseControl
	, Binds: [ '_onContentsScrolled', '_onContentsMouseWheel', '_onThumbDrag', '_onTrackDrag', '_onMouseUp' ]

	, options: {
		/**
		 * @param {String} direction Either 'vertical' or 'horizontal'.
		 */
		direction: null
		/**
		 * The element that scrolls
		 */
		, elementId: ''
		, repeatDelay: 200
	}

	, el: null
	, thumb: null
	, track: null
	, contents: null
	, scroller: null

	, vertical: true

	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);

		this.vertical = (this.options.direction === 'vertical');

		// BaseControl methods:
		this.setupBaseStateHandlers();
		this.setupBaseEventHandlers();

		this._setupElements();
		this._setupContents();

		this._updateThumbPosition();
	}
	, _setupElements: function() {
		this.thumb = this.el.getElement('.U-control-scrollbar-thumb');
		this.track = this.el.getElement('.U-control-scrollbar-track');
	}
	, _setupContents: function() {
		this.contents = $(this.options.elementId);
		this.contents.addEvents({
			'scroll': this._onContentsScrolled
			,'mousewheel': this._onContentsMouseWheel
		});

		this.scroller = new Fx.Scroll(this.contents, { wheelStops: false});
	}

	/* Event Handlers */

	/** Bound by base */
	, onMouseDown: function(ev) {
		if (ev.getMouseButton() !== 'left')
			return;

		if (this.thumb.contains(ev.target)) {
			this.thumbDragStart = ev.page;
			this.thumbDragPosition = this.thumb[this.vertical ? 'offsetTop' : 'offsetLeft'];

			document.addEvent('mousemove', this._onThumbDrag);
		} else if (this.track.contains(ev.target)) {
			this.trackDragStart = ev.page;
			var onTrackRepeat = function(){
				this._onTrackRepeat();
				this.trackDragTimer = onTrackRepeat.delay(this.options.repeatDelay);
			}.bind(this);
			onTrackRepeat();

			document.addEvent('mousemove', this._onTrackDrag)
		} else {
			return;
		}

		ev.preventDefault();
		document.addEvent('mouseup', this._onMouseUp);

		// Prevent IE from selecting text:
		$(document.html).addEvents({ 'dragstart': this._returnFalse, 'selectstart': this._returnFalse });

	}
	, _onThumbDrag: function(ev) {
		var axis = (this.vertical ? 'y' : 'x')
			,delta = (ev.page[axis] - this.thumbDragStart[axis])

			,trackSize = this.track.getSize()[axis]
			,thumbPosition = this.thumbDragPosition
			,percent = ((thumbPosition + delta) / trackSize)
		;

		this._setScrollPosition(percent, true);
	}
	, _onTrackDrag: function(ev) {
		this.trackDragStart = ev.page;
	}
	, _onTrackRepeat: function() {
		// Determine if we're above or below the track:
		var axis = (this.vertical ? 'y' : 'x')
			,mouse = this.trackDragStart
			,contentsSize = this.contents.getSize()[axis]
			,offset = this.thumb.getOffsets()[axis]
			,thumbSize = this.thumb.getSize()[axis]
			,direction = (mouse[axis] < offset) ? -1 : (mouse[axis] > offset + thumbSize) ? 1 : 0
			,factor = 0.5;
		if (!direction) {
			return;
		}
		var delta = (direction * factor * contentsSize);

		var instant = false;
		this._scrollDelta(delta, instant);
	}
	, _onMouseUp: function(ev) {
		document.removeEvent('mousemove', this._onThumbDrag);
		document.removeEvent('mousemove', this._onTrackDrag);
		document.removeEvent('mouseup', this._onMouseUp);

		$(document.html).removeEvents({ 'dragstart': this._returnFalse, 'selectstart': this._returnFalse });



		this.thumbDragStart = null;
		this.thumbDragPosition = null;

		if (this.trackDragTimer) {
			clearTimeout(this.trackDragTimer);
			this.trackDragTimer = null;
			this.trackDragStart = null;
		}
	}

	, _returnFalse: function(ev) {
		return false;
	}

	, _onContentsScrolled: function(ev) {
		this._updateThumbPosition();
	}
	, _onContentsMouseWheel: function(ev) {
		var wheelAmount = -ev.wheel;

		var axis = (this.vertical ? 'y' : 'x')
			,factor= 0.5
			,c = this.contents
			,size = c.getSize()[axis]
			;
		var delta = (wheelAmount * size * factor);

		if (this._scrollDelta(delta, false)) {
			ev.preventDefault();
		}

	}
	/**
	 * Scrolls the element by the specified amount.
	 * Returns false if the element can't scroll any further.
	 */
	, _scrollDelta: function(delta, instant) {
		var axis = (this.vertical ? 'y' : 'x')
			,c = this.contents
			,scroll = c.getScroll()[axis]
			,size = c.getSize()[axis]
			,scrollSize = c.getScrollSize()[axis]
			,position = (scroll + delta);

		if (this.scroller.isRunning()) {
			position = (this.lastScrollPosition + delta);
			this.scroller.cancel();
		}
		this.lastScrollPosition = position;

		if (position < 0) {
			position = 0;
		}
		if (position > (scrollSize - size)) {
			position = (scrollSize - size);
		}
		if (position === scroll) {
			return false;
		}


		this.scroller[instant ? 'set' : 'start'](this.vertical ? 0 : position, this.vertical ? position : 0);
		return true;
	}


	, _updateThumbPosition: function() {
		var axis = (this.vertical ? 'y' : 'x')
			,c = this.contents
			,scroll = c.getScroll()[axis]
			,scrollSize = c.getScrollSize()[axis]
			,size = c.getSize()[axis];
		var thumb = {
			percent: (scroll / scrollSize)
			,size: (size / scrollSize)
		};

		this._setThumbPosition(thumb.percent, thumb.size);
	}
	, _setThumbPosition: function(percent, size) {
		this.thumb.setStyle((this.vertical ? 'top' : 'left' ), (percent * 100).toFixed(1) + '%');
		if (size) {
			this.thumb.setStyle((this.vertical ? 'height' : 'width' ), (size * 100).toFixed(1) + '%');
			if (size > .999) {
				this.el.addClass('hidden');
			} else {
				this.el.removeClass('hidden');
			}
		}
	}
	, _setScrollPosition: function(percent, instant) {
		var axis = (this.vertical ? 'y' : 'x')
			,c = this.contents
			//,size = c.getSize()[axis]
			,scrollSize = c.getScrollSize()[axis]
			;
		var position = (percent * scrollSize);
		this.scroller[instant ? 'set' : 'start'](this.vertical ? 0 : position, this.vertical ? position : 0);
	}

}).extend({
	scrollBarTemplate: null
	, attachScrollBarTo: function(element, options) {
		// Set up default options:
		options = Object.merge({
			elementId: element
			,direction: 'vertical'
			,addClass: ''
		}, options);

		// Set up the template:
		if (!this.scrollBarTemplate) {
			this.scrollBarTemplate = $('scrollBarTemplate');
		}
		var scrollBarEl = this.scrollBarTemplate.clone();
		if (options.addClass) {
			scrollBarEl.addClass(options.addClass);
		}
		scrollBarEl.addClass((options.direction === 'vertical') ? 'vertical' : 'horizontal');

		element.grab(scrollBarEl, 'after');

		return new Uverse.controls.ScrollBar(scrollBarEl, options);
	}

});
Uverse.controls.Textbox = new Class({
	Extends: Uverse.controls.BaseControl
	, Implements: [ Callbacks ]
	, Binds: ['_onTextChanging']

	, options: {
	}
	, callbacks: {
		/**
		 * @param {Event} ev
		 * @param {BaseControl} control
		 * @param {String} newValue
		 * @param {String} oldValue
		 */
		'changing': null
	}

	, el: null

	, initialize: function(el, callbacks) {
		this.el = $(el);
		this.setCallbacks(callbacks);

		this.input = this.el;

		// BaseControl methods:
		this.setupBaseEventHandlers();
		this.setupBaseStateHandlers();

		this._setupEvents();
	}

	/** Overrides base */
	, serialize: function() {
		return this.el.serializeInput();
	}

	, _setupEvents: function(){
		this.input.addEvent('changing', this._onTextChanging);
	}

	, _onTextChanging: function(ev, el, newValue, oldValue){
		if (this.callbacks['changing']){
			this.callbacks['changing'](ev, this, newValue, oldValue);
		}
	}

});Uverse.utils.ClickTracking = new Class({
	request : null

	, attributeMap : {
		prefix : 'data-clicktrack-'
		, names : {
			category : 'category'
			, subcategory : 'subcategory'
			, action : 'action'
			, label : 'label'
		}
	}

	, classNameMap : {
		prefix : 'track-'
		, names : {
			category : 'hasCategory'
			, subcategory : 'hasSubcategory'
			, action : 'hasAction'
			, label : 'hasLabel'
		}
	}

	, callback: null

	, initialize : function() {
		this._setupRequest();
		this._addGlobalEvent();
	}

	, _setupRequest: function() {
		this.request = new Request({
			url: Uverse.config.clickTracking.url
			, method: 'POST'
			, link: 'chain'
			, onComplete: this._onRequestComplete.bind(this)
		});
	}

	, _onRequestComplete: function(xhr) {
		if (this.callback) {
			var isNavigatingAway = this.callback();
			if (isNavigatingAway === true)
				this.isNavigatingAway = isNavigatingAway;
			this.callback = null;
		}
	}

	, _addGlobalEvent: function() {
		$(document.body).addEvent('click:relay(.track)', this._onTrackElClicked.bind(this));
	}

	, _onTrackElClicked: function(ev, target) {
		var href = target.get('href');

		var options = null;
		if (this._shouldFollowLinkAfterClickTrack(ev, target)) {
			ev.preventDefault();
			options = {
				callback: function () {
					Uverse.console.log("[ClickTracking]", "Navigating to ", href);
					window.location = href;
					return true; // Indicates that we're navigating away
				}.bind(this)
			};
		}

		this.track(target, options);

	}
	
	, _shouldFollowLinkAfterClickTrack: function(ev, target) {
		var href = target.get('href');
		var isALink = !!href;
		var isHashBookmark = (href && href.indexOf('#') === 0) ? true : false;
		var opensInNewWindow = (target.get('target') == '_blank');
		var isLeftClick = (ev.getMouseButton() == 'left');
		var wasDefaultPrevented = ev.wasDefaultPrevented();

		return (!wasDefaultPrevented && isALink && !isHashBookmark && !opensInNewWindow && isLeftClick);
	}

	/**
	 * @param {Object} [options]
	 * @param {Function} [options.callback]
	 * @param {String} [options.addCategory]
	 * @param {String} [options.addSubcategory]
	 * @param {String} [options.addAction]
	 * @param {String} [options.addLabel]
	 */
	, track: function(element, options) {

		if (options && options.callback) {
			if (this.callback) {
				Uverse.console.log("[ClickTracking]", "Replacing callback");
			}
			// Only keep a single callback:
			this.callback = options.callback;
		}

		if (options) {
			this._updateAllAttributes(element, options.addCategory, options.addSubcategory, options.addAction, options.addLabel);
		}
		
		var trackingData = new Uverse.utils.ClickTracking.data(element, this.attributeMap, this.classNameMap);
		if (this._hasErrors(trackingData)) {
			this._onRequestComplete();
		} else {
			this._readyToTrack(trackingData);
		}
	}

	, _hasErrors: function(trackingData) {
		var errorMessage = false;
		if (!trackingData.hasValidData()) {
			errorMessage = "Click tracking could not be performed because trackingData is incomplete.";
		} else if (this.isNavigatingAway) {
			errorMessage = "Click tracking data: Cannot submit - browser is navigating away.";
		}
		if (errorMessage) {
			Uverse.console.warn("[ClickTracking]", errorMessage, trackingData.getData());
		}
		return !!errorMessage;
	}

	, _readyToTrack: function(trackingData) {
		Uverse.console.log("[ClickTracking]", "Click tracking data: ", trackingData.getData() );
		this.request.send({ data: trackingData.getData() });
	}
	
	, _updateAllAttributes: function(element, category, subcategory, action, label) {
		if(category) { this.updateAttribute(element, this.attributeMap.names.category, category); }
		if(subcategory) { this.updateAttribute(element, this.attributeMap.names.subcategory, subcategory); }
		if(action) { this.updateAttribute(element, this.attributeMap.names.action, action); }
		if(label) { this.updateAttribute(element, this.attributeMap.names.label, label); }
	}
	
	, updateAttribute: function(element, name, value) {
		element.set(this.attributeMap.prefix + name, value);
	}
});Uverse.utils.ClickTracking.data = new Class({
	el : null

	, data : {
		category : null
		, subcategory : null
		, action : null
		, label : null
	}

	, attributeMap: {}
	, classNameMap: {}

	, initialize : function(el, attributeMap, classNameMap) {
		this.el = el;
		this.attributeMap = attributeMap;
		this.classNameMap = classNameMap;
		this._getAllData();
	}

	, _getAllData : function() {
		this.data.category = this._findDataAttributeByName(this.el, 'category');
		this.data.subcategory = this._findDataAttributeByName(this.el, 'subcategory');
		this.data.action = this._findDataAttributeByName(this.el, 'action');
		this.data.label = this._findDataAttributeByName(this.el, 'label');
	}

	, _findDataAttributeByName : function(element, dataAttributeSuffix) {
		if (!element) { return null; }

		var attribuateValue = element.get(this._generateAttributeName(dataAttributeSuffix));
		if (attribuateValue && attribuateValue !== '') {
			return attribuateValue;
		} else {
			return this._findDataAttributeByName(this._getNextParent(element, dataAttributeSuffix), dataAttributeSuffix);
		}
	}

	, _getNextParent : function(element, dataAttributeSuffix) {
		return element.getParent('.' + this._generateClassName(dataAttributeSuffix));
	}

	, _generateAttributeName : function(dataAttributeSuffix) {
		return this.attributeMap.prefix + this.attributeMap.names[dataAttributeSuffix];
	}

	, _generateClassName : function(dataAttributeSuffix) {
		return this.classNameMap.prefix + this.classNameMap.names[dataAttributeSuffix];
	}

	, hasValidData : function() {
		if (
				(this.data.category && this.data.category !== '')
				|| (this.data.subcategory && this.data.subcategory !== '')
				|| (this.data.action && this.data.action !== '')) {
			return true;
		} else {
			return false;
		}
	}
	
	, getData: function() {
		return this.data;
	}
	
	, isALink: function() {
		return this.el.href ? true : false;
	}
});Uverse.utils.CommonLocalization = new Class({
	Implements: [Options]
	
	, userZip: ''
		
	, options : {
		userZip          : "",
		cookieDomains    : [],
		appname          : ""
	}
	
	, initialize: function(options) {
		this.setOptions(options);
		this._createZipCookies();
	}

	, _createZipCookies: function() {
		if (Uverse.config.cltDomainList && Uverse.config.cltAppName) {
			var cltOptions = {cookieDomains: App.storage.cltDomainList.split(','), appname: App.storage.cltAppName};
			
			if (this.options.userZip != null && this.options.userZip != "") {
				cltOptions.userZip = this.options.userZip;
				this._getClt();
			}
		}
	}
	
	, _getClt: function() {
		if (this.options.userZip != "") {
			if (!this._cookieExistsOnDomain() || !this._zipsMatch()) {
				this._createCookies();
			}
		} else {
			throw new Error("userZip option must be specified");
		}
	}
	
	, _getDomainUrls: function() {
		var domainUrls = this.options.cookieDomains, domainUrl;
		for (var x = 0; x < domainUrls.length; x++) {
			domainUrls[x] = 'http://' + domainUrls[x] + '/loc/controller?appid=' + this.options.appname + '&ltype=rev&zip=' + this.options.userZip;
		}
		return domainUrls;
	}
	
	, _cookieExistsOnDomain: function() {
		return ( Cookie.read("attPersistantLocalization") !== null );
	}
	
	, _zipsMatch: function() {
		return Cookie.read("attPersistantLocalization").indexOf("zip=" + this.options.userZip);
	}
	
	, _createCookies: function() {
		var domainUrls = this._getDomainUrls();
		// being that these are cross domain requests, we can't use ajax, so rather than using something inappropriate like a img
		// tag, best bet is an object tag. However, IE throws a fit if you try to create object tags and append them to the body,
		// so we'll go for the next best thing which is an iframe...
		domainUrls.each(function(domainUrl) {
			$(document.body).adopt(new Element('iframe', {'src': domainUrl, 'class' : 'hidden'}));
		});
	}
	
});/**
 * Processes deep-links by parsing the URL and looking for specific parameters.
 */
Uverse.utils.DeepLink = new Class({
	Implements: [ Callbacks ]

	, callbacks: {
		/**
		 * @param {Object} deepLinkAction
		 * @param {String} deepLinkAction.action
		 * @param {Object} deepLinkAction.data
		 */
		'deepLinkAction': null
	}

	, initialize: function(callbacks) {
		this.setCallbacks(callbacks);
	}

	, processUrlInfo: function(urlInfo, historyData) {
		// Parse the search & hash into an object:
		var urlData = null;
		if (urlInfo.search) {
			urlData = Object.merge({}, urlData, String.parseQueryString(urlInfo.search.substr(1)));
		}
		if (urlInfo.hash) {
			urlData = Object.merge({}, urlData, String.parseQueryString(urlInfo.hash.substr(1)));
		}

		var deepLinkAction;

		// Determine what action to take:
		if (urlData == null) {
			deepLinkAction = {
				action: 'base'
				,data: null
				,historyData: historyData
			};
		} else if (urlData['play']) {
			var videoInfo = {
				categoryPath: '/ng' + urlInfo.pathname.replace(/^\/uv\//, '/')
				,videoId: urlData['play']
			};
			deepLinkAction = {
				action: 'playVideo'
				,data: videoInfo
				,historyData: historyData
			};
		} else {
			deepLinkAction = {
				action: 'unknown'
				,data: null
				,historyData: historyData
			};
		}

		Uverse.console.log("[DeepLink]", "Deep Link Action: ", deepLinkAction.action);

		this.callbacks['deepLinkAction'](deepLinkAction);
	}
});

Uverse.utils.Dvr = new Class({
	Implements: [Callbacks]
	
	, callbacks: {
		dvrRequestComplete: null
		,dvrRequestFailure: null
	}

	, itemStates: {
		UNKNOWN: 'unknown'
		, CANNOT_BE_RECORDED: 'cannotBeRecorded'
		, CANNOT_BE_RECORDED_LOCAL: 'cannotBeRecorded-local'
		, CAN_BE_RECORDED: 'canBeRecorded'
		, RECORDED: {
			SINGLE: 'recorded-single'
			, SERIES: 'recorded-series'
		}
		, SET_TO_RECORD: {
			SINGLE: 'setToRecord-single'
			, SERIES: 'setToRecord-series'
			, SERIES_WITH_RERUNS: 'setToRecord-seriesWithReruns'
		}
	}
	        
	, dvrData: $H()
	, uniqueDvrData: $H()
	, dvrToken: null
	
	, initialize: function(callbacks) {
		this.setCallbacks(callbacks);
		
		Uverse.page.addMemoryEvent('Personalization-dvrToken:once', this._onTokenReceived.bind(this));
	}

	, _onTokenReceived: function(dvrToken) {
		this.dvrToken = dvrToken;
		this._makeDvrRequest();
	}
	
	, _makeDvrRequest: function() {
		new Request.JSON({
			url : Uverse.config.dvr.urls.dvrItems
			,data : {token : this.dvrToken}
			,method : 'get'
			,link : 'cancel'
			,onSuccess: this._onDvrRequestComplete.bind(this)
			,onFailure: this._onDvrRequestFailure.bind(this)
		}).send();
	}
	
	, _onDvrRequestFailure: function() {
		this.callbacks.dvrRequestFailure();
	}
	, _onDvrRequestComplete: function(data) {
		this.complete = true;
		this.dvrData = this._processDvrItems(data.dvrItems);
		this.callbacks.dvrRequestComplete();
	}
	
	, _processDvrItems: function(dvrItems) {
		var dvrData = $H();
		
		if (dvrItems) {
		
			dvrItems.each(function(item){

				var seriesKey = this.generateDvrStatusKey(item.normalizedProgramTitle);
				var episodeKey = this.generateDvrStatusKey(item.normalizedProgramTitle, item.normalizedEpisodeTitle);
				var latestKey = item.normalizedProgramTitle + '?latest';
				
				if (item.airTime) {
					//if there is an airTime we always have to store a unique item with airtime
					var uniqueKey = episodeKey + '$' + item.airTime;
					this.uniqueDvrData.set(uniqueKey, item);
				}
				
				var seriesItem = dvrData.get(seriesKey) || {seriesScheduled: item.seriesScheduled};
				var episodeItem = dvrData.get(episodeKey) || {};
				
				//alter canBeScheduled of series based on episode
				if (item.episodeRecorded || item.episodeScheduled || item.episodeConflicted || item.episodeRecording) 
					seriesItem.canBeScheduled = false;

				// Determine if the series has any episode scheduled
				if (item.episodeScheduled) {
					seriesItem.hasEpisodeScheduled = true;
				}
				if (item.isRerunsIncluded) {
					seriesItem.hasRerunsIncluded = true;
				}

				//alter seriesScheduled of series based on episode
				if (item.seriesScheduled) 
					seriesItem.seriesScheduled = true;
				
				//merge series and episode flags
				var trueFlags = $H(item).filter(this._filterTrueFlags);
				episodeItem = Object.merge(episodeItem, trueFlags.getClean());
				
				//also store latest episode, only used for movies for now
				if (!dvrData.has(latestKey)) {
					dvrData.set(latestKey, item);
				} else {
					var latest = dvrData.get(latestKey);
					if (item.airTime > latest.airTime) {
						dvrData.set(latestKey, item);
					}
				}
				
				dvrData.set(seriesKey, seriesItem);
				dvrData.set(episodeKey, episodeItem);
				
				if(seriesKey !== episodeKey) {
					dvrData.set(episodeKey, episodeItem);
				}
			
			}, this);
		}
		
		return dvrData;
	}
	
	/**
	 * build a guide item key from the 2 titles
	 */
	, generateDvrStatusKey: function(programTitle, episodeTitle) {
		return (episodeTitle) ? programTitle + ':' + episodeTitle : programTitle;
	}
	
	/**
	 * returns the value of a sub-set of flags or false if not in the sub-set
	 * used in filtering a DVR item hash
	 */
	, _filterTrueFlags: function(value, key) {
		switch (key) {
			case 'episodeRecorded':
			case 'episodeScheduled':
			case 'episodeConflicted':
			case 'episodeRecording':
			case 'seriesScheduled':
				return value;
			default:
				return false;
		}
	}
	
	, isComplete: function() {
		return this.complete;
	}
	
	, getRecordStateForItem: function(normalizedTitle, isSeries) {
		var dvrItem = this.dvrData.get(normalizedTitle);
		if(dvrItem) {
			if (dvrItem.seriesScheduled || dvrItem.hasEpisodeScheduled || dvrItem.episodeScheduled) {
				if(isSeries && dvrItem.hasRerunsIncluded) {
					return this.itemStates.SET_TO_RECORD.SERIES_WITH_RERUNS;
				} else if(isSeries) {
					return this.itemStates.SET_TO_RECORD.SERIES;
				} else {
					return this.itemStates.SET_TO_RECORD.SINGLE;
				}
			} else {
				if(isSeries) {
					return this.itemStates.RECORDED.SERIES;
				} else {
					return this.itemStates.RECORDED.SINGLE;
				}
			}
		} else {
			return this.itemStates.UNKNOWN;
		}
	}
	
	, getItemStateSingleSeriesNameFromType: function(type) {
		return type == 'movies' ? 'SINGLE' : 'SERIES';
	}
	
	, isSeriesFromType: function(type) {
		return type == 'movies' ? false : true;
	}
	
	, addNewItem: function(epgInfo) {
		this.dvrData[epgInfo.normalizedProgramTitle] = epgInfo;
	}
	
});Uverse.utils.Entitlement = new Class({

    ALLOWED: 'allowed'
	, NEED_UPGRADE: 'upgrade'
	, NEED_ORDER: 'order'
	, NEED_LOGIN: 'login'

	, compareEntitlement: function(assetEntitlement) {
    	
		if(assetEntitlement === '') {
    		return this.ALLOWED;
    	}
		
		if(assetEntitlement !== '' && !Uverse.page.isLoggedIn()) {
			return this.NEED_LOGIN;
		}
    	
    	if (Uverse.page.isLoggedIn() && !Uverse.page.isUverseUser()) {
			return this.NEED_ORDER;
		}
    	
    	if(!Uverse.page.isLoggedIn() && assetEntitlement !== '') {
    		return this.NEED_UPGRADE;
    	}

		var userEntitlement = Uverse.page.getUserEntitlement().hash;

		var match = assetEntitlement.split(',').some(function(assetEntitlementItem) {
			if(userEntitlement.get(assetEntitlementItem)) {
				return true;
			}
		});
		
		return match ? this.ALLOWED : this.NEED_UPGRADE;
	}
	
	, promptUserForLogin: function(iconName) {
		var template = $('entitlementTemplate').clone();
		var text = $('entitlementTemplateItems').getElement('.' + iconName).get('html');
		template.getElement('.description').set('html', text);

		return template;
	}

	, promptUserForOrder: function(iconName, entitlementMessageBase) {
		var template = $('entitlementOrderTemplate').clone();
		var text = $('entitlementUpgradeItemsTemplate').getElement('.' + iconName).get('html');
		template.getElement('.description .custom').set('html', text);
		template.getElement('.description .base').set('html', entitlementMessageBase);
		return template;
	}

	, promptUserForUpgrade: function(iconName, entitlementMessageBase) {
		var template = $('entitlementUpgradeTemplate').clone();
		var text = $('entitlementUpgradeItemsTemplate').getElement('.' + iconName).get('html');
		template.getElement('.description .custom').set('html', text);
		template.getElement('.description .base').set('html', entitlementMessageBase);
		return template;
	}
});Uverse.utils.EpgInfo = new Class({
	Implements: [Options, Callbacks]
	
	, request: null
	, options: {
		normalizedProgramTitle: ''
		, normalizedEpisodeTitle: ''
		, dateFormat: '%a %m/%d at %l:%M%p'
	}
	, callbacks: {
		onEpgInfoRecieved: null
		, onEpgInfoFailed: null
	}
	
	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
		
		this.request = new Request.JSON({
			url: Uverse.config.dvr.urls.epgInfo
			, data: this.options
			, method: 'get'
			, noCache: true
			, onSuccess: this._onSuccess.bind(this)
			, onFailure: this._onFailure.bind(this)
		}).send();
	}
	
	, _onSuccess: function(json) {
		var guideItemValues = {};
		var channel = {};
		
		if(json.guideItem) {

			var airDate = json.guideItem.airDate;
			var dateString = ""
			if (typeof airDate === 'number') {
				date = new Date(airDate); 
				dateString = date.format(this.options.dateFormat);
				
				var tzName = this._parseTzNameFromBrowserDateToString(date);
				if(tzName) { dateString += " " + tzName; }
			} else {
				dateString = airDate;
			}
			
			guideItemValues.airDate = {
				friendlyFormat: dateString
			};
			guideItemValues.programID = json.guideItem.programId;
			guideItemValues.isHD = json.guideItem.hd;
			channel = {
				name: json.guideItem.channel.callLetters
				, number: json.channelLineup.channelNumber
			};
		}
		
		this.callbacks.onEpgInfoRecieved({
			canBeRecorded: json.epgStatus.canBeScheduled
			, hasUpcomingEpisode: json.epgStatus.hasUpcomingEpisode
			, normalizedProgramTitle: json.epgStatus.normalizedProgramTitle
			, normalizedEpisodeTitle: json.epgStatus.normalizedEpisodeTitle
			, airDate: guideItemValues.airDate
			, programID: guideItemValues.programID
			, isHD: guideItemValues.isHD
			, channel: channel
		});
	}
	
	, _parseTzNameFromBrowserDateToString: function(date) {
		var tzPattern = /(\(([A-Za-z ]+)\)|([A-Z]{3}) [0-9]{4})/g;
		var tzMatch = tzPattern.exec(String(date));
		if (tzMatch) {
			if (tzMatch[2]) {
				return tzMatch[2].replace(/[a-z ]/g,"");
			} else if (tzMatch[3]) {
				return tzMatch[3];
			}
		}
		
		return null;
	}
	
	, _onFailure: function() {
		this.callbacks.onEpgInfoFailed();
	}
	
	, cancelRequest: function() {
		this.request.cancel();
	}
});Uverse.utils.Favorite = new Class({
	favoriteData: $H()
	
	, itemStates: {
		SAVED: 'saved'
		, NOT_SAVED: 'notSaved'
	}
	
	, initialize: function() {
		if(Uverse.page.isUserLoggedIn()) {
			Uverse.page.addMemoryEvent('Favorite-assetList', this._onUverseData.bind(this));
		}
	}

	, _onUverseData: function() {
		this.favoriteData = Uverse.page._getPersonalizationData('library');
	}
	
	, getFavoriteStateForItem: function(favoriteID) {
		return this.favoriteData.contains(favoriteID) ? this.itemStates.SAVED : this.itemStates.NOT_SAVED;
	}
	
	, getFavoriteCount: function() {
		return this.favoriteData.length;
	}
});Uverse.utils.History = new Class({
	Implements: [ Callbacks ]
	,Binds: ['_checkForChanges' ]


	, callbacks: {
		/**
		 * Fires when the user initiates a history change,
		 * such has hitting the browser's Forward/Back buttons,
		 * or navigating to a deep-linked bookmark.
		 *
		 * urlInfo contains the normalized url.
		 *
		 * @param {Object} urlInfo
		 * @param {String} urlInfo.href
		 * @param {String} urlInfo.pathname
		 * @param {String} urlInfo.hash
		 *
		 * @param {Object} [historyData]
		 */
		'historyChanged': null
	}

	, baseUrlInfo: null
	, currentUrlInfo: null
	, initialWindowTitle: null

	, timer: null
	, pushStateEnabled: false

	, historyChanging: false

	, initialize: function(callbacks) {
		this.setCallbacks(callbacks);

		this.pushStateEnabled = ('pushState' in window.history);

		if (this.pushStateEnabled) {
			Element.NativeEvents['popstate'] = 2;
			window.addEvent('popstate', this._checkForChanges);
		} else {
			this.historyDataCache = {};
		}

		if ('onhashchange' in window) {
			Element.NativeEvents['hashchange'] = 1;
			window.addEvent('hashchange', this._checkForChanges);
		} else {
			this.timer = this._checkForChanges.periodical(200);
		}
	}

	, checkInitialUrl: function() {
		// Grab the base url:
		var baseUrlInfo = this._parseUrl(window.location);
		this.baseUrlInfo = this.currentUrlInfo = baseUrlInfo;
		this.initialWindowTitle = document.title;
		if (baseUrlInfo.hash || baseUrlInfo.search) {
			if (baseUrlInfo.hash) {
				// Clear the hash:
				baseUrlInfo = this._parseUrl(baseUrlInfo.pathname + baseUrlInfo.search);
				this.baseUrlInfo = this.currentUrlInfo = baseUrlInfo;
			}

			// Fire our callback for our initial state:
			this._checkForChanges(true);
		}
	}
	, reloadCurrentUrl: function() {
		this._checkForChanges(true);
	}

	/**
	 * @param {String|Element|Location} url The url to parse, or a link element.
	 * @param {Object} [historyData] An optional "state" object that can be used when history is popped.
	 * @param {Object} [historyOptions]
	 * @param {Boolean} [historyOptions.windowTitle]
	 * @param {Boolean} [historyOptions.replaceHistory] Determines whether the url gets added or replaces the browser's history
	 */
	, pushToHistory: function(url, historyData, historyOptions) {
		if (url === null) {
			url = this.baseUrlInfo.pathname;
		}
		historyOptions = Object.merge({
			windowTitle: null
			,replaceHistory: true
		}, historyOptions);


		var urlInfo = this._parseUrl(url, this.baseUrlInfo);
		this.currentUrlInfo = urlInfo;

		var windowTitle = this._getWindowTitle(historyOptions.windowTitle);

		if (this.pushStateEnabled) {
			var method = (historyOptions.replaceHistory ? 'replaceState' : 'pushState');
			window.history[method](historyData, windowTitle, url);
		} else {
			if (historyData) {
				this.historyDataCache[urlInfo.href] = historyData;
			}
			var hash = urlInfo.relativeUrl || '/'; // Don't allow empty hashes, because that'll scroll to top
			window.location.hash = hash;
		}
		document.title = windowTitle;

		return urlInfo;
	}

	, _getWindowTitle: function(title) {
		if (title == null) {
			return this.initialWindowTitle;
		}

		// Grab the last part after the ' - '
		var split = ' - ';
		var suffix = this.initialWindowTitle.split(split);
		suffix = suffix[suffix.length - 1];

		return title + split + suffix;
	}



	, _checkForChanges: function(ev) {
		var urlInfo = this._getCurrentUrlInfo();

		var overrideChanging = (ev === true);

		// Check for changes:
		if (overrideChanging || this.currentUrlInfo.href !== urlInfo.href) {
			this.historyChanging = true;
			this.currentUrlInfo = urlInfo;

			var historyData;
			if (this.pushStateEnabled) {
				historyData = (ev && ev.event && ev.event.state) || window.history.state;
			} else {
				historyData = this.historyDataCache[urlInfo.href];
			}
			this.callbacks['historyChanged'](urlInfo, historyData || null);
			this.historyChanging = false;
		}
	}

	, _getCurrentUrlInfo: function(){
		var urlInfo = this._parseUrl(window.location, this.baseUrlInfo);
		urlInfo = this._normalizeUrlInfo(urlInfo);
		return urlInfo;
	}

	/**
	 * Parses any url, including relative, root, and absolute.
	 *
	 * @param {String|Location|Link} url Can be either a string, window.location, or a Link Element
	 * @param {Object} [relative] The base url to use to generate the relativeUrl.
	 *
	 * @returns {String} urlInfo.href
	 * @returns {String} urlInfo.pathname
	 * @returns {String} urlInfo.search
	 * @returns {String} urlInfo.hash
	 * @returns {String} [urlInfo.relativeUrl]
	 */
	, _parseUrl: function(url, relative) {
		var location;
		if (typeof url === 'string') {
			if (!this.parsingLink) {
				this.parsingLink = new Element('a'); // Link Elements implement the same API as window.Location
			}
			this.parsingLink.href = url;
			location = this.parsingLink;
		} else {
			location = url;
		}

		var urlInfo = {
			href: location.href
			,pathname: location.pathname.replace(/^\/?/, '/') // Normalize leading slash (IE)
			,search: location.search
			,hash: location.hash
		};


		// Determine the relative path:
		if (relative) {
			var basePath = relative.pathname + relative.search;
			var urlPath = urlInfo.pathname + urlInfo.search;
			// Determine if it's path-relative or root-relative:
			if (basePath === urlPath) {
				urlInfo.relativeUrl = urlInfo.hash;
			} else {
				urlInfo.relativeUrl = urlInfo.pathname + urlInfo.hash;
			}
		}

		return urlInfo;
	}
	, _normalizeUrlInfo: function(urlInfo) {

		// Extract the path from the hash:
		if (urlInfo.hash && (urlInfo.hash.charAt(1) === '/')) {
			var newUrl = urlInfo.hash.substr(1);
			if (newUrl === '/') {
				// A single slash maps to the current url (because an empty hash scrolls to top)
				newUrl = '';
			}
			urlInfo = this._parseUrl(newUrl);
		}

		return urlInfo;
	}


});/**
 * This is a generic interface for content that is loadable and unloadable.
 * This interface should be implemented by any class that might be loaded in a Modal,
 * so that it can be properly destroyed when the modal is closed.
 * @type {Class}
 */
Uverse.utils.Loadable = new Class({
	implementsLoadable: true
	, load: function() { }
	, unload: function() { }
	, destroy: function() { }
});

Uverse.utils.LoadableList = new Class({
	Implements: Uverse.utils.Loadable
	, list: null
	, initialize: function(list) {
		this.list = list;
	}

	/** Overrides Loadable */
	, load: function() {
		this._eachLoadable(function(item){ item.load(); });
	}

	/** Overrides Loadable */
	, unload: function() {
		this._eachLoadable(function(item){ item.unload(); });
	}

	/** Overrides Loadable */
	, destroy: function() {
		this._eachLoadable(function(item){ item.destroy(); });
	}

	, _eachLoadable: function(method) {
		this.list.each(function(item) {
			if (item && item.implementsLoadable) {
				method(item);
			}
		});
	}
});Uverse.utils.Notification = new Class({
	notificationData: $H()
	
	, itemStates: {
		NOTIFIED: 'notified'
		, NOT_NOTIFIED: 'notNotified'
	}
	, userEmail: null
	, showList: []
	
	, initialize: function() {
		if(Uverse.page.isUserLoggedIn()) {
			Uverse.page.addMemoryEvent('Notification-showList', this._onShowListRetrieved.bind(this));
			Uverse.page.addMemoryEvent('Notification-userEmail', this._onUserEmailRetrieved.bind(this));
		}
	}

	, _onShowListRetrieved: function() {
		this.showList = Uverse.page._getPersonalizationData('notifications').episodes;
	}
	
	, _onUserEmailRetrieved: function() {
		this.userEmail = Uverse.page._getPersonalizationData('notifications').emailAddr;
	}
	
	, getNotificationStateForItem: function(categoryPath) {
		return this.showList.contains(categoryPath) ? this.itemStates.NOTIFIED : this.itemStates.NOT_NOTIFIED;
	}
	
	, getUserEmail: function() {
		return this.userEmail;
	}
});Uverse.utils.Personalization = new Class({
	Implements: [Callbacks]
	
	, callbacks: {
		userDataComplete: null
		, uverseDataComplete: null
	}
	, userData: null
	, uverseData: null
	
	, initialize: function(callbacks) {
		this.setCallbacks(callbacks);
		this._fetchUserData();
		this._fetchUverseData();
	}

	, _fetchUserData: function() {
		this.userData = new Uverse.utils.Personalization.UserData();
		this.callbacks.userDataComplete.delay(0);
	}
	
	, _fetchUverseData: function() {
		this.uverseData = new Uverse.utils.Personalization.UverseData();
		
		if(this.userData.isLoggedIn()) {
			this.uverseData.requestData({
				onComplete: this._onUverseDataComplete.bind(this)
			});
		} else {
			this._onUverseDataComplete();
		}
	}
	
	, _onUverseDataComplete: function() {
		this.callbacks.uverseDataComplete.delay(0);
	}

	, isUserDataComplete: function() {
		return this.userData.complete;
	}
	
	, isUverseDataComplete: function() {
		return this.uverseData.complete;
	}
	
	, isLoggedIn: function() {
		return this.userData.isLoggedIn();
	}
	
	, getUsername: function() {
		return this.userData.getUsername();
	}
	
	, getUserZip: function() {
		return this.userData.getZip();
	}
	
	, getUserEntitlement: function() {
		return this.userData.getUserEntitlement();
	}
	
	, isUverseUser: function() {
		return this.userData.isUverse();
	}
	
	, getPersonalizationData: function(name) {
		return this.uverseData.getPersonalizationData(name);
	}
	, setPersonalizationData: function(name, value) {
		return this.uverseData.setPersonalizationData(name, value);
	}
	
	, favoriteAddItem: function(videoID) {
		this.uverseData.favoriteAddItem(videoID);
	}
	
	, favoriteRemoveItem: function(videoID) {
		this.uverseData.favoriteRemoveItem(videoID);
	}

	, setNotificationUserEmail: function(email) {
		this.uverseData.setNotificationUserEmail(email);
	}
	
	, notificationAddCategoryPath: function(categoryPath) {
		this.uverseData.notificationAddCategoryPath(categoryPath);
	}

	, getVideoBookmark: function(safeVideoKey) {
		return this.uverseData.getVideoBookmark(safeVideoKey);
	}

	, setVideoBookmark: function(safeVideoKey, bookmark) {
		return this.uverseData.setVideoBookmark(safeVideoKey, bookmark);
	}

});

Uverse.utils.Personalization.UserData = new Class({
	cookieNames: {
		USERNAME: 'NEXTGEN_NAME'
		, ENTITLEMENT: 'NEXTGEN_PACKAGES'
		, LOGINPORTAL: 'ATTNETSSOCKSTR'
		, UVERSE: 'NEXTGEN_UVERSE'
		, HSIA: 'NEXTGEN_HSIA'
		, ZIP: 'NEXTGEN_ZIP'
	}

	, username: null
	, entitlementPackages: {
		string: '',
		list: []
	}
	, loginPortal: null
	, uverseUser: false
	, hsia: false
	, zip: null
	, complete: false
	
	, initialize: function() {
		this._getUserInfoFromCookie();
		this.complete = true;
	}
	
	, _getUserInfoFromCookie: function() {
		this._getCookieUsername();
		this._getCookieForLoginPortal();
		this._getCookieForHSIA();
		
		if(this.isLoggedIn()) {
			this._getCookieForEntitlement();
			this._getCookieForUverse();
			this._getCookieForZip();
		}
	}
	
	, _getCookieUsername: function() {
		this.username = Cookie.read(this.cookieNames.USERNAME);
	}
	
	, _getCookieForEntitlement: function() {
		var cookieValue = Cookie.read(this.cookieNames.ENTITLEMENT);
		
		if(cookieValue) {
			cookieValue = cookieValue.replace(/"/g, "");
			this.entitlementPackages.string = cookieValue;
			this.entitlementPackages.list = this.entitlementPackages.string.split(',');
			
			var tempHash = $H();
			this.entitlementPackages.list.each(function(item) { tempHash[item] = true; });
			this.entitlementPackages.hash = tempHash;
		}
	}
	
	, _getCookieForLoginPortal: function() {
		this.loginPortal = Cookie.read(this.cookieNames.LOGINPORTAL);
	}
	
	, _getCookieForUverse: function() {
		var cookieValue = Cookie.read(this.cookieNames.UVERSE);
		this.uverseUser = (cookieValue && cookieValue != '') ? true : false;
	}
	
	, _getCookieForHSIA: function() {
		var cookieValue = Cookie.read(this.cookieNames.HSIA);
		this.hsia = (cookieValue && cookieValue === 'true') ? true : false;
	}
	
	, _getCookieForZip: function() {
		this.zip = Cookie.read(this.cookieNames.ZIP);
	}
	
	, getUserEntitlement: function() {
		return this.entitlementPackages;
	}
	
	, isLoggedIn: function() {
		return this.username != null && this.loginPortal != null && this.loginPortal !== '';
	}
	
	, getUsername: function() {
		return this.username;
	}
	
	, getZip: function() {
		return this.zip;
	}
	
	, isHSIA: function() {
		return this.hsia;
	}
	
	, isUverse: function() {
		return this.uverseUser;
	}
});

Uverse.utils.Personalization.UverseData = new Class({
	Implements: [Callbacks]
	, Binds: ['_onPersonalizationComplete']
	        
	, callbacks: {
		onComplete: null
	}
	             
	, url: '/personalisation.json'
	, personalizationData: {}
	, request: null
	, complete: false
	
	, initialize: function() {
		this.request = new Request.JSON({
			url: this.url, 
			method: 'get',
			link: 'cancel',
			noCache: true,
			onSuccess: this._onPersonalizationComplete
		});
	}
	
	, requestData: function(callbacks) {
		this.setCallbacks(callbacks);
		this._makePersonalizationRequest();
	}
	
	, _makePersonalizationRequest: function() {
		this.request.send();
	}
	
	, _onPersonalizationComplete: function(data) {
		this.personalizationData = data;
		this.complete = true;
		this.callbacks.onComplete();
	}
	
	, getPersonalizationData: function(name) {
		if(!name) { throw new Error('Missing argument (name): must request a type of personalization data'); }
		return this.personalizationData[name] || null;
	}
	, setPersonalizationData: function(name, value) {
		this.personalizationData[name] = value;
	}

	, favoriteAddItem: function(favoriteID) {
		this.personalizationData.library.include(favoriteID);
	}
	, favoriteRemoveItem: function(favoriteID) {
		this.personalizationData.library.erase(favoriteID);
	}

	, setNotificationUserEmail: function(email) {
		this.personalizationData.notifications.emailAddr = email;
	}
	
	, notificationAddCategoryPath: function(categoryPath) {
		this.personalizationData.notifications.episodes.push(categoryPath);
	}

	, getVideoBookmark: function(safeVideoKey) {
		return this.personalizationData.bookmarks[safeVideoKey];
	}

	/**
	 * @param {Object} bookmark
	 * @param {Number} bookmark.position
	 * @param {Number} bookmark.totalTime
	 * @param {Number} bookmark.dateWatched
	 */
	, setVideoBookmark: function(safeVideoKey, bookmark) {
		this.personalizationData.bookmarks[safeVideoKey] = bookmark;
	}
	
	, isDeviceRetreived: function() {
		return this.personalizationData.deviceRetreived || false;
	}
});Uverse.utils.PlayerManager = new Class({

	Implements: [
		Uverse.utils.Loadable
		, Options
	]
	
	, el: null
	, contentEls: {
		player: null
		,loading: null
	}
	, options: {
		item_id: null
		, playerClassName: null
		, companionAdClassName: null
		, headerTitleClassName: '.modal-player-header-title-text'
		, playerOptions: {
			companionAdEl: null
			, videoNetwork: null
			, playerApi: null
		}
		, extensions: []
		, extensionsOptions: {}
	}
	, player: null
	, extensionManager: null
	, videoKey: null
	, shrink: null

	, initialize: function(el, options){
		Uverse.console.log("[PlayerManager]", "Player Manager Loaded");
		this.el = $(el);
		this.setOptions(options);

		this._setupElements();
		this._setupShrink();
		this._setupExtensionManager();

		this.extensionManager.runPlayerLoading();

	}

	, _setupElements: function() {
		this.contentEls.player = this.el.getElement('.player');
		this.contentEls.loading = this.el.getElement('.player-loading');
	}

	, _setupShrink: function() {
		this.shrink = new Uverse.utils.Shrink();
		this.shrink.resize(this.el.getElement(this.options.headerTitleClassName));
	}

	, _setupExtensionManager: function() {
		var extensions = this.options.extensions
			, extensionsOptions = this.options.extensionsOptions
			, loadPlayerCallback = this._startPlayer.bind(this);
		this.extensionManager = new Uverse.playerExtensions.ExtensionManager(this.el, extensions, loadPlayerCallback, extensionsOptions);
	}

	, _startPlayer: function() {
		this.videoKey = this._getVideoKey(this.options.item_id);
		this._showLoading();
		this._createPlayerInstance(this.options.playerClassName);
	}
	
	, _getVideoKey: function(key) {
		// must strip ':s' from sports content
		key = key.replace(/\:s$/,'');
		return key.substring(key.indexOf(':') + 1);
	}
	
	, _createPlayerInstance: function(playerClassName) {
		this.options.playerOptions.companionAdEl = this.el.getElement('.' + this.options.companionAdClassName);
		Uverse.console.log('[PlayerManager]', 'Starting', playerClassName);
		this.player = new Uverse.players[playerClassName](this.contentEls.player, this.options.playerOptions);
		
		this.player.addEvent('ready', this._loadVideo.bind(this));
		this.player.addEvent('playerError', this._onPlayerError.bind(this));
		this.player.addEvent('videoEnd', this._onPlayerVideoEnd.bind(this));
		this.extensionManager.runPlayerLoaded(this.player, this.el);
		this.player.build(this.options.playerLocation);
	}

	, _showLoading: function() {
		this.contentEls.loading.removeClass('hidden');
	}

	, _hideLoading: function() {
		this.contentEls.loading.addClass('hidden');
	}

	, _loadVideo: function() {
		this.player.load(this.videoKey, this.options.item_id);
		this._hideLoading();
	}
	
	, _onPlayerError: function(message) {
		Uverse.console.error("[PlayerManager]", "Player Error: ", message);
		this._destroyPlayer();
	}

	, _onPlayerVideoEnd: function() {
		this.extensionManager.runPlayerFinished();
		this._destroyPlayer();
	}

	/**
	 * Hides and destroys the player
	 */
	, _destroyPlayer: function() {
		if (this.player) {
			this.player.destroyPlayer();
			this.player = null;
		}
	}

	/** Implements Loadable */
	, load: function() {
	}
	/** Implements Loadable */
	, unload: function() {

	}
	/** Implements Loadable */
	, destroy: function() {
		this.extensionManager.destroyExtensions();
		this._destroyPlayer();
		$(this.el).destroy();
	}

});Uverse.utils.TileDrawerOverlayParent = new Class({
	drawerElement: null
	, overlayElement: null

	/** Must override */
	, templateElementID: null
	
	, initialize: function(drawerElement) {
		this.drawerElement = drawerElement;
		this._cloneOverlay();
	}

	/** Overridable */
	, hideOverlay: function() {
		if(this.overlayElement) {
			this.overlayElement = this.overlayElement.dispose();
		}
	}

	, _cloneOverlay: function() {
		if(!this.overlayElement) {
			this.overlayElement = $(this.templateElementID).clone();
		}
	}

	/** Protected
	 * @param {Object} [overlayOptions]
	 * @param {Boolean} [overlayOptions.detachOverlayFromTile]
	 */
	, showOverlay: function(overlayOptions) {
		this.overlayElement.removeClass('detached').set('style', null);
		this.drawerElement.adopt(this.overlayElement);

		if (overlayOptions && overlayOptions.detachOverlayFromTile) {
			Uverse.console.log("[TileDrawerOverlay]", "Showing detached overlay");

			var tile = this.drawerElement.getClosest('.tile');
			var overlayPos = this.overlayElement.getCoordinates(tile);

			tile.adopt(this.overlayElement);

			this.overlayElement.addClass('detached').setStyles({
				'top': overlayPos.top
				,'left': overlayPos.left
			});
		}
	}
});
Uverse.utils.TileDrawerOverlayGeneric = new Class({
	Extends: Uverse.utils.TileDrawerOverlayParent

	, templateElementID: 'tileDrawerGenericTemplate'
	
	, textContainerElement: null
	
	, initialize: function(drawerElement) {
		this.parent(drawerElement);
	}

	, showGenericOverlay: function(overlayContents, overlayOptions) {
		this.overlayElement.adopt(overlayContents);
		this.showOverlay(overlayOptions);
	}
	/** Overrides base */
	, hideOverlay: function() {
		this.overlayElement.empty();
		this.parent();
	}

});Uverse.utils.TileDrawerOverlayLoading = new Class({
	Extends: Uverse.utils.TileDrawerOverlayParent

	/** Overrides base */
	, templateElementID: 'tileDrawerLoadingTemplate'
	, spinner: null
		
	, initialize: function(drawerElement) {
		this.parent(drawerElement);
		this.spinner = this.drawerElement.getElement(".loading-image");
	}

	, showLoadingOverlay: function(overlayOptions) {
		this.showOverlay(overlayOptions);
		if (this.spinner) {this.spinner.removeClass.delay(500, this.spinner, 'hidden');}
	}

	, hideLoadingOverlay: function() {
		this.hideOverlay();
		if (this.spinner) {this.spinner.addClass('hidden');}
	}

});Uverse.utils.TileDrawerOverlayMessage = new Class({
	Extends: Uverse.utils.TileDrawerOverlayParent
	
	, templateElementID: 'tileDrawerMessageTemplate'
	
	, textContainerElement: null
	
	, initialize: function(drawerElement) {
		this.parent(drawerElement);
		this._processOverlay();
	}
	, _processOverlay: function() {
		this.textContainerElement = this.overlayElement.getElement('.drawer-overlay-message');
		this.overlayElement.addEvent('click', this._onOverlayClose.bind(this));
	}

	, showMessageOverlay: function(message, overlayOptions) {
		this._addMessageToContentElement(message);
		this.showOverlay(overlayOptions);
	}
	, _addMessageToContentElement: function(message) {
		this.textContainerElement.set('html', message);
	}

	, _onOverlayClose: function(ev) {
		ev.stopPropagation();
		this.hideOverlay();
	}
});Uverse.utils.TileHelper = new Class({

	ENTITLEMENT_CLASS_PREFIX: 'entitlement-'

	, setupVideoPlayLinks: function(el) {
		// Replace the SEO deep-link url with a Hashed deep-link url:
		var videoPlayLinks = el.getElements('.video-play-link');
		videoPlayLinks.each(function(a) {
			var href = a.get('href');
			href = href.replace('?', '#');
			a.set('href', href);
		});

		return videoPlayLinks;
	}
	,
	loadVideoPlayLink: function(tile, videoPlayLink) {
		// Grab the title and network from the tile,
		// so that it can be displayed by the player loader:
		var videoTitle = tile.getElement('.videoInfo-title')
			,videoSubtitle = tile.getElement('.videoInfo-subtitle')
			,videoDescription = tile.getElement('.videoInfo-description');

		if (videoDescription) {
			// If the element has been ellipsified, retrieve the original text:
			videoDescription = videoDescription.retrieve('originalElement') || videoDescription;
		}
		var videoInfo = {
			videoTitle: (videoTitle ? videoTitle.get('text') : '')
			,videoSubtitle: (videoSubtitle ? videoSubtitle.get('text') : '')
			,videoDescription: (videoDescription ? videoDescription.get('text') : '')
			,videoNetwork: ''
		};
		
		if (tile.getAttribute('data-content-type') == 'movies') {
			videoInfo.videoSubtitle = videoInfo.videoTitle;
		}
		var historyOptions = {
			windowTitle: videoInfo.videoTitle
		};
		Uverse.page.loadDeepLink(videoPlayLink, videoInfo, historyOptions);
	}


	, applyEntitlement: function(item, entitlementHelper) {
		var entitlementString = this._getEntitlementStringFromElement(item);
		var entitlementAccess = entitlementHelper.compareEntitlement(entitlementString);
		var className = this._createEntitlementAccessClassName(entitlementAccess);
		item.addClass(className);

	}
	, _getEntitlementStringFromElement: function(element) {
		var dataEntitlement = element.get('data-entitlement');
		if (dataEntitlement) {
			dataEntitlement = dataEntitlement.replace(/::/g, '>');
		} else {
			dataEntitlement = "";
		}
		return dataEntitlement;
	}
	, _createEntitlementAccessClassName: function(access) {
		return this.ENTITLEMENT_CLASS_PREFIX + access;
	}
	, getEntitlementStateViaClassName: function(item, targetAccess) {
		var className = this._createEntitlementAccessClassName(targetAccess);
		return item.hasClass(className)
	}


});
Uverse.utils.TokenHandler = new Class({
	Implements: [ Callbacks ]

	, callbacks: {
		/**
		 * @param {Object} data
		 */
		tokenError: null
		/**
		 * @param {Object} playToken
		 * @param {Node} playToken.tokenXML
		 * @param {String} playToken.tokenString
		 * @param {Object} data
		 */
		,tokenRetrieved: null
	}

	, initialize: function(callbacks) {
		this.setCallbacks(callbacks);
	}
	
	, sendAuthenticationRequest: function(key) {
		var request = new Request({
			method: 'get',
			headers: { 'Accept': 'application/xml' },
			url: Uverse.config.token.urls.token.substitute({ key: key }),
			onComplete: this._onAuthenticationRequestComplete.bind(this)
		});
		request.send();
	}
	
	, _onAuthenticationRequestComplete: function(responseText, responseXML) {
		if(this._isErrorThenHandle(responseXML)) {
			return;
		} else {
			var playToken = responseXML.getElementsByTagName('playToken')[0].firstChild;
			var streamTokenText = responseXML.getElementsByTagName('streamToken')[0].firstChild.data;

			this.callbacks.tokenRetrieved({ tokenXML: playToken, tokenString: this._serializeToken(playToken) }, streamTokenText);
		}
	}
	
	, _serializeToken: function(tokenElement) {
		if(tokenElement.xml) {
			return tokenElement.xml;
		} else {
			var serializer = new XMLSerializer();
			return serializer.serializeToString(tokenElement);
		}
	}
	
	, _isErrorThenHandle: function(responseXML) {
		var errorTag = responseXML.getElementsByTagName('error')[0];
		if (errorTag) {
			this.callbacks.tokenError(errorTag.firstChild.data);
			return true;
		}
		return false;
	}
	
});
(function() {

	var transitions = {
		'transitions-tile-drawer-open':             { props: [ 'height' ] }
		,'transitions-modal-shadow-open':           { props: [ 'opacity' ] }
		,'transitions-modal-container-open':        { props: [  ] }
		,'transitions-mastfooter-open':             { props: [ 'bottom' ] }
		,'transition-mastfooter-back-to-top':       { props: [ 'width' ] }
		,'transition-mastfooter-back-to-top-show':  { props: [ 'bottom' ] }
		,'transition-tile-groups-reloading':        { props: [ 'opacity' ] }
		,'transition-main-nav-menu-shown':			{ props: [ 'height' ] }
	};

	Element.implement({
		/**
		 * @param {String} className
		 * @param {TransitionOptions} [transition]
		 * @return {Element}
		 */
		addClassWithTransition: function(className, transition) {
			transition = transition || transitions[className];
			if (!transition)
				Uverse.console.warn("[Transitions]", "Transition is not defined for:", className);

			return this.transition(transition, function(){
				this.addClass(className);
			});
		}
		,
		/**
		 * @param {String} className
		 * @param {TransitionOptions} [transition]
		 * @return {Element}
		 */
		removeClassWithTransition: function(className, transition) {
			transition = transition || transitions[className];
			if (!transition)
				Uverse.console.warn("[Transitions]", "Transition is not defined for:", className);

			return this.transition(transition, function(){
				this.removeClass(className);
			});
		}
		,
		/**
		 * @param {String} className
		 * @param {TransitionOptions} [transition]
		 * @return {Element}
		 */
		toggleClassWithTransition: function(className, transition) {
			if (this.hasClass(className))
				return this.removeClassWithTransition(className, transition);
			return this.addClassWithTransition(className, transition);
		}
	});




})();
/**
 * A reusable utility that adds an ellipsis
 * to elements if their contents wrap.
 */
Uverse.utils.Ellipsify = new Class({
    Implements: [Options]

    , options: {
        /**
         * The default ellipsis text or element
         */
        ellipsis: '...'

        /**
         * If `true`, the original contents will be cloned,
         * so that `ellipsifyElement` can be called again
         * (eg, if the element resizes).
         *
         * If `false`, the original contents will be permanently modified.
         * This reduces memory and increases performance.
         */
        , cloneOriginal: false

        /**
         * Determines how specific the trimming should be.
         * Can be: 'letter', 'word', or 'node'.
         */
        , truncateTo: 'letter'
    }

    , initialize: function(options){
        this.setOptions(options);
    }

    /**
     * Measures the contents of the element,
     * and adds an ellipsis if the contents
     * are taller than the element.
     *
     * @param {Element} el The element to ellipsify
     * @param {Object} options Overrides the default options
     *
     * @return {Node} Returns null if no truncation happens; otherwise, returns the ellipsis element.
     */
    , ellipsifyElement: function(el, options) {
        options = Object.merge({}, this.options, options);

        // Prepare:
        var originalContents;
        if (!options.cloneOriginal) {
            originalContents = Array.from(el.childNodes);
        } else {
            // Create a new clone of the original contents:
            var originalElement = el.retrieve('originalElement');
            if (originalElement) {
                originalContents = Array.from(originalElement.clone().childNodes);
                el.empty();
            } else {
                originalElement = el.clone();
                el.store('originalElement', originalElement);
                originalContents = Array.from(el.childNodes);
            }
        }

        // Constants:
        var NODETYPE_ELEMENT = 1;


        // Wrap for measurement:
        var wrapperNotNeeded = (el.childNodes.length === 1 && el.childNodes[0].nodeType === NODETYPE_ELEMENT);
        var wrapper;
        if (wrapperNotNeeded) {
            wrapper = el.childNodes[0];
        } else {
            wrapper = new Element('div', {'style':'visibility: hidden;'});
            wrapper.adopt(originalContents).inject(el);
        }


        // Start trimming:
        var goalHeight = el.offsetHeight;
        var textIsTooHigh = function () {
            return goalHeight < wrapper.offsetHeight;
        };
        // Initial test:
        var ellipsis = null;
        if (textIsTooHigh()) {

            // Create a Node from the ellipsis:
            ellipsis = options.ellipsis;
            switch (typeOf(ellipsis)){
                case 'element':
                case 'textnode':
                case 'whitespace':
                    ellipsis = ellipsis.clone();
                    break;
                case 'string':
                default:
                    ellipsis = document.createTextNode(ellipsis);
                    break;
            }
            wrapper.appendChild(ellipsis);

            // Search for the last node that wraps:
            var wrapNode = this._findWrapNode(textIsTooHigh, wrapper, originalContents, ellipsis);

            // Trim the text inside the node:
            this._trimWrapNode(textIsTooHigh, wrapNode);

        }


        // Finalize (un-wrap):
        if (!wrapperNotNeeded) {
            el.adopt(wrapper.dispose().childNodes);
        }

        return ellipsis;
    }

    /**
     * Finds the node that causes wrapping.
     * This method hides all other wrapped nodes.
     */
    , _findWrapNode: function(textIsTooHigh, parentNode, childNodes, ellipsis) {

        var wrapNode;
        while (true) {

            // Brute force:
            if (childNodes.length === 1){
                wrapNode = childNodes[0];
            } else {
                // Brute Force: Remove elements until overflow stops:
                var index = childNodes.length;
                do {
                    index--;
                    wrapNode = childNodes[index];
                    parentNode.removeChild(wrapNode);
                } while (index > 0 && textIsTooHigh());

                // Re-add the just-removed wrapNode:
                if (ellipsis) {
                    parentNode.insertBefore(wrapNode, ellipsis);
                } else {
                    parentNode.appendChild(wrapNode);
                }

                if (Uverse.console.enabled) {
                    // TODO: Fix this known Chrome bug:
                    // After we re-added the element, we should definitely be overflowing.
                    // However, it seems Chrome has a bug that doesn't refresh
                    // the height.  This only occurs for certain items,
                    // but occurs consistently for those items.
                    // Let's just log an error message:
                    if (!textIsTooHigh()){
                        Uverse.console.error('[Ellipsify]', "Element is not measuring correctly, so ellipsify probably didn't work.", { offsetHeight: wrapNode.offsetHeight, outerHTML: wrapNode.outerHTML }, wrapNode);
                    }
                }

            }


            // Now, repeat for sub-nodes:
            if (wrapNode && wrapNode.childNodes && wrapNode.childNodes.length){
                parentNode = wrapNode;
                childNodes = wrapNode.childNodes;
                ellipsis = null;
            } else {
                break;
            }
        }

        return wrapNode;
    }

    /**
     * Trims the text within the node.
     */
    , _trimWrapNode: function(textIsTooHigh, wrapNode){

        if (!wrapNode)
            return;

        // Constants:
        var NODETYPE_TEXT = 3;
        if (wrapNode.nodeType !== NODETYPE_TEXT) {
            // It's not a text node, so we must hide it:
            wrapNode.parentNode.removeChild(wrapNode);
            return;
        }

        var trimToWord = false;

        switch (this.options.truncateTo) {
            case 'node':
                wrapNode.parentNode.removeChild(wrapNode);
                return;
            case 'word':
                trimToWord = true;
                break;
            case 'letter':
                break;
        }

        // Determine how to trim:
        var text = wrapNode.nodeValue;
        var trimAndTest;
        if (trimToWord) {
            text = text.split(/\b/g);
            trimAndTest = function(index){
                wrapNode.nodeValue = text.slice(0, index).join('');
                return (textIsTooHigh() ? -1 : 1);
            };
        } else {
            trimAndTest = function(index){
                wrapNode.nodeValue = text.substr(0, index);
                return (textIsTooHigh() ? -1 : 1);
            };
        }

        // Determine where the text wraps:
        var wrapCharIndex = this._binarySearch(text.length, trimAndTest);

        // Update with the final results:
        trimAndTest(wrapCharIndex - 1);
    }


    /**
     * Performs a binary search.
     * @param {Integer} searchLength The number of positions that need to be tested.
     * @param {Function(index)} testFn Tests the given index, and returns the "step-direction" which can be -1, 0, or 1.
     */
    , _binarySearch: function(searchLength, testFn) {
        var searchStart = 0, searchIndex = 0;
        while (searchLength > 0) {
            searchIndex = searchStart + Math.floor(searchLength / 2);
            var stepDirection = testFn(searchIndex);
            if (stepDirection === 0) {
                // Short-circuit!
                return searchIndex;
            } else if (stepDirection > 0) {
                // Step forward:
                searchIndex++;
                searchLength = (searchStart + searchLength) - searchIndex;
                searchStart = searchIndex;
            } else {
                // Step backward:
                searchLength = searchIndex - searchStart;
            }
        }

        return searchIndex;
    }




});Uverse.utils.WebtrendsAPI = new Class({
	metaTagsNames: {
		REGISTERED_VISITOR: "WT.rv"
		, LOGGED_IN: 'WT.z_LoggedIn'
		, USER_TYPE: 'WT.z_UserType'
		, IS_HSIA: 'WT.z_HSIA'
		, USERNAME: 'DCS.dcsaut'
	},
	
	metaTagBooleanContents: {
		REGISTERED: 1
		, LOGGED_IN: 'Logged In'
		, LOGGED_OUT: 'Guest'
		, USER_UVERSE: 'U-verse'
		, USER_ATT: 'ATT.net'
		, USER_HSIA: 'HSIA'
		, USER_NONHSIA: 'Non-HSIA'
	},
	
	initialize : function() {
		
		Uverse.page.addMemoryEvent('Personalization-userData', this._initWebTrends.bind(this));
		
	},
	
	_initWebTrends: function(personalizationUserData) {
		if (personalizationUserData.isLoggedIn()) {
			this._addMetaTagToPage({
				name: this.metaTagsNames.REGISTERED_VISITOR
				, content: this.metaTagBooleanContents.REGISTERED
			});
			this._addMetaTagToPage({
				name: this.metaTagsNames.LOGGED_IN
				, content: this.metaTagBooleanContents.LOGGED_IN
			});
//			this._addMetaTagToPage({
//				name: this.metaTagsNames.USERNAME
//				, content: personalizationUserData.getUsername()
//			});
			if (personalizationUserData.isUverse()) {
				this._addMetaTagToPage({
					name: this.metaTagsNames.USER_TYPE
					, content: this.metaTagBooleanContents.USER_UVERSE
				});
			} else {
				this._addMetaTagToPage({
					name: this.metaTagsNames.USER_TYPE
					, content: this.metaTagBooleanContents.USER_ATT
				});
			}
		} else {
			this._addMetaTagToPage({
				name: this.metaTagsNames.LOGGED_IN
				, content: this.metaTagBooleanContents.LOGGED_OUT
			});
		}
		
		if (personalizationUserData.isHSIA()) {
			this._addMetaTagToPage({
				name: this.metaTagsNames.IS_HSIA
				, content: this.metaTagBooleanContents.USER_HSIA
			});
		} else {
			this._addMetaTagToPage({
				name: this.metaTagsNames.IS_HSIA
				, content: this.metaTagBooleanContents.USER_NONHSIA
			});
		}
		
		this._loadWebtrends({
			dcsid: Uverse.config.webtrends.dcsid
			, domain: Uverse.config.webtrends.domain
			, DivList: Uverse.config.webtrends.baseTags
			, onsitedoms: Uverse.config.webtrends.onsitedoms
		});
			
	},
	
	_addMetaTagToPage: function(data) {
		(new Element('meta', {
			name: data.name
			, content: data.content
		})).inject(document.head);
	},
	
	_loadWebtrends: function(webTrendsOptions) {
		/* written by Webtrends, modified by mgage */
		window.webtrendsAsyncInit = function(){
			var dcs = new Webtrends.dcs().init({
				dcsid: webTrendsOptions.dcsid 
				, domain: webTrendsOptions.domain 
				, navigationtag: "div,span"
				, timezone: -8
				, offsite: true
				, download: true
				, downloadtypes: "xls,doc,pdf,txt,csv,zip,docx,xlsx,rar,gzip" 
				, onsitedoms: webTrendsOptions.onsitedoms
				, FPCConfig: {
					enabled: true,  
					domain: "",  
					name: "wls_id",  
					expires: 315569259747     //10 years
				}
				, plugins: {
					LinkTrack: { 
						src: Uverse.config.vendorPath + "Webtrends/linkTrack.js" 
						, DivList: webTrendsOptions.DivList
					}
					, campaign: {
						src: Uverse.config.vendorPath + "Webtrends/campaign.js"
					}
				}
			}).track({
				filter: function(dcs, options) {}
				, transform: function(dcs, options) {}
				, finish: function(dcs, options) {}
			});
		};
		
		var s = document.createElement("script"); s.async=true; s.src=Uverse.config.vendorPath + "Webtrends/webtrends.min.js";
		var s2 = document.getElementsByTagName("script")[0]; s2.parentNode.insertBefore(s,s2);
	}
});Uverse.utils.ForeseeAPI = new Class({
	
	initialize : function() {
		Uverse.page.addMemoryEvent('Personalization-userData', this._initializeForesee.bind(this));
	}

	,_initializeForesee: function(personalizationUserData) {
		this.personalizationUserData = personalizationUserData;
		this.foreseeJSprops = Asset.javascript(Uverse.config.vendorPath+'/Foresee/foresee-fsr.js', {
			onLoad: this._addTrigger.bind(this)
		});
		
	}

	,_addTrigger: function() {
		this.foreseeJS = Asset.javascript(Uverse.config.vendorPath+'/Foresee/foresee-trigger.js', {
			onLoad: this._setUserOptions.bind(this)
		});
	}
	
	,_setUserOptions: function() {
		if(window.FSR && window.FSR.CPPS) {
			window.FSR.CPPS.set('LoggedIn', this.personalizationUserData.isLoggedIn() ? 'true' : 'false');				
		}
	}
});Uverse.utils.GoogleAnalyticsAPI = new Class({
	
	initialize : function() {
		window._gaq = window._gaq || [];
		window._gaq.push(['_setAccount', Uverse.config.google_analytics.code]);

		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	}

	, api : function(methodName, args) {
		Uverse.console.log('[GoogleAnalyticsAPI]', 'GA pushing: ' + methodName + " | args: " + args);
		var call = args || [];
		call.unshift(methodName);
		_gaq.push(call);
	}

});Uverse.utils.Shrink = new Class({
	Implements: [Options],
	options: {
		minimumFontSize: 11
	},

	initialize: function (options) {
		this.setOptions(options);
	},

	resize: function (text) {
		var wrapper = text.getParent(),
			fontSize = parseInt(text.getStyle('font-size'), 10);

		while (text.offsetWidth > wrapper.offsetWidth && fontSize > this.options.minimumFontSize)
			text.setStyle('font-size', --fontSize);
	}
});Uverse.utils.Banner = new Class({
	Implements: [Options]
	, options: {
		'templatesPrefix': null, // Set on init
		'template': null // Set on init.
	}
	, url: null
	, initialize: function (src, options) {
		this.options.templatesPrefix = Uverse.config.templates.bannersPrefix;
		// Templates live in bannersTemplates.ftl
		this.options.template = 'default'
		this.src = src;
		this.setOptions(options);
		if(!this.options.id)
			this.options.id = String.uniqueID();
	}
	, toHtml: function () {
		// Create a copy of the options and finally add `src` to it.
		var data = Object.clone(this.options),
				template;

		data.src = this.src;
		// Parse the template with our new object.
		template = $(this.options.templatesPrefix + this.options.template).get('html');
		return template.substitute(data);
	}
	, toElement: function() {
		return Elements.from(this.toHtml());
	}
	, toString: function () {
		return this.toHtml();
	}
	, getId: function () {
		return this.options.id;
	}
});/*jshint laxcomma:true*/
/*global Elements:true Uverse:true $:true Options:true Class:true*/
Uverse.utils.BannersManager = new Class({
	Implements: [Options]
	, options: {
		defaultPositon: 'bottom'
	}
	, el: null
	, readOnly: false
	, banners: {}
	, initialize: function(el, options) {
		Uverse.console.log('[BannersManager]', 'Initializing BannersManager');
		this.el = $(el);
		this.setOptions(options);
	}
	, clear: function () {
		if(this.readOnly) {
			Uverse.console.log('[BannersManager]', 'Clear is not allowed on read only mode.');
			return;
		}
		this.banners = [];
		this.el.empty();
	}
	, add: function (banner, pos) {
		if(this.readOnly) {
			Uverse.console.log('[BannersManager]', 'Add is not allowed on read only mode.');
			return;
		}
		// Disallow two banners with the same id.
		if(banner.getId() in this.banners)
			throw new Error('Duplicate banner id');

		pos = pos || this.options.defaultPositon;
		var element = banner.toElement();
		element.inject(this.el, pos);
		this.banners[banner.getId()] = {
			'banner': banner,
			'element': element
		};
	}
});Uverse.widgets.Banners = new Class({
	Implements: [Options]
	, el: null
	, options: {
			path : null // Added on initialization
			, section : '1'
			, bannerUrl: '/banner.json'
	}
	, manager: null
	, _loadTargetedBanners: function() {
		var successHandler,
				failHandler,
				request;

		successHandler = function (result) {
			if (result && result.bannerAvailable) {
				var banner = new Uverse.utils.Banner(result.imageUrl);
				if(result.link) {
					banner.options.link = result.link;
					banner.options.template = 'defaultWithLink';
					banner.options.target = result.externalLink ? '_blank' : '_self';
				}
	
				this.manager.add(banner);
			}
		};

		failHandler = function (result) {
			Uverse.console.log('[Banner]', 'AJAX call error - No banner set up for this page or server error');
		};

		request = new Request.JSON({
			url: this.options.bannerUrl,
			method: 'get',
			data: {
					path: this.options.path,
					section: this.options.section,
					json: 'yes'
				},
			onSuccess: successHandler.bind(this),
			onFailure: failHandler.bind(this)
		});

		request.send();
	}
	, _onUnsupportedBrowser: function (info, userAgent) {
		// If no image is provided to 'Uverse.utils.Banner', it will try to take it
		// from the options.
		var banner = new Uverse.utils.Banner(info.src, info);
		banner.options.template = 'unsupportedBrowser';
		banner.options.target = '_blank';
		banner.options.browser = info.name;
		this.manager.clear();
		this.manager.add(banner);
		this.manager.readOnly = true;
	}
	, initialize: function (el, options) {
		this.el = $(el);
		this.setOptions(options);
		this.options.path = Uverse.config.requestPath;

		this.manager = new Uverse.utils.BannersManager(this.el);
		this._loadTargetedBanners();

		Uverse.page.addMemoryEvent('UnsupportedBrowser',
			this._onUnsupportedBrowser.bind(this));
	}
});Uverse.utils.UnsupportedBrowsers = new Class({
	el: null
	// The following array can hold RegExp expressions
	, unsupportedUserAgents: null
	, _getUnsupportedUserAgent: function (userAgent, documentMode) {
		// Try to match the current 'userAgent' with each '_userAgents'.
		// If there's a match, we return 'false'
		for(var pattern in this.unsupportedUserAgents) {
			var unsupportedUserAgent = this.unsupportedUserAgents[pattern];
			if (this._isUserAgentMatch(userAgent, documentMode, pattern, unsupportedUserAgent)) {
				if (unsupportedUserAgent.browserIsSupported === true) {
					return null; // This is for IE8 Compatibility mode
				}
				return unsupportedUserAgent;
			}
		}
		return null;
	}
	, _isUserAgentMatch: function(userAgent, documentMode, pattern, unsupportedUserAgent) {
		if (userAgent.match(new RegExp(pattern))) {
			if (unsupportedUserAgent.andDocumentModeIsNot === undefined || unsupportedUserAgent.andDocumentModeIsNot !== documentMode ) {
				return true;
			}
		}
		return false;
	}
	, initialize: function () {
		this.unsupportedUserAgents = Uverse.config.unsupportedBrowsers;
		var userAgent = navigator.userAgent
			,documentMode = document.documentMode
			,unsupportedUserAgent = this._getUnsupportedUserAgent(userAgent, documentMode);
		// If the current browser is unsupported, we trigger an event to let
		// page (and its event listeners) know about this.
		if (unsupportedUserAgent) {
			Uverse.page.fireMemoryEvent(
				'UnsupportedBrowser',
				[unsupportedUserAgent, userAgent]
			);
		}
	}
});Uverse.widgets.ParentIcon = new Class({
	Implements: [Callbacks]
	               
	, el: null
	, icon: null
	, state: null
	, callbacks: {
		onClick: null
		, onOneClick: false // Optional
		, onStateChange: null
	}
	
	, initialize: function(el, callbacks) {
		this.setCallbacks(callbacks);
		this.el = $(el);
		this.icon = this.el.getElement('.icon');
		this.el.addEvent('click', this.onClick.bind(this));
	}

	/** Public, must override */
	, setState: function(state) {
		return null;
	}

	/** Protected, overridable */
	, onClick: function(ev) {
		var isClosing = ev.target.getParent().hasClass('selected');
		ev.target.set('data-clicktrack-label', (isClosing ? "Close" : "Open"));
		this.callbacks.onClick();
	}

	/** Public */
	, getState: function() {
		return this.state;
	}
});Uverse.widgets.FavoriteIcon = new Class({
	Extends: Uverse.widgets.ParentIcon
	
	, favoriteID: null
	, oneClickFavorites: 'oneClickFavorites'
	, oneClickFavoritesEnabled: false

	, initialize: function(el, favoriteID, callbacks) {
		this.parent(el, callbacks);
		this.state = Uverse.page.favorite.itemStates.NOT_SAVED;
		this.favoriteID = favoriteID;
		Uverse.page.addMemoryEvent('Favorite-assetList', this._onUverseDataReceived.bind(this));
		Uverse.page.addMemoryEvent('Personalization-uverseData', this._onPersonalization.bind(this));
	}

	/** Overrides base */
	, setState: function(state) {
		this.state = state;
		this.callbacks.onStateChange(state);
		
		this.icon.removeClass('active');
		
		if(this.state == Uverse.page.favorite.itemStates.SAVED) {
			this.icon.addClass('active');
		} 
	}
	
	, _onUverseDataReceived: function() {
		this.setState(Uverse.page.getFavoriteStateForItem(this.favoriteID));
	}


	/** Overrides base */
	, onClick: function(ev) {
		if (this.oneClickFavoritesEnabled && this.state === Uverse.page.favorite.itemStates.NOT_SAVED) {
			this.icon.set('data-clicktrack-label', "One-Click-Favorites Save");
			this.callbacks.onOneClick();
		} else {
			this.parent(ev);
		}
	}


	, _onPersonalization: function(uverseData) {
		this.oneClickFavoritesEnabled = uverseData.getPersonalizationData(this.oneClickFavorites);
	}

});
Uverse.widgets.FavoriteSaver = new Class({
	Implements: [Callbacks]

	, callbacks: {
		showLoading: null
		, hideLoading: null
		, closeDrawer: null
		, showGenericOverlay: null
		, hideGenericOverlay: null
	}
	, favoriteID: null
	, favoriteTemplateElementID: 'favoriteOptionsTemplate'
	, screens: {
		addToFavorites: null
		, removeFromFavorites: null
		, confirmation: null
	}
	, addToFavoritesRequest:null
	, oneClickFavorites: 'oneClickFavorites'
	, oneClickFavoritesEnabled: false
	, favoriteData:  {}

	, initialize: function(favoriteID, favoriteType, callbacks) {
		this.setCallbacks(callbacks);
		this.favoriteID = favoriteID;
		if (favoriteType=='Video') {
			this.favoriteData = {
				itemKey: this.favoriteID
			};
		} else if (favoriteType=='Category') {
			this.favoriteData = {
				showPath: this.favoriteID
			};
		}

		this._setupRequests();
	}
	, _setupRequests: function(){
		this.addToFavoritesRequest = new Request.JSON({
			url: Uverse.config.favorite.urls.save
			, method: 'post'
			, data: this.favoriteData
			, noCache: true
			, onComplete: this._onAddToFavoritesSuccess.bind(this)
		});
		this.removeRequest = new Request.JSON({
			url: Uverse.config.favorite.urls.remove
			, method: 'post'
			, data: this.favoriteData
			, noCache: true
			, onComplete: this._onRemoveSuccess.bind(this)
		});
		this.saveUserSettingRequest = new Request.JSON({
			url: Uverse.config.personalization.urls.saveUserSetting
			, method: 'post'
			, noCache: true
			, link: 'chain'
		});

	}

	, getUI: function(state) {
		var stateClassNames = this._getClassNamesFromState(state);
		var template = this._getTemplate(stateClassNames);

		Uverse.page.addMemoryEvent('Personalization-uverseData', this._onPersonalization.bind(this));

		this._unHideFirstScreen(template);

		return template;
	}

	, _unHideFirstScreen: function(template) {
		template.getChildren()[0].removeClass('hidden');
	}

	, _getClassNamesFromState: function(state) {
		switch (state)
		{
			case Uverse.page.favorite.itemStates.NOT_SAVED:
				return ['favorite-add', 'favorite-remove', 'favorite-remove-confirmation'];
			case Uverse.page.favorite.itemStates.SAVED:
				return ['favorite-remove', 'favorite-add', 'favorite-remove-confirmation'];
		}
	}

	, _getTemplate: function(stateClassNames) {
		var template = $(this.favoriteTemplateElementID);
		var templateArray = [];

		stateClassNames.each(function(stateClassName) {
			switch (stateClassName)
			{
				case 'favorite-add':
					var addToFavoritesTemplate = template.getElement('.favorite-add').clone();
					this.screens.addToFavorites = addToFavoritesTemplate;
					this.screens.addToFavoritesFormWidget = new Uverse.controls.Form(addToFavoritesTemplate.getElement('form'), {
						'submit': this.addToFavorites.bind(this)
						,'changing': this._onOneClickChanging.bind(this)
					});

					templateArray.push(addToFavoritesTemplate);
					break;
				case 'favorite-remove':
					var removeFromFavoritesTemplate = template.getElement('.favorite-remove').clone();
					this.screens.removeFromFavorites = removeFromFavoritesTemplate;
					this.screens.removeFromFavoritesFormWidget = new Uverse.controls.Form(removeFromFavoritesTemplate.getElement('form'), {
						'submit': this._onRemoveSubmit.bind(this)
						,'changing': this._onOneClickChanging.bind(this)
					});

					templateArray.push(removeFromFavoritesTemplate);
					break;
				case 'favorite-remove-confirmation':
					var confirmationTemplate = template.getElement('.favorite-remove-confirmation').clone();
					this.screens.confirmation = confirmationTemplate;
					this.screens.confirmationFormWidget = new Uverse.controls.Form(confirmationTemplate.getElement('form'), {
						'submit': this._onConfirmationSubmit.bind(this)
					});

					templateArray.push(confirmationTemplate);
					break;
			}
		}, this);

		template = new Element('div');
		templateArray.each(function(templateItem) {
			template.adopt(templateItem);
		});

		return template;
	}

	/** Public */
	, addToFavorites: function(ev) {
		Uverse.console.log("[FavoriteSaver]", "Adding to Favorites");
		Uverse.page.favoriteAddItem(this.favoriteID);
		this.addToFavoritesRequest.send();

		if (this._isUILoaded()) {
			this.callbacks.showLoading();
		}
	}
	, _onAddToFavoritesSuccess: function(response) {
		if (this._isUILoaded()) {
			this._showRemoveFromFavorites();
			this.callbacks.hideLoading();
		}
	}

	, _onRemoveSubmit: function(ev) {
		this.screens.confirmation.dispose().removeClass('hidden');
		this.callbacks.showGenericOverlay(this.screens.confirmation);
	}
	, _onConfirmationSubmit: function(ev, formValues) {
		var confirmed = (formValues['result'] === 'confirm');

		var overlayOptions = { confirmationResult: confirmed, preventDrawerFromCollapsing: false };
		this.callbacks.hideGenericOverlay(overlayOptions);

		this.preventDrawerFromCollapsing = overlayOptions.preventDrawerFromCollapsing;

		if (confirmed) {
			this._onRemoveConfirmed();
		}
	}
	, _onRemoveConfirmed: function() {
		Uverse.console.log("[FavoriteSaver]", "Removing from Favorites");
		Uverse.page.favoriteRemoveItem(this.favoriteID);

		this.removeRequest.send();
		this.callbacks.showLoading();
	}
	, _onRemoveSuccess: function(response) {
		if (this.oneClickFavoritesEnabled && !this.preventDrawerFromCollapsing) {
			this.callbacks.closeDrawer();
		} else {
			this._showAddToFavorites();
			this.callbacks.hideLoading();
		}

	}
	, _showAddToFavorites: function() {
		this.screens.addToFavorites.removeClass('hidden');
		this.screens.removeFromFavorites.addClass('hidden');
	}
	, _showRemoveFromFavorites: function() {
		this.screens.addToFavorites.addClass('hidden');
		this.screens.removeFromFavorites.removeClass('hidden');
	}

	, _isUILoaded: function() {
		return (this.screens.addToFavorites != null);
	}

	, _onOneClickChanging: function(ev, control, checked, oldValue) {
		if (control.getName() == this.oneClickFavorites) {
			ev.target.set('data-clicktrack-label', (checked ? "On" : "Off"));
			this._saveOneClickSetting(this.oneClickFavorites, checked);
		}
	}
	, _saveOneClickSetting: function(key, value) {
		Uverse.console.log("[FavoriteSaver]", "Setting ", key, " to ", value);
		var data = {};
		data[key] = value;
		this.saveUserSettingRequest.send({ data: data });

		Uverse.page.updateUserSetting(key, value);
	}

	, _onPersonalization: function(uverseData) {
		this.oneClickFavoritesEnabled = uverseData.getPersonalizationData(this.oneClickFavorites);

		this.screens.removeFromFavoritesFormWidget.setValue(this.oneClickFavorites, this.oneClickFavoritesEnabled);
		this.screens.addToFavoritesFormWidget.setValue(this.oneClickFavorites, this.oneClickFavoritesEnabled);
	}
});
/**
 * Controls the filter bar
 */
Uverse.widgets.FilterBar = new Class({
	/* Extends, Implements, Binds */
	Implements: [
		  Callbacks
		, Options
	]
	, Binds: ['_onFilterFormChanging']

	/* Instance members */
	, options: {
	}
	, callbacks: {
		/**
		 * Fires when changes are made to the filter bar
		 * @param {String} filterValues The key-value pairs of the current filter
		 */
		'filterChanged': null
	}

	, filterBar: null
	, primaryFilters: null
	, secondaryFilterBars: null
	, filterForms: null
	, selectedFilterForm: null

	/* Constructor */
	, initialize: function(el, options, callbacks) {
		this.filterBar = $(el);
		this.setOptions(options);
		this.setCallbacks(callbacks);

		this._setupFilterBar();
	}

	, _setupFilterBar: function(){
		this._setupPrimaryFilters();
		this._setupSecondaryFilters();
	}
	, _setupPrimaryFilters: function(){
		this.primaryFilters = this.filterBar.getElements('.primary-filter-tab');
		if (this.primaryFilters.length > 0) {
			var self = this;
			this.primaryFilters.addEvents({
				'click': function(ev) {
					ev.preventDefault();
					self._setPrimaryFilter(this);
					self._updateFilter();
				}
			});
		}
	}
	, _setupSecondaryFilters: function(){
		this.secondaryFilterBars = this.filterBar.getElements('.secondary-filter-bar');

		// Set up each form:
		this.filterForms = this.secondaryFilterBars.getElement('.filter-form').map(function(form){
			var callbacks = {
				'changing': this._onFilterFormChanging
			};
			var ucForm = new Uverse.controls.Form(form, callbacks);
			return ucForm;
		}, this);
	}
	, checkInitialFilter: function(){
		if (this.primaryFilters.length > 0) {
			// Set the initial filter:
			var selected = this.primaryFilters.filter('.selected')[0];
			Uverse.console.assert(selected, "[FilterBar]", "One of the Primary Filters must be selected.", this.primaryFilters);
			this._setPrimaryFilter(selected);
			this._updateFilter();
		} else {
			// There's no "primary filters"; there's only a secondary filter
			Uverse.console.assert(this.filterForms.length == 1, "[FilterBar]", "If there's no Primary Filters, there should only be 1 Secondary Filter.", this.filterForms.length);

			this.selectedFilterForm = this.filterForms[0];
			this._updateFilter();
		}

	}


	, _onFilterFormChanging: function(ev, control, newValue, oldValue) {
		this._updateFilter();
	}


	, _setPrimaryFilter: function(primaryFilter) {
		var pfValue = primaryFilter.getAttribute('data-primary-filter-value');
		this.primaryFilters.removeClass('selected');
		primaryFilter.addClass('selected');

		// Find and show the matching secondary filter:
		this.secondaryFilterBars.each(function(secondaryFilterBar, ix) {
			var sfValue = secondaryFilterBar.getAttribute('data-primary-filter-value');
			if (pfValue == sfValue) {
				secondaryFilterBar.removeClass('hidden');
				this.selectedFilterForm = this.filterForms[ix];
			} else {
				secondaryFilterBar.addClass('hidden');
			}
		}, this);
	}

	, _updateFilter: function() {
		var filterValues = this.selectedFilterForm.getValues({filterEmpty:true});

		this.callbacks['filterChanged'](filterValues);
	}

});

Uverse.widgets.Footer = new Class({
	Implements: [Options]
	, options: {
		'openButtonSelector': '#open-footer-button',
		'openClassName': 'transitions-mastfooter-open',
		'backToTopButtonSelector': '.mastfooter-back-to-top',
		'backToTopButtonHoverClass': 'transition-mastfooter-back-to-top',
		'backToTopShowClass': 'transition-mastfooter-back-to-top-show',
		'showBackToTopAt': 1000,
		'animation': {
			'duration': 100,
			'transition': Fx.Transitions.Sine.easeOut,
			'backToTop': {
				'duration': 75,
				'transition': Fx.Transitions.Sine.easeOut
			}
		}
	}
	, openButton: null
	, backToTopButton: null
	, modalOpen: false
	, _toggleOpen: function(ev) {
		ev.preventDefault();
		this.el.toggleClassWithTransition(this.options.openClassName);
	}
	, _toggleBackToTop: function(ev) {
		ev.preventDefault();
		this.backToTopButton.toggleClassWithTransition(this.options.backToTopButtonHoverClass);
	}
	, _scrollToTop: function(ev) {
		if (Fx.Scroll) {
			ev.preventDefault();
			var fx = new Fx.Scroll(this._scrollParent);
			fx.toTop();
		}
	}
	, _onScrollHandler: function(e) {
		if(this._scrollParent.getScroll().y > this.options.showBackToTopAt && !this.modalOpen) {
			this.backToTopButton.reveal();
		} else {
			this.backToTopButton.dissolve();
		}
	}
	, _onModalPlayerOpen: function(e) {
		this.modalOpen = true;
		this.backToTopButton.hide();
	}
	, _onModalPlayerClosed: function(e) {
		// We must check if the button should be shown or not.
		this.modalOpen = false;
		this._onScrollHandler();
	}
	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);
		this.openButton = this.el.getElement(this.options.openButtonSelector);
		this.backToTopButton = this.el.getElement(this.options.backToTopButtonSelector);
		this.openButton.addEvent('click', this._toggleOpen.bind(this));
		this.el.set('morph', this.options.animation);

		this._scrollParent = this.el.getScrollParent();
		this._scrollParent.addEvent('scroll', this._onScrollHandler.bind(this));
		this.backToTopButton.addEvents({
			mouseenter: this._toggleBackToTop.bind(this)
			,mouseleave: this._toggleBackToTop.bind(this)
			,click: this._scrollToTop.bind(this)
		});
		this.backToTopButton.set('morph', this.options.animation.backToTop);
		
		Uverse.page.addMemoryEvent('modalLoaded', this._onModalPlayerOpen.bind(this));
		Uverse.page.addMemoryEvent('modalClosed', this._onModalPlayerClosed.bind(this));
	}
});/**
 * Infinite Scroll
 * Watches the tile container,
 * and fires an event when the user
 * approaches the bottom of the container.
 */
Uverse.widgets.InfiniteScroll = new Class({
		// Extends, Implements
	Implements: [Options, Callbacks]
	, Binds: ['_onScrolledIn', '_onWindowResize']

		// Instance members

	, options: {
		minDistance: 1000
	}
	, callbacks: {
		'endOfContainerReached': null
	}

	, scrollingOptions: {
		distance: {
			bottom: -1000 // auto-adjusts to window height
		}
	}

	, tileContainer: null
	, lastTile: null
	, pageHeight: 0
	, emptyDistance: 0
	, columns: []
	, disabled: false


	// Constructor
	, initialize: function (tileContainer, options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
		this.scrollingOptions = Object.clone(this.scrollingOptions);
		this.tileContainer = tileContainer;

		this._setupResize();
		this._setupScrolling();
	}

	, _setupResize: function () {
		window.addEvent('resize:pace(1000)', this._onWindowResize);
		this._onWindowResize();
	}

	, _onWindowResize: function () {
		// Our 'endOfContainerReached' event should be based
		// on the height of the window:
		this.pageHeight = window.getHeight();
		this._updateScrollingOptions();
	}

	, _setupScrolling: function () {
		this.tileContainer.store('scrollingOptions', this.scrollingOptions);
		this.tileContainer.addEvent('scrolling:position(above top)', this._onScrolledIn);
	}

	, updateScrollingContainer: function(newContainer) {
		this.tileContainer.removeEvent('scrolling:position(above top)', this._onScrolledIn);
		this.tileContainer = newContainer;
		this._setupScrolling();
	}

	/**
	 * Tears down the scrolling events
	 */
	, destroyInfiniteScroll: function() {
		window.removeEvent('resize:pace(1000)', this._onWindowResize);
		this.tileContainer.removeEvent('scrolling:position(above top)', this._onScrolledIn);
	}

	, disable: function() {
		this.disabled = true;
	}
	, enable: function() {
		this.disabled = false;
	}


	, _onScrolledIn: function(actions, direction, position) {
		if (!this.disabled) {
			this.callbacks['endOfContainerReached']();
		}
	}

	/**
	 * Sets the updated columns, so that scrolling events can be monitored correctly.
	 */
	, updateColumns: function(columns) {
		this.columns = columns;

		this._updateEmptyDistance();
	}
	, _updateEmptyDistance: function() {
		if (this.columns.length == 0) {
			return;
		}

		var columnHeights = this.columns.map(function(c){ return c.getHeight(); });
		this.emptyDistance = columnHeights.max() - columnHeights.min();

		this._updateScrollingOptions();
	}

	, _updateScrollingOptions: function() {
		var distance = Math.max(this.options.minDistance, this.pageHeight + this.emptyDistance);
		this.scrollingOptions.distance.bottom = -distance;
	}

	, tilesAdded: function() {
		this._updateEmptyDistance();

		// Update all scrolling elements
		var scrollParent = this.tileContainer.getScrollParent();
		scrollParent.fireEvent('scroll');

		// Check to see if our container has enough items now,
		// or if we still need to retrieve more:
		var position = this.tileContainer.getScrollingPosition(this.scrollingOptions);
		if (position === 'above' || position === 'top') {
			this.callbacks['endOfContainerReached']();
		}
	}

});
Uverse.widgets.MainNavigation = new Class({
	Implements: [ Options ]

	, options: {
		addHoveredClass: true
	}
	, el: null
	, fx: {
		cssSelector: 'transition-main-nav-menu-shown'
	}

	, initialize: function(el, options) {
		this.el = el;
		this.setOptions(options);
		
		this._addEvents();
	}

	, _addEvents: function() {
		this.el.getElements('.main-nav-item').addEvents({
			'mouseenter': this._onItemHoverEnter.bind(this)
			,'mouseleave': this._onItemHoverExit.bind(this)
		});
	}
	
	, _onItemHoverEnter: function(ev) {
		var item = $(ev.target).getClosest('.main-nav-item');

		if(this.options.addHoveredClass)
			item.addClass('hovered');

		var menu = item.getElement('.main-nav-menu');
		menu && menu.addClassWithTransition(this.fx.cssSelector);
	}
	
	, _onItemHoverExit: function(ev) {
		var item = $(ev.target).getClosest('.main-nav-item');

		if(this.options.addHoveredClass)
			item.removeClass('hovered');

		var menu = item.getElement('.main-nav-menu');
		menu && menu.removeClassWithTransition(this.fx.cssSelector);
	}
});
Uverse.widgets.MainLinks = new Class({
	Implements: [ Options ]
	, el: null

	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);

		Uverse.page.addMemoryEvent('Personalization-userData', function (userData) {
			if (userData.isLoggedIn()) {
				Uverse.page.addMemoryEvent('Favorite-assetList', this._updateFavoritesCount.bind(this));
			}
		}.bind(this));
	}
	, _updateFavoritesCount: function() {
		var badges = this.el.getElements('.badge.favoritesCount');
		var count = Uverse.page.favorite.getFavoriteCount();
		badges.each(function(badge) {
			this._updateBadgeText(badge, count, (count > 0));			
		}, this);
	}
	, _updateBadgeText: function(badge, text, enabled) {
		badge.getElement('.badge-text').innerHTML = text;
		badge.removeClass('hidden');
		if (enabled) {
			badge.removeClass('disabled');
		} else {
			badge.addClass('disabled');
		}		
	}
});/**
 * Holds Modal contents.
 */
Uverse.widgets.Modal = new Class({
	Implements: [
		Options
		, Callbacks
		, MemoryEvents
	]
	, Binds: [ '_onModalClick', '_closeModal' ]
	, options: {
		/**
		 * @param {String} [debugName] A friendly name for debugging purposes only
		 */
		debugName: ""
		,className: ""
		,closeOnForegroundClick: false
		,closeOnBackgroundClick: true
		,closeOnEscape: true
		,requestOptions: null // MooTools Request options object
	}
	, callbacks: {
		/**
		 * Fires when the modal is opening
		 * @type {Function|Boolean} [optional]
		 */
		'modalOpening': false
		/**
		 * Fires when the modal is closing
		 * @type {Function|Boolean} [optional]
		 */
		,'modalClosing': false
		/**
		 * Fires when the modal is closed
		 * @type {Function|Boolean} [optional]
		 */
		,'modalClosed': false
	}

	, contents: null
	, modalContents: null
	, modalManager: null
	, request: null
	, loadedWidgets: null

	, initialize: function(contents, options, callbacks) {
		this.contents = contents;
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	, loadModal: function(modalManager) {
		if (this.callbacks['modalOpening'])
			this.callbacks['modalOpening']();

		this.modalManager = modalManager;

		this._setupModalEvents(modalManager.modalContainer);

		this.modalContents = modalManager.modalContents;
		this.modalContents.empty().adopt(this.contents);
		this.contents = null;

		if (this.options.className) {
			modalManager.modalContainer.addClass(this.options.className);
			modalManager.modalShadow.addClass(this.options.className);
		}

		if (this.options.requestOptions) {
			this._startRequest(this.options.requestOptions);
		}

		this.fireMemoryEvent('modalLoaded');
	}

	, unloadModal: function(modalManager) {
		if (this.callbacks['modalClosing'])
			this.callbacks['modalClosing']();

		this._teardownModalEvents(modalManager.modalContainer);
		if (this.options.className) {
			modalManager.modalContainer.removeClass(this.options.className);
			modalManager.modalShadow.removeClass(this.options.className);
		}

		if (this.request && this.request.isRunning()) {
			this.request.cancel();
		}

		this.fireMemoryEvent('modalUnloaded');
	}

	, destroyModal: function() {
		if (this.callbacks['modalClosed'])
			this.callbacks['modalClosed']();
		this.fireMemoryEvent('modalDestroying');

		this.modalContents.empty();
		this.modalContents = null;
		this.contents = null;

		this.modalManager = null;
	}



	, _setupModalEvents: function(modalContainer) {
		if (this.options.closeOnEscape)
			$(document).addEvent('keydown:keys(esc)', this._closeModal);
		if (this.options.closeOnBackgroundClick || this.options.closeOnForegroundClick)
			modalContainer.addEvent('click', this._onModalClick);
	}
	, _teardownModalEvents: function(modalContainer){
		$(document).removeEvent('keydown:keys(esc)', this._closeModal);
		modalContainer.removeEvent('click', this._onModalClick);
	}

	, _closeModal: function() {
		this.modalManager.closeCurrentModal();
	}
	, _onModalClick: function(ev) {
		if (ev.wasDefaultPrevented())
			return;

		var options = this.options;
		var isForegroundClick = this.modalContents.contains(ev.target) && (this.modalContents !== ev.target);
		var isCloseButtonClick = !!ev.target.getClosest('.modal-close-button');

		var shouldClose = isCloseButtonClick || (options.closeOnForegroundClick && isForegroundClick) || (options.closeOnBackgroundClick && !isForegroundClick);
		if (shouldClose) {
			ev.preventDefault();
			this._closeModal();
			if (!isCloseButtonClick) {
				Uverse.page.clickTrack(ev.target, {addAction:"Background Close"});
			}
		}
	}



	, _startRequest: function(requestOptions) {
		requestOptions = Object.merge({
			update: this.modalContents
		}, requestOptions);
		this.request = new Request.HTML(requestOptions);
		this.request.addEvent('success', this._onRequestSuccess.bind(this));
		this.request.send();
	}
	, _onRequestSuccess: function(tree, elements, html, javascript) {
		// Process the Uverse.load() queue:
		this.loadedWidgets = Uverse.loader.processQueue({ preventLazyLoad: true });

		this.addMemoryEvent('modalLoaded', function() {
			this.loadedWidgets.load();
		}.bind(this));
		this.addMemoryEvent('modalUnloaded', function() {
			this.loadedWidgets.unload();
		}.bind(this));
		this.addMemoryEvent('modalDestroying', function() {
			this.loadedWidgets.destroy();
		}.bind(this));

	}

});

/**
 * Handles the loading & unloading of multiple Modal pages.
 */
Uverse.widgets.ModalManager = new Class({
	Implements: [ Options, Callbacks ]

	, options: {
		 modalContainerId: null
		,modalShadowId: null
	}
	, callbacks: {
		'modalClosed': null
	}

	, modalContainer: null
	, modalContents: null
	, modalShadow: null

	, currentModal: null
	, shadowShown: false
	, currentScroll: null

	, initialize: function (options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);

		this.modalContainer = $(this.options.modalContainerId);
		this.modalContents = this.modalContainer.getElement('.modal-contents');
		this.modalShadow = $(this.options.modalShadowId);
	}

	/**
	 * Loads and shows the modal page.
	 *
	 * Hides any existing modal.
	 */
	, loadModal: function(modal) {
		if (this.currentModal)
			this._hideModal(false);

		this.currentModal = modal;

		this._showModal();
	}
	/**
	 * Closes the current modal page.
	 */
	, closeCurrentModal: function() {
		if (!this.currentModal)
			return;

		this._hideModal(true);
		this.callbacks['modalClosed']();
	}

	, _showModal: function() {
		Uverse.console.log("[ModalManager]", "Showing modal ", this.currentModal.options.debugName);

		this.currentModal.loadModal(this);

		this.modalContainer.removeClass('hidden');
		this.modalContainer.addClassWithTransition('transitions-modal-container-open');

		this._showShadow();
	}
	, _showShadow: function() {
		if (this.shadowShown)
			return;

		this.shadowShown = true;
		this._hidePrimaryScrollBars();

		this.modalShadow.removeClass('hidden');
		this.modalShadow.addClassWithTransition('transitions-modal-shadow-open');
	}


	, _hideModal: function(hideShadow) {
		Uverse.console.log("[ModalManager]", "Hiding modal ", this.currentModal.options.debugName);

		if (hideShadow) {
			this._hideShadow();
		}

		this.modalContainer.removeClassWithTransition('transitions-modal-container-open');
		this.modalContainer.get('morph').chain(function(){
			this.modalContainer.addClass('hidden');
		}.bind(this));

		this.currentModal.unloadModal(this);
		this.currentModal.destroyModal();
		this.currentModal = null;
	}
	, _hideShadow: function() {
		this.shadowShown = false;

		this.modalShadow.removeClassWithTransition('transitions-modal-shadow-open');
		this.modalShadow.get('morph').chain(function(){
			this.modalShadow.addClass('hidden');
		}.bind(this));

		this._restoreScrollBars();

	}



	, _hidePrimaryScrollBars: function() {
		var scrollBarSize = this._getScrollBarSize();

		var scrollParent = $(document.html);
		this.currentScroll = scrollParent.getScroll(); // Needs to be restored in FireFox
		scrollParent.setStyles({
			'overflow': 'hidden'
			,'padding-right': scrollBarSize.width
		});

		scrollParent.scrollTo(this.currentScroll.x, this.currentScroll.y);
	}
	, _restoreScrollBars: function(){
		var scrollParent = $(document.html);
		scrollParent.setStyles({
			'overflow': null
			,'padding-right': null
		});
		
		scrollParent.scrollTo(this.currentScroll.x, this.currentScroll.y);
	}
	, _getScrollBarSize: function(){
		if (this.scrollBarSize) {
			return this.scrollBarSize;
		}

		var measureElement = new Element('div').setStyles({
			'visibility': 'hidden', 'position': 'absolute', 'top': '0'
			,'height': '100px', 'width': '100px'
			,'overflow': 'scroll'
		});
		$(document.body).adopt(measureElement);
		var scrollSize = measureElement.getScrollSize(), size = measureElement.getSize();
		measureElement.dispose();

		this.scrollBarSize = { width: size.x-scrollSize.x, height: size.y-scrollSize.y };
		return this.scrollBarSize;
	}



});
Uverse.widgets.NotificationCreator = new Class({
	Implements: [Callbacks]
	             
	, callbacks: {
		showLoading: null
		, hideLoading: null
		, showMessage: null
	}
	, categoryPath: null
	, currentState: null
	, email: null
	, notificationTemplateElementID: 'notificationOptionsTemplate'
	, screens: {
		set: null
		, setForm: null
		, hasBeenSet: null
	}
	, requestData: {
		request: null
		, params: {
			data: {}
		}
	}

	, initialize: function(categoryPath, callbacks) {
		this.setCallbacks(callbacks);
		this.categoryPath = categoryPath;
		this.requestData.request = new Request.JSON({
			url: Uverse.config.notification.urls.create
			, method: 'post'
			, noCache: true
			, onSuccess: this._onSaveSuccess.bind(this)
		});
		Uverse.page.addMemoryEvent('Notification-userEmail', this._onNotificationUserEmailChanged.bind(this));
	}
	
	, _onNotificationUserEmailChanged: function() {
		if(this.screens.hasBeenSet) {
			this._updateEmailInTemplate(this.screens.hasBeenSet);
		}
		if(this.screens.setForm) {
			this._updateEmailTextField($(this.screens.setForm.email));
		}
	}
	
	, _updateEmailInTemplate: function(template) {
		template.getElement('.email').set('text', Uverse.page.getNotificationUserEmail());
	}
	
	, _updateEmailTextField: function(input) {
		input.set('value', Uverse.page.getNotificationUserEmail());
	}
	
	, getUI: function(state) {
		this.currentState = state;
		
		var stateClassNames = this._getClassNamesFromState(state);
		var template = this._getTemplate(stateClassNames);
		
		this._unHideFirstScreen(template);
		
		return template;
	}
	
	, _unHideFirstScreen: function(template) {
		template.getChildren()[0].removeClass('hidden');
	}
	
	, _getClassNamesFromState: function(state) {
		switch (state)
		{
		case Uverse.page.notification.itemStates.NOT_NOTIFIED:
			return ['set', 'hasBeenSet'];
		case Uverse.page.notification.itemStates.NOTIFIED:
			return ['hasBeenSet'];
		}
	}
	
	, _getTemplate: function(stateClassNames) {
		var template = $(this.notificationTemplateElementID);
		var templateArray = [];
		
		stateClassNames.each(function(stateClassName) {
			switch (stateClassName)
			{
			case 'set':
				var saveTemplate = template.getElement('.set').clone();
				this.screens.set = saveTemplate;
				this.screens.setForm = saveTemplate.getElement('form');
				this._updateEmailTextField($(this.screens.setForm.email));
				this._addSaveEventsToTemplate(saveTemplate);
				templateArray.push(saveTemplate);
				break;
			case 'hasBeenSet':
				var confirmTemplate = template.getElement('.hasBeenSet').clone();
				this._updateEmailInTemplate(confirmTemplate);
				this.screens.hasBeenSet = confirmTemplate;
				templateArray.push(confirmTemplate);
				break;
			}
		}, this);
		
		template = new Element('div');
		templateArray.each(function(templateItem) {
			template.adopt(templateItem);
		});
		
		return template;
	}
	
	, _addSaveEventsToTemplate: function(template) {
        new Uverse.controls.Form(this.screens.setForm, { 'submit': this._onSaveSubmit.bind(this) });
	}
	
	, _onSaveSubmit: function(ev, formValues) {
		if(this._invalidEmail(formValues.email)) {
			this.callbacks.showMessage(Uverse.config.messages.error.invalidEmail);
			return;
		}
		
		this.callbacks.showLoading();
		
		this.requestData.params.data.seriesPath = this.categoryPath;
        this.requestData.params.data.email = formValues.email;
		
		this.requestData.request.send(this.requestData.params);
	}
	
	, _invalidEmail: function(email) {
		if(this._isEmailEmpty(email)) { return true; }
		else if(this._isEmailInvalid(email)) { return true; }
		else { return false; }
	}
	
	, _isEmailEmpty: function(email) {
		return (email && email !== '') ? false : true;
	}
	
	, _isEmailInvalid: function(email) {
		var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	    return !re.test(email);
	}

	, _onSaveSuccess: function(response) {
		Uverse.page.notificationUserEmailChanged(response.emailAddr);
		Uverse.page.notificationAddCategoryPath(this.categoryPath);
		this.screens.set.addClass('hidden');
		this.screens.hasBeenSet.removeClass('hidden');
		this.currentState = Uverse.page.notification.itemStates.NOTIFIED;
		this.callbacks.hideLoading();


	}
});Uverse.widgets.NotificationIcon = new Class({
	Extends: Uverse.widgets.ParentIcon
	
	, categoryPath: null
	             
	, initialize: function(el, categoryPath, callbacks) {
		this.parent(el, callbacks);
		this.categoryPath = categoryPath;
		this.state = Uverse.page.notification.itemStates.NOT_NOTIFIED;
		Uverse.page.addMemoryEvent('Notification-showList', this._onNotificationEpisodeListRetrieved.bind(this));
	}

	/** Overrides base */
	, setState: function(state) {
		this.state = state;
		this.callbacks.onStateChange(state);
		
		this.icon.removeClass('active');
		
		if(this.state == Uverse.page.notification.itemStates.NOTIFIED) {
			this.icon.addClass('active');
		} 
	}
	
	, _onNotificationEpisodeListRetrieved: function() {
		this.setState(Uverse.page.getNotificationStateForItem(this.categoryPath));
	}
});
/**
 * PageWidth
 * Determines the number of columns that fit in a page,
 * and when that number changes,
 * fires the 'PageWidth_columnsChanged' event.
 */
Uverse.widgets.PageWidth = new Class({
    /* Extends, Implements */
    Implements: [
        Options
    ]
    , Binds: ['_onWindowResize']

    /* Instance members */
    , options: {
        minimumColumns: 4
		,columnWidth: null
		,columnPadding: 8+8
		,pagePadding: 10+10
    }

    , pageContainer: null

    , columnCount: 0


    /* Constructor */
    , initialize: function (pageContainer, options) {
        this.pageContainer = $(pageContainer);
        this.setOptions(options);

        var columnTemplate = this.pageContainer.getElement('.columnTemplate');
        // If there's no columnTemplate, then we don't need PageWidth.
        // (This only happens on the error page)
        if (!columnTemplate)
            return;

        this._setupElements(columnTemplate);
        this._setupEvents();
    }

    , _setupElements: function(columnTemplate) {
        // Measure the column width:
        this.options.columnWidth = columnTemplate.getWidth();

        // spot-check
        Uverse.console.assert(this.options.columnWidth, "[PageWidth]", "Failed to initialize!  Could not find the column width.");
    }

    , _setupEvents: function() {
        // Resize event:
        window.addEvent('resize:pace(100)', this._onWindowResize);

        // initialize the columns:
        this._onWindowResize();
    }

    , _onWindowResize: function() {
        var parentWidth = this.pageContainer.getParent().getWidth();
        var newColumnCount = Math.floor((parentWidth - this.options.pagePadding + this.options.columnPadding) / this.options.columnWidth);
        var oldColumnCount = this.columnCount;

        if (newColumnCount < this.options.minimumColumns) {
            newColumnCount = this.options.minimumColumns;
        }

        if (oldColumnCount !== newColumnCount)
        {
            this.columnCount = newColumnCount;
            var newWidth = newColumnCount * this.options.columnWidth - this.options.columnPadding;

            Uverse.page.fireMemoryEvent('PageWidth_columnsChanging', [newColumnCount, oldColumnCount, newWidth]);

            var pageWidthElements = this.pageContainer.getElements('.needsPageWidth');
            pageWidthElements.setStyle('width', newWidth);

            Uverse.page.fireMemoryEvent('PageWidth_columnsChanged', [newColumnCount, oldColumnCount, newWidth]);
        }
    }

});

Uverse.widgets.PlayerLoader = new Class({
	Implements: [ Options, Callbacks ]

	, options: {}
	, callbacks: {
		'loadModal': null
	}

	, playerTemplate: null

	, initialize: function(playerTemplate, options, callbacks) {
		this.playerTemplate = playerTemplate;
		this.setOptions(options);
		this.setCallbacks(callbacks);

		this._setupShrink();
	}

	, _setupShrink: function() {
		this.shrink = new Uverse.utils.Shrink();
	}


	/**
	 * @param {Object} videoInfo
	 * @param {String} videoInfo.videoId
	 * @param {String} videoInfo.categoryPath
	 * @param {String} [videoInfo.videoNetwork]
	 * @param {String} [videoInfo.videoTitle]
	 * @param {String} [videoInfo.nextVideoHistory]
	 */
	, playVideo: function(videoInfo) {
		var container = this.playerTemplate.clone();

		container.getElement('.playerLoader-network').set('text', videoInfo.videoNetwork || "");
		container.getElement('.playerLoader-title').set('text', videoInfo.videoTitle || "");
		container.getElement('.playerLoader-subtitle').set('text', videoInfo.videoSubtitle || "");
		container.getElement('.playerLoader-description').set('text', videoInfo.videoDescription || "");

		var data = {
			categoryPath: videoInfo.categoryPath
			,videoId: videoInfo.videoId
		};
		if (videoInfo.nextVideoHistory) {
			data['nextVideoHistory'] = videoInfo.nextVideoHistory;
		}
		
		var modalOptions = {
			debugName: "Play Video " + videoInfo.videoId
			,className: 'modal-container-for-modal-player'
			,requestOptions: {
				url: '/getPlayer.html'
				,data: data
				,onFailure: this._onRequestFailure.bind(this, container)
			}
		};
		var modalCallbacks = {};

		var modal = new Uverse.widgets.Modal(container, modalOptions, modalCallbacks);
		this.callbacks['loadModal'](modal);

		this.shrink.resize(container.getElement('.playerLoader-shrink'));

	}

	, _onRequestFailure: function(container, xhr) {
		container.getElement('.player-loading').addClass('hidden');
		container.getElement('.loadingError-extension').removeClass('hidden');
	}
});Uverse.widgets.QuickSearch = new Class({
	Implements: [ Options ]
	, Binds: ['_onRequestSuccess', '_onDocumentClick']

	, options: {
		searchUrl         : null
		,searchKey        : null

		,requestPace           : 250
		,minCharacters         : 1
		,hidePreviewDelay      : 0001
	}

	, uversePage: false
	, iokoApp: false

	, el: null
	, request: null

	/** tileHelper is static: */
	, tileHelper: new Uverse.utils.TileHelper()

	/** entitlementHelper is static: */
	, entitlementHelper: new Uverse.utils.Entitlement()

	, formControl: null
	, textbox: null
	, searchResultsContainer: null

	, selectedResult: null

	, submittedSearchQuery: false

	, currentSearchTerms: ""
	, requestedSearchTerms: ""
	, displayedResultsSearchTerms: null
	, resultCache: {}

	, transitions: {
		'searching': null
	}


	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);

		var formElement = this.el.getElement('form');
		this._setupForm(formElement);
		this._setupRequest();
		this._setupResults();
		this._setupTextbox();
		if ((typeof Uverse != 'undefined') && !!Uverse.page && !!Uverse.page.clickTracking) { this.uversePage = true; }
		if ((typeof Ioko != 'undefined') && !!Ioko.namespace('storage', 'App')) { this.iokoApp = true; }
	}
	, _setupForm: function(formElement){

		var callbacks = {
			'submit': this._onSubmit.bind(this)
			,'changing': this._onChanging.bind(this)
		};

		this.formControl = new Uverse.controls.Form(formElement, callbacks);
	}
	, _onSubmit: function(ev, formValues) {
		if (!this.selectedResult || this.selectedResult.match('.quick-search-advanced-submit')) {
			// Navigate to the results page, if we've got valid text:
			if (formValues.query == '' || formValues.query.length < this.options.minCharacters) {
				// Do nothing.
			} else if (this.uversePage) {
				Uverse.page.clickTrack(ev.target, {
					callback: function() {
						Uverse.console.log("[QuickSearch]", "Navigating to the advanced search page.");
						this.formControl.submit();
						return true; // Indicates that we're navigating away
					}.bind(this)
					, addLabel: formValues.query
				});
			} else {
				this.formControl.submit();
			}
		} else {
			this._navigateToSelectedResult();
		}
	}
	, _onChanging: function(ev, control, newValue, oldValue) {
		this.currentSearchTerms = newValue.toLowerCase().clean();

		this._checkForChanges();
	}


	, _setupRequest: function() {
		this.request = new Request({
			url : this.options.searchUrl
			, method: 'POST'
			, onSuccess : this._onRequestSuccess
		});

		// Set a maximum pace for requests:
		this._sendRequest = this._sendRequest.pace(this.options.requestPace, this);
	}

	, _checkForChanges: function() {
		if (this.currentSearchTerms.length < this.options.minCharacters) {
			this._hideResults();
			this._hasText(false);
			return;
		}

		this._hasText(true);

		// Check cache:
		var cachedResult = this.resultCache[this.currentSearchTerms];
		if (cachedResult) {
			this._renderResults(this.currentSearchTerms, cachedResult);
			this._setIsSearching(false);
			return;
		}

		if (!this.request.isRunning()) {
			this._sendRequest();
		}
	}
	, _sendRequest: function() {
		Uverse.console.log('[QuickSearch]', 'Searching for', this.currentSearchTerms);
		this.requestedSearchTerms = this.currentSearchTerms;

		var data = {};
		data[this.options.searchKey] = this.currentSearchTerms;
		this.request.send({data:data});

		this._setIsSearching(true);
	}
	, _setIsSearching: function(isSearching) {
		this.el.toggleClass('searching', isSearching);
	}
	, _onRequestSuccess: function(html) {
		// Store to cache, then render:
		var searchTerms = this.requestedSearchTerms;
		this.resultCache[searchTerms] = html;
		this._renderResults(searchTerms, html);
		this._setIsSearching(false);
		// Chain:
		this._checkForChanges();
	}

	, _renderResults: function(searchTerms, html) {
		// Check current:
		if (this.displayedResultsSearchTerms === searchTerms) {
			return;
		}

		this.displayedResultsSearchTerms = searchTerms;

		this.searchResultsContainer.empty().set('html', html);
		if (this.searchResultsContainer.hasClass('hidden')) {
			this.searchResultsContainer.removeClass('hidden');
		}
		this.selectedResult = null;

		this._setupPlayLinks();
		this._setupEntitlement();

		Uverse.console.log('[QuickSearch]', 'Rendered search results for ', searchTerms);
	}

	, _hideResults: function() {
		this.searchResultsContainer.addClass('hidden').empty();
		this.displayedResultsSearchTerms = null;
	}
	, _resultsAreVisible: function() {
		return (this.displayedResultsSearchTerms !== null);
	}

	, _hasText: function(hasText) {
		this.el.toggleClass('has-text', hasText);
	}


	, _setupResults: function() {
		this.searchResultsContainer = this.el.getElement('.quick-search-results-container');
		this.searchResultsContainer.addEvents({
			'mouseover:relay(.quick-search-result, .quick-search-advanced-submit)': function(ev, target){ this._setSelectedResult(target);}.bind(this)
			,'mouseout:relay(.quick-search-result, .quick-search-advanced-submit)': function(ev, target){ this._setSelectedResult(null); }.bind(this)
			,'click:relay(.quick-search-result-link)': function(ev, target){ this._clickedLink(ev, target);}.bind(this)
		});
	}
	, _onDocumentClick: function(ev) {
		var target = $(ev.target);
		var isClickOut = !this.el.contains(target);
		if (isClickOut) {
			this._onBlur(null);
		}
	}

	, _setupTextbox: function() {
		this.textbox = this.el.getElement('.quick-search-textbox');
		Uverse.console.assert(this.textbox);

		this.textbox.addEvents({
			'keydown': this._onKeyDown.bind(this)
			,'focus': this._onFocus.bind(this)
		});
	}
	, _onFocus: function(ev) {
		this.el.addClass('active');
		$(document.body).addEvent('click', this._onDocumentClick);
		this._checkForChanges();
	}
	, _onBlur: function(ev) {
		this.el.removeClass('active');
		$(document.body).removeEvent('click', this._onDocumentClick);
		this._hideResults();
	}
	, _onKeyDown: function(ev) {
		if (this._resultsAreVisible()) {
			switch (ev.key) {
				case 'esc':
					ev.preventDefault();
					if (this.selectedResult) {
						this._setSelectedResult(null);
					} else {
						this._hideResults();
					}
					break;
				case 'up':
					ev.preventDefault();
					this._moveSelection(-1);
					break;
				case 'down':
					ev.preventDefault();
					this._moveSelection(1);
					break;
				case 'tab':
					ev.preventDefault();
					if (ev.shift)
						this._moveSelection(-1);
					else
						this._moveSelection(1);
					break;
				case 'left':
					if (this._hasSelection()) {
						this._highlightPreview();
					}
					break;
				case 'right':
					if (this._hasSelection()) {
						this._unhighlightPreview();
					}
					break;
			}
		}
	}

	, _moveSelection: function(direction) {
		var selectedIndex = -1;
		var results = this.el.getElements('.quick-search-result, .quick-search-advanced-submit');
		if (this.selectedResult) {
			// find the index:
			selectedIndex = results.indexOf(this.selectedResult);
		}
		selectedIndex += direction;
		if (selectedIndex < 0) {
			selectedIndex = results.length - 1;
		}
		if (selectedIndex >= results.length) {
			selectedIndex = 0;
		}

		this._setSelectedResult(results[selectedIndex]);
	}

	, _hasSelection: function() {
		return (this.selectedResult !== null);
	}

	, _setSelectedResult: function(newSelectedResult) {
		if (this.selectedResult === newSelectedResult) {
			return;
		}

		if (this.selectedResult) {
			this.selectedResult.removeClass('selected');
		}
		if (newSelectedResult) {
			newSelectedResult.addClass('selected');
		}
		this.selectedResult = newSelectedResult;

		this._updatePreview();
	}

	, _navigateToSelectedResult: function() {

		var activeImageOverlayLink = (this.currentPreview && this.currentPreview.getElement('.image-overlay-active a'));

		var targetedResult = activeImageOverlayLink || this.selectedResult.getElement('.quick-search-result-link');

		targetedResult.focus();
		targetedResult.click();
	}


	, _updatePreview: function() {
		if (!this.selectedResult || this.selectedResult.match('.quick-search-advanced-submit')) {
			this.hidePreviewTimer = this._hidePreview.delay(this.options.hidePreviewDelay, this, [true]);
		} else {
			this._hidePreview();
			this.currentPreview = this.selectedResult.getElement('.quick-search-preview-container');
			this._showPreview();
		}
	}
	, _showPreview: function() {
		if (this.currentPreview.hasClass('hidden')) {
			this.currentPreview.fade('hide').removeClass('hidden');
		}
		this.currentPreview.fade('in', 'quint:out');
		this._positionCurrentPreview();
	}
	, _hidePreview: function(slow) {
		if (this.hidePreviewTimer) {
			clearTimeout(this.hidePreviewTimer);
			this.hidePreviewTimer = null;
		}
		if (this.currentPreview) {
			this.currentPreview.fade('out', (slow ? 'quint:in' : 'quint:out'));
			this._unhighlightPreview();
		}
	}
	, _highlightPreview: function() {
		if (this.currentPreview) {
			this.currentPreview.getElements('.image-overlay').addClass('image-overlay-active');
		}
	}
	, _unhighlightPreview: function () {
		if (this.currentPreview) {
			this.currentPreview.getElements('.image-overlay-active').removeClass('image-overlay-active');
		}
	}

	, _positionCurrentPreview: function() {
		var tileShadow = 8, containerOffset = 4
			,previewTile = this.currentPreview.getElement('.quick-search-preview-tile')
			,containerTop = this.searchResultsContainer.getTop() + containerOffset
			,containerHeight = this.searchResultsContainer.getHeight() - containerOffset*2
			,previewTop = previewTile.setStyle('top', 0).getTop() + tileShadow
			,previewHeight = previewTile.getHeight() - tileShadow*2
			,resultTop = this.selectedResult.getTop()
			,resultHeight = this.selectedResult.getHeight();

		var top = resultTop + (resultHeight - previewHeight)/2;
		// Fit within the container:
		top = Math.max(Math.min(containerTop + containerHeight - previewHeight, top), containerTop);

		previewTile.setStyle('top', top - previewTop);
	}

	, _clickedLink: function(ev, link) {
		var followLink = (ev.getMouseButton() == 'left'), async = !followLink;
		if (followLink) {
			ev.preventDefault();
		}

		var label = "";
		if (this.uversePage) {
			label = link.get(Uverse.page.getConstant('clickTracking', 'attributeMap.prefix') + Uverse.page.getConstant('clickTracking', 'attributeMap.names.label'));
		} else if (this.iokoApp) {
			label = link.get(Ioko.namespace('storage', 'App').clickTracking.LABEL);
		}
		var href = link.get('href');
		this._reportSearchQuery(label, async);

		if (this.uversePage) {
			Uverse.page.clickTrack(link, {
				callback: function() {
					Uverse.console.log("[QuickSearch]", "Clicked a search suggestion.");
					if (followLink && !!href && !this.submittedSearchQuery ) {
						window.location = href;
						this.submittedSearchQuery = true;
						return true; // Indicates that we're navigating away
					}
				}.bind(this)
			});
		} else if (this.iokoApp) {
			Ioko.namespace('storage', 'App').clickTracking.track(link, {
				followLink: followLink
				,event: ev
			});
		}
	}

	, _reportSearchQuery: function(text, async) {
		//submit only one search query suggestion
		if (!this.submittedSearchQuery) {
			var reportRequest = new Request({
				url : '/report/search_queries.json'
				,method: 'POST'
				,async: async
				,link : 'chain'
			});
			reportRequest.send({
				data: {
					'query_type' : 'TYPEAHEAD'
					,'query' : text
				}
			});
		}
	}


	, _setupPlayLinks: function() {

		this.tileHelper.setupVideoPlayLinks(this.el);

		if (!this.playLinksBound) {
			this.playLinksBound = true;
			this.el.addEvent('click:button(left):relay(.video-play-link)', this._onPlayLinkClick.bind(this));
		}
	}
	, _onPlayLinkClick: function(ev, videoPlayLink) {
		ev.preventDefault();

		this.tileHelper.loadVideoPlayLink(this.el, videoPlayLink);

		this._onModalOpened();
	}
	, _onModalOpened: function() {
		// TODO: Somehow, hook into the modal opening/closing:
		//Uverse.page.addEvent('modalClosed', this._onModalClosed);

		// For now, we're going to hide the results when the modal's opened:
		this._onBlur(null);
	}
	, _onModalClosed: function() {
		//Uverse.page.removeEvent('modalClosed', this._onModalClosed);
		this._onFocus(null);
	}

	, _setupEntitlement: function() {
		if (this.uversePage && Uverse.page.isUserLoggedIn()) {
			var tiles = this.el.getElements('.tile');
			tiles.each(function(tile){
				this.tileHelper.applyEntitlement(tile, this.entitlementHelper);
			}, this);
		}

	}

});


/**
 * Sets up recording icons on tile and provides data to populate tile slider.
 */
Uverse.widgets.RecordingIcon = new Class({
	Extends: Uverse.widgets.ParentIcon
	
	, normalizedProgramTitle: ''
	, type: null

    /* Constructor */
    , initialize: function(el, callbacks, normalizedProgramTitle, type) {
		this.parent(el, callbacks);
        this.normalizedProgramTitle = normalizedProgramTitle;
        this.type = type;
        
        this.state = Uverse.page.dvr.itemStates.UNKNOWN;
        
        if(this.el) {
			Uverse.page.addMemoryEvent('Dvr-dvrItems', this._onDvrDataRecieved.bind(this));
        }
    }
    
	, _onDvrDataRecieved: function() {
		this.setState(Uverse.page.getDvrRecordStateForItem(this.normalizedProgramTitle, Uverse.page.dvr.isSeriesFromType(this.type)));
	}

	/** Overrides base */
	, setState: function(state) {
		this.state = state;
		this.callbacks.onStateChange(state);
		
		this.icon.removeClass('active');
		this.icon.removeClass('activeSeries');

		switch (this.state) {
			case Uverse.page.dvr.itemStates.RECORDED.SINGLE:
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SINGLE:
				this.icon.addClass('active');
				break;
			case Uverse.page.dvr.itemStates.RECORDED.SERIES:
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SERIES:
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SERIES_WITH_RERUNS:
				this.icon.addClass('activeSeries');
				break;
		}
		this.icon.show();

	}
});
Uverse.widgets.Recorder = new Class({
	Implements: [Callbacks]
	             
	, callbacks: {
		showLoading: null
		, hideLoading: null
		, showMessage: null
		, recordSuccess: null
	}
	
	, recordingTemplateElementID: 'recordingOptionsTemplate'
	, recordRequestData: {
		request: null
		, params: {
			data: {}
		}
	}
	, epgInfo: {}
	, type: null
	, recordRequest: null
	, recordingForms: {
		record: null
		, setToRecord: null
	}
	, currentState: null
	
	, initialize: function(type, callbacks) {
		this.type = type;
		this.setCallbacks(callbacks);
		this.recordRequestData.request = new Request.JSON({
			url: Uverse.config.dvr.urls.record
			, method: 'post'
			, noCache: true
			, onSuccess: this._onRecordSuccess.bind(this)
			, onFailure: this._onRecordFailure.bind(this)
		});
	}
	
	, getUI: function(state, epgInfo) {
		this.epgInfo = epgInfo;
		this.currentState = state;
		
		var stateClassNames = this._getClassNamesFromState(state);
		var template = this._getRecordingTemplate(stateClassNames);
		this._updateTemplateViaType(stateClassNames, template);
		this._updateTemplateData(template, this.epgInfo);
		
		this.recordingForms.record = template.getElement('div.record');
		this.recordingForms.setToRecord = template.getElement('div.setToRecord');

		this._addRecordEventsToTemplate(template);

		return template;
	}

	, getErrorStateUI: function () {
		return this._getRecordingTemplate(['genericError']);
	}
	
	, _getClassNamesFromState: function(state) {
		switch (state) {
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SINGLE:
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SERIES:
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SERIES_WITH_RERUNS:
				return ['setToRecord'];
			case Uverse.page.dvr.itemStates.RECORDED.SINGLE:
			case Uverse.page.dvr.itemStates.RECORDED.SERIES:
				return ['recorded'];
			case Uverse.page.dvr.itemStates.CAN_BE_RECORDED:
				return ['record', 'setToRecord'];
			case Uverse.page.dvr.itemStates.CANNOT_BE_RECORDED:
				return ['cannotBeRecorded'];
			case Uverse.page.dvr.itemStates.CANNOT_BE_RECORDED_LOCAL:
				return ['cannotBeRecorded-local'];
		}
	}
	
	, _getRecordingTemplate: function(stateClassNames) {
		var template = $(this.recordingTemplateElementID);
		var templateArray = [];
		
		stateClassNames.each(function(stateClassName) {
			switch (stateClassName)
			{
			case 'recorded':
				templateArray.push(template.getElement('.recorded').clone());
				break;
			case 'setToRecord':
				templateArray.push(template.getElement('.setToRecord').clone());
				break;
			case 'record':
				var recordTemplate = template.getElement('.record').clone();
				templateArray.push(recordTemplate);
				break;
			case 'cannotBeRecorded':
				templateArray.push(template.getElement('.cannotBeRecorded').clone());
				break;
			case 'cannotBeRecorded-local':
				templateArray.push(template.getElement('.cannotBeRecorded-local').clone());
				break;
			case 'genericError':
				templateArray.push(template.getElement('.genericError').clone());
				break;
			}
		}, this);
		
		template = new Element('div');
		templateArray.each(function(templateItem, index) {
			// Make the first item visible:
			if (index == 0) {
				templateItem.removeClass('hidden');
			} else {
				templateItem.addClass('hidden');
			}
			template.adopt(templateItem);
		});

		return template;
	}
	
	, _updateTemplateViaType: function(stateClassNames, template) {
		stateClassNames.each(function(stateClassName) {
			var typeTemplate = $(this.recordingTemplateElementID).getElement('.labels').getElement('.' + stateClassName).getElement('.' + this.type).clone();
			var targetTemplate = template.getElement('.' + stateClassName);
			
			this._addSectionToTemplateOrRemove(targetTemplate, typeTemplate, 'description');
			this._addSectionToTemplateOrRemove(targetTemplate, typeTemplate, 'options');
			this._addSectionToTemplateOrRemove(targetTemplate, typeTemplate, 'time');
			this._addSectionToTemplateOrRemove(targetTemplate, typeTemplate, 'channel');
		}, this);
	}
	
	, _addSectionToTemplateOrRemove: function(template, typeTemplate, targetName) {
		var targetContent = null;
		var sourceElement = null;
		var targetElement = typeTemplate.getElement('.' + targetName);
		if(targetElement) {
			targetContent = targetElement.get('html');
			sourceElement = template.getElement('.' + targetName);
		} else {
			if(template.getElement('.' + targetName)) {
				template.getElement('.' + targetName).destroy();
			}
		}
		
		if(targetContent && sourceElement) {
			sourceElement.set('html', targetContent);
		} 
	}
	
	, _updateTemplateData: function(template) {
		if (!template)
			return;

		if(this.epgInfo.airDate) {
			this._addDataSectionToTemplate(template, '.time', this.epgInfo.airDate.friendlyFormat);
		}
		
		this._addDataSectionToTemplate(template, '.channel .number', this.epgInfo.channel.number);
		this._addDataSectionToTemplate(template, '.channel .name', this.epgInfo.channel.name);

		switch (this.currentState) {
			case Uverse.page.dvr.itemStates.SET_TO_RECORD.SERIES_WITH_RERUNS:
				break;
			default:
				this._hideReruns(template);
				break;

		}

	}
	
	, _addDataSectionToTemplate: function(template, targetName, value) {
		var sourceElements = template.getElements(targetName);
		sourceElements.set('text', value);
	}
	
	, _hideReruns: function(template) {
		var rerunElements = template.getElements('.description .reruns');
		if(rerunElements.length > 0) {
			rerunElements.hide();
		}
	}
	
	, _addRecordEventsToTemplate: function(template) {
		var formElement = template.getElement('form'); // (Assuming this is the only form)
		if (!formElement)
			return;

		var callbacks = {
			'submit': this._onRecordSubmit.bind(this)
		};
		this.formWidget = new Uverse.controls.Form(formElement, callbacks);
	}
	
	, _onRecordSubmit: function(ev, formValues) {
		this.callbacks.showLoading();
		
		this.recordRequestData.params.data.highDefinition = this.epgInfo.isHD ? "true" : "false";
		this.recordRequestData.params.data.programId = this.epgInfo.programID;
		this.recordRequestData.params.data.showType = formValues.includeReruns ? 'ANY' : 'FIRST_RUN_ONLY';
		this.recordRequestData.params.data.mode = 'generic';
		this.recordRequestData.params.data.series = Uverse.page.dvr.isSeriesFromType(this.type);
		
		this.recordRequestData.request.send(this.recordRequestData.params);
	}
	
	, _getState: function() {
		return this.currentState;
	}
	
	, _isRerunsSelected: function() {
		//var value = this._getRerunValue();
		//return value == 'FIRST_RUN_ONLY' ? false : true;
		var formValues = this.formWidget.getValues();
		return formValues.includeReruns;
	}
	
	, _onRecordSuccess: function(responseJSON) {
		this._showOrHideRerunsText();
		this.recordingForms.record.addClass('hidden');
		this.recordingForms.setToRecord.removeClass('hidden');
		this.currentState = Uverse.page.dvr.itemStates.SET_TO_RECORD[Uverse.page.dvr.getItemStateSingleSeriesNameFromType(this.type)];
		this.callbacks.recordSuccess({
			episodeRecorded: false
			, episodeScheduled: true
			, normalizedProgramTitle: this.epgInfo.normalizedProgramTitle
			, normalizedEpisodeTitle: this.epgInfo.normalizedEpisodeTitle
			, programId: this.epgInfo.programID
			, seriesScheduled: true
		});
		this._onRecordComplete();
	}
	
	, _showOrHideRerunsText: function() {
		var rerunsElement = this.recordingForms.setToRecord.getElement('.description .reruns');
		
		if(rerunsElement) {
			if(!this._isRerunsSelected()) { rerunsElement.hide(); } 
			else { rerunsElement.show('inline'); }
		}
	}
	
	, _onRecordFailure: function(responseJSON) {
		this.callbacks.showMessage(Uverse.config.messages.error.generic);
		this._onRecordComplete();
	}
	
	, _onRecordComplete: function() {
		this.callbacks.hideLoading();
	}
});/**
 * This class adds magic "shine" to the page.
 * More specifically, it looks for ".shiny-container .shiny",
 * and adds a cool glowing effect that follows the mouse.
 * This is used for custom controls and navigation.
 */
Uverse.widgets.Shiny = new Class({
	initialize: function(document){
		document.addEvents({
			'mouseover:pace(250):relay(.shiny-container)': this._createShiny
		});
	}

	, _createShiny: function(ev, shinyContainer) {
		var imgOffset = {x: 50, y: 50}; // (=image size/2)

		shinyContainer.addEvents({
			'mousemove:pace(15)': onMouseMove
			,'mouseleave:once': onMouseLeave
		});

		var shinys = (shinyContainer.match('.shiny')) ? new Elements([shinyContainer]) : shinyContainer.getElements('.shiny');
		shinys.addClass('shiny-shine');

		function update(mousePos){
			shinys.each(function(shiny){
				var elPos = shiny.getPosition();
				if (isNaN(elPos.x)) // IE8 issue?
					return;
				var pos = { x: mousePos.x - imgOffset.x - elPos.x, y: mousePos.y - imgOffset.y - elPos.y};
				shiny.setStyle('background-position', [pos.x, pos.y]);
			});
		}
		function onMouseMove(ev){
			update(ev.page);
		}
		function onMouseLeave(ev){
			cleanUp();
		}
		function cleanUp(){
			shinys.removeClass('shiny-shine');
			shinyContainer.removeEvent('mousemove', onMouseMove);
		}

	}

});
Uverse.widgets.SplashScreen = new Class({
	Implements: [ Options ]
	, Binds: [ '_onModalClosed' ]

	, cookieNames: {
		hiddenSplashScreens: 'hiddenSplashScreens'
	}
	, options: {
		splashScreenUniqueId: null
		, modalOptions: {
			debugName: 'Splash Screen'
			,className: 'modal-splash-screen'
			,closeOnBackgroundClick: true
			,closeOnForegroundClick: false
			,closeOnEscape: true
		}
	}
	, hiddenSplashScreens: []
	, splashScreenKey: null

	, splashScreenContents: null
	, initialize: function(el, options) {
		this.splashScreenContents = $(el).dispose();
		this.setOptions(options);

		this.splashScreenKey = this.options.splashScreenUniqueId;

		this._getHiddenSplashScreens();
		this._checkForSplashScreen();
	}

	, _getHiddenSplashScreens: function(){
		var hiddenSplashScreens = Cookie.read(this.cookieNames.hiddenSplashScreens);
		if (hiddenSplashScreens) {
			this.hiddenSplashScreens = hiddenSplashScreens.split(',');
		}
	}
	, _checkForSplashScreen: function(){
		if (!this.hiddenSplashScreens.contains(this.splashScreenKey)) {
			Uverse.console.log("[SplashScreen]", "Loading Splash Screen:", this.splashScreenKey);
			this._displaySplashScreen();
		} else {
			Uverse.console.log("[SplashScreen]", "Splash Screen has already been shown:", this.splashScreenKey);
			var splashScreenWasDisplayed = false;
			Uverse.page.splashScreenIsDone(splashScreenWasDisplayed);
		}
	}

	, _displaySplashScreen: function() {
		var modalOptions = this.options.modalOptions;
		var callbacks = { 'modalClosed': this._onModalClosed };
		var modal = new Uverse.widgets.Modal(this.splashScreenContents, modalOptions, callbacks);
		Uverse.page.loadModal(modal);
		this.splashScreenContents.removeClass('hidden');
	}

	, _onModalClosed: function () {
		this._hideSplashScreenForever();
		this.splashScreenContents.destroy();

		var splashScreenWasDisplayed = true;
		Uverse.page.splashScreenIsDone(splashScreenWasDisplayed);
	}
	, _hideSplashScreenForever: function(){
		Uverse.console.log("[SplashScreen]", "Hiding Splash Screen:", this.splashScreenKey);
		var tenYears = 3650; // days
		this.hiddenSplashScreens.push(this.splashScreenKey);
		var key = this.cookieNames.hiddenSplashScreens
			,value = this.hiddenSplashScreens.join(',')
			,options = { duration: tenYears };

		Cookie.write(key, value, options);
	}
});
/**
 * Parent class for Tile behavior.
 */
Uverse.widgets.Tile = new Class({
	Implements: [
		Options
	]

	/* Instance members */
	, el: null
	, drawer: null
	, currentDrawerItem: null
	, pendingOperationsCancelFunctions: null
	, entitlementMessageBase: null
	, recording: null
	, favorite: null

	/** tileHelper is static: */
	, tileHelper: new Uverse.utils.TileHelper()

	/** entitlementHelper is static: */
	, entitlementHelper: new Uverse.utils.Entitlement()

	, ENTITLEMENT_DATA_ATTR_NAME_UPGRADE_MESSAGE: 'data-entitlement-message-upgrade'
	, CLICK_TRACKING_ICON_STATES: {
		OPEN: 'Open'
		, CLOSE: 'Close'
	}

	, initialize: function(el, options, tileEvents) {
		this.el = el;
		this.pendingOperationsCancelFunctions = $H();
		this.setOptions(options);
		this.tileEvents = tileEvents;
		if(Uverse.page.isUserLoggedIn()) { this.setupEntitlement(); }
	}

	/** Overridable */
	, setupEntitlement: function() {
		var tile = this.el;
		this.tileHelper.applyEntitlement(tile, this.entitlementHelper);

		this.entitlementMessageBase = tile.get(this.ENTITLEMENT_DATA_ATTR_NAME_UPGRADE_MESSAGE);
	}

	/** Protected */
	, setupDrawer: function() {
		var drawerCallbacks = {
			closeDrawer: this._closeCurrentDrawer.bind(this)
		};
		this.drawer = new Uverse.widgets.Tile.Drawer(this.el.getElement('.drawer'), drawerCallbacks);
	}

	/** Protected */
	, setupRecording: function() {
		this.recording = new Uverse.widgets.Tile.Drawer.RecordingItem(
			this.el.getElement('.dvr')
			, {
				normalizedProgramTitle: this.el.get('data-program-title')
				, normalizedEpisodeTitle: this.el.get('data-episode-title')
				, isCategory: (this.getTileType() == 'Category' ? true : false)
				, type: this.el.get('data-content-type')
			}
			, {
				onIconClicked: this._onIconClicked.bind(this, {
					requires: {
						login: true
						, uverse: true
						, entitlement: true
					}
				})
				, onShowLoading: this.drawer.showLoading.bind(this.drawer)
				, onHideLoading: this.drawer.hideLoading.bind(this.drawer)
				, onShowMessage: this.drawer.showMessage.bind(this.drawer)
			}
		);
		this.pendingOperationsCancelFunctions['recording'] = this.recording.cancelOperations.bind(this.recording);
	}

	/** Protected */
	, setupFavorite: function() {
		var favoriteIcon = this.el.getElement('.favorite');
		if(favoriteIcon) {
			this.favorite = new Uverse.widgets.Tile.Drawer.FavoriteItem(
				this.el.getElement('.favorite')
				, {
					favoriteID: this.el.get('data-favorite-id')
					, favoriteType: this.getTileType()
				}
				, {
					onIconClicked: this._onIconClicked.bind(
						this,
						{
							requires: {
								login: true
								, uverse: false
								, entitlement: false
							}
						}
					)
					, onShowLoading: this.drawer.showLoading.bind(this.drawer)
					, onHideLoading: this.drawer.hideLoading.bind(this.drawer)
					, showGenericOverlay: this._showGenericOverlayForFavorites.bind(this)
					, hideGenericOverlay: this._hideGenericOverlayForFavorites.bind(this)
				}
			);
		}
	}
	, _showGenericOverlayForFavorites: function(overlayContents, overlayOptions) {
		overlayOptions = overlayOptions || {};
		var tile = this.el;
		this.tileEvents.fireEvent('FavoriteRemovePrompt', [ tile, overlayOptions ]);
		this.drawer.showGenericOverlay(overlayContents, overlayOptions);
	}
	, _hideGenericOverlayForFavorites: function(overlayOptions) {
		var tile = this.el;
		this.tileEvents.fireEvent('FavoriteRemoveSubmit', [ tile, overlayOptions ]);
		this.drawer.hideGenericOverlay();
	}

	/** Protected */
	, setupNotification: function() {
		var notifyIcon = this.el.getElement('.notify');
		if(notifyIcon) {
			this.notification = new Uverse.widgets.Tile.Drawer.NotificationItem(
				notifyIcon
				, {
					categoryPath: this.el.get('data-category-path')
				}
				, {
					onIconClicked: this._onIconClicked.bind(this, {
						requires: {
							login: true
							, uverse: false
							, entitlement: false
						}
					})
					, onShowLoading: this.drawer.showLoading.bind(this.drawer)
					, onHideLoading: this.drawer.hideLoading.bind(this.drawer)
					, onShowMessage: this.drawer.showMessage.bind(this.drawer)
				}
			);
		}
	}

	/** Protected, overridable */
	, getTileType: function() {
		Uverse.console.error("[Tile]", "getTileType has not been overridden for this tile.");
		return null;
	}

	, _closeCurrentDrawer: function() {
		Uverse.console.log("[Tile]", "Closing the drawer");
		this.currentDrawerItem.updateClickTrackingLabel(this.CLICK_TRACKING_ICON_STATES.CLOSE);
		this.currentDrawerItem.setSelected(false);

		this.drawer.hideDrawer(this.currentDrawerItem.name);
		this.drawer.hideLoading();
		this.drawer.hideGenericOverlay();
		this.drawer.hideMessage();
	}

	, _onIconClicked: function(options, drawerReadyCallback, drawerItem, isOneClick) {
		if(this.drawer.isOpen() || options === null) {
			if(drawerItem == this.currentDrawerItem) {
				this._closeCurrentDrawer();
			} else {
				Uverse.console.log("[Tile]", "Swapping the drawer");
				this.currentDrawerItem.updateClickTrackingLabel(this.CLICK_TRACKING_ICON_STATES.CLOSE);
				this.currentDrawerItem.setSelected(false);

				this.currentDrawerItem = drawerItem;
				this.currentDrawerItem.setSelected(true);
				this.currentDrawerItem.updateClickTrackingLabel(this.CLICK_TRACKING_ICON_STATES.OPEN);
				this._openDrawerWithContent(options, drawerReadyCallback, this.currentDrawerItem);
			}
		} else if (isOneClick) {
			Uverse.console.log("[Tile]", "Drawer staying closed due to OneClick");
		} else {
			Uverse.console.log("[Tile]", "Opening the drawer");
			this.currentDrawerItem && this.currentDrawerItem.setSelected(false);

			this.currentDrawerItem = drawerItem;
			this.currentDrawerItem.setSelected(true);
			this.currentDrawerItem.updateClickTrackingLabel(this.CLICK_TRACKING_ICON_STATES.OPEN);
			this._openDrawerWithContent(options, drawerReadyCallback, this.currentDrawerItem);
		}
	}

	, _openDrawerWithContent: function(options, drawerReadyCallback, drawerItem) {
		this._cancelPendingOperations(drawerItem.name);

		if (options.requires.login && !Uverse.page.isUserLoggedIn()) {
			this.drawer.showDrawer(this._getHeaderElement(drawerItem.name, 'signIn'), this.entitlementHelper.promptUserForLogin(drawerItem.name));
		} else if (options.requires.uverse && !Uverse.page.isUverseUser()) {
			this.drawer.showDrawer(this._getHeaderElement(drawerItem.name, 'signIn'), this.entitlementHelper.promptUserForOrder(drawerItem.name, this.entitlementMessageBase));
		} else if (options.requires.entitlement && this.tileHelper.getEntitlementStateViaClassName(this.el, this.entitlementHelper.NEED_UPGRADE)) {
			this.drawer.showDrawer(this._getHeaderElement(drawerItem.name, 'signIn'), this.entitlementHelper.promptUserForUpgrade(drawerItem.name, this.entitlementMessageBase));
		} else {
			drawerReadyCallback(this._getHeaderElement(drawerItem.name), this.drawer.showDrawer.bind(this.drawer));
		}

	}

	, _cancelPendingOperations: function(exception) {
		this.pendingOperationsCancelFunctions.each(function(cancelFunction, key) {
			if(key !== exception) { cancelFunction(); }
		});
	}

	, _getHeaderElement: function(itemName, classItemName) {
		var header = $('tileDrawerHeadersTemplate').getElement('.drawer-header').clone();
		header.addClass(Uverse.config.drawer.headers[classItemName || itemName].classname);
		header.appendText(Uverse.config.drawer.headers[itemName].text, 'top');
		return header;
	}

	/** Protected */
	, setupPlayLinks: function() {
		var videoPlayLinks = this.tileHelper.setupVideoPlayLinks(this.el);

		// ToDo: delegate this event:
		videoPlayLinks.addEvent('click:button(left)', this._onPlayLinkClick.bindAndPassThis(this));
	}
	, _onPlayLinkClick: function(videoPlayLink, ev) {
		ev.preventDefault();
		this.tileHelper.loadVideoPlayLink(this.el, videoPlayLink);
	}

});

/**
 * Behavior for interval tiles.
 */
Uverse.widgets.Tile.Interval = new Class({
	Extends: Uverse.widgets.Tile
	, el: null
	, itemEls: null
	, pagintaionEls: null
	, tileName: 'Interval'

	, currentItemIndex: 0
	, lastItemIndex: null
	, playing: false
	, tracked: null

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		if (!(this.itemEls && this.pagintaionEls)) {
			return false;
		}
		this.parent(el, options, tileEvents);

		// Initialize Interval
		this.el
			.addEvent('mousemove', this._stop.bind(this))
			.addEvent('mouseleave', this._start.bind(this));


		// Initialize Interval Items
		this.itemEls.each(function(el, i) {
			if (i == 0) {
				el.setStyle('z-index', 2);
				el.setStyle('visibility', 'visible');
			} else {
				el.setStyle('z-index', 1);
				el.setStyle('visibility', 'hidden');
			}
			var eventEls = el.getElements('.event');
			eventEls.each(function(eel, ii) {
				eel.addEvent('click', this._trackClickThrough.bind(this));
			}, this);
		}, this);

		this.tracked = new Hash();

		// Initialize Interval Pagination
		this.pagintaionEls.each(function(item, i) {
			item.store('itemIndex', i);
			item.addEvent('click', this._onClickNavigationItem.bind(this));
		}, this);

		// Initialize Tweens
		this.itemTweens = new Array();
		for (var i = 0, iM = this.itemEls.length; i < iM; i++) {
			this.itemTweens[i] = new Fx.Tween(this.itemEls[i], this.options.itemFx);
		}

		/* TODO: Add GA Impressions and Click Throughs*/

		// Preload Images
		this._preloadAssets();


	}

	/** Overrides base */
	, setupEntitlement: function() {
		this.itemEls.each(function(item) {
			this.tileHelper.applyEntitlement(item, this.entitlementHelper);
			this.entitlementMessageBase = item.get(this.ENTITLEMENT_DATA_ATTR_NAME_UPGRADE_MESSAGE);
		}, this);
	}

	, _preloadAssets: function(){
		var srcs = [];
		this.itemEls.each(function(item){
			srcs.push(item.getElement('img').get('src'));
		});

		// start a timeout in case images fail
		this.assetsTimeout = this._onAssetsTimeout.delay(20000, this);
		this.assets = Asset.images(srcs, {
			onComplete: function(){
				Uverse.console.log("[Tile]", "[" + this.tileName + " Tile]", "Assets Preloaded");
				this._onAssetsLoaded();
			}.bind(this)
		});
	}

	, _onAssetsTimeout: function(){
		Uverse.console.log("[Tile]", "[" + this.tileName + " Tile]", "Assets Timed Out");
		this._onAssetsLoaded();
	}

	, _onAssetsLoaded: function(){
		clearTimeout(this.assetsTimeout);
		this._start();
		this._trackImpression();
	}

	, _onClickNavigationItem: function(e) {
		var el = $(e.target);
		var index = el.retrieve('itemIndex');
		this._change(index);
	}

	, _start: function() {
		if (this.playing) {
			return;
		}
		Uverse.console.log("[Tile]", "[" + this.tileName + " Tile]", "Started Playing");
		this.periodical = this._next.periodical(this.options.interval, this);
		this.playing = true;
	}

	, _stop: function() {
		if (!this.playing) {
			return;
		}
		Uverse.console.log("[Tile]", "[" + this.tileName + " Tile]", "Stopped Playing");
		clearInterval(this.periodical);
		this.playing = false;
	}

	, _next: function () {
		this._change(this.currentItemIndex+1);
	}

	, _change: function (to) {

		// Wrap index
		if (to >= this.itemEls.length) {
			to = 0;
		}

		// Check if change event fired for current item
		if (this.currentItemIndex == to) {
			return;
		}

		// Check for invalid index
		if (to == undefined) {
			throw 'Invalid item index specified';
		}

		var current = this.currentItemIndex;

		// Reset last index
		if (this.lastItemIndex != undefined) {
			this.itemTweens[this.lastItemIndex].cancel();
			this.itemTweens[this.lastItemIndex].set(0);
			this.itemEls[this.lastItemIndex].setStyle('z-index', 1);
			this.itemEls[this.lastItemIndex].setStyle('visibility', 'hidden');
		}

		// setup the items
		this.itemEls[current].setStyle('z-index', 2);
		this.itemEls[to].setStyle('z-index', 1);
		this.itemEls[current].removeClass('active');
		this.pagintaionEls[current].removeClass('active');
		this.pagintaionEls[to].addClass('active');

		// animate the change
		this.itemEls[to].setStyle('visibility', 'visible');
		this.itemTweens[to].set(1);
		this.itemTweens[current].start(1, 0).chain(
			function() {
				this.itemEls[current].setStyle('z-index', 0);
			}.bind(this)
		);

		// save the state
		this.lastItemIndex = current;
		this.currentItemIndex = to;
		this._trackImpression();
	}

	,_trackImpression: function(){
		var key = 'impression_' + this.currentItemIndex;
		if (!this.tracked.has(key)) {
			var cat = this.itemEls[this.currentItemIndex].get('data-eventtrack-category');
			var act = this.itemEls[this.currentItemIndex].get('data-eventtrack-action');
			var lbl = this.itemEls[this.currentItemIndex].get('data-eventtrack-label');
			if (cat && act && lbl) {
				Uverse.page.googleAnalyticsPush('_trackEvent', [ cat, act + " Impression", lbl ]);
				Uverse.console.log("[Tile]", "[" + this.tileName + " Tile]", "Tracked Impression");
			}
			this.tracked.set(key, cat + " | " + act + " | " + lbl );
		}
	}

	,_trackClickThrough: function(e){
		var key = 'click' + this.currentItemIndex;
		if (!this.tracked.has(key)) {
			var target=e.target;
			var item=target.getParent('.eventTrack');
			if(item){
				var cat = item.get('data-eventtrack-category');
				var act = item.get('data-eventtrack-action');
				var lbl = item.get('data-eventtrack-label');
				if (cat && act && lbl) {
					Uverse.page.googleAnalyticsPush('_trackEvent', [ cat, act + " Click-Through", lbl ]);
					Uverse.console.log("[Tile]", "[" + this.tileName + " Tile]", "Tracked Clicktrough");
				}
			}
		}
	}
});

/**
 * Behavior for category tiles.
 */
Uverse.widgets.Tile.Category = new Class({
	/* Extends, Implements */
	Extends: Uverse.widgets.Tile

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		this.parent(el, options, tileEvents);

		this.setupDrawer();
		this.setupRecording();
		this.setupFavorite();
		this.setupNotification();

		this.setupPlayLinks();
	}

	/** Overrides base */
	, getTileType: function() {
		return 'Category'
	}
});

/**
 * Behavior for video tiles.
 */
Uverse.widgets.Tile.Video = new Class({
	Extends: Uverse.widgets.Tile

	, initialize: function(el, options, tileEvents) {
		this.parent(el, options, tileEvents);

		this.setupDrawer();
		this.setupRecording();
		this.setupFavorite();
		this.setupNotification();

		this.setupPlayLinks();
	}

	/** Overrides base */
	, getTileType: function() {
		return 'Video';
	}


});

/**
 * Behavior for minitron tiles.
 */
Uverse.widgets.Tile.Minitron = new Class({
	Extends: Uverse.widgets.Tile.Interval

	, options: {
		interval: 5000,
		enableRotation: true,
		itemFx: {
			property: 'opacity',
			duration: 1000,
			transition: Fx.Transitions.Quad.easeOut,
			link: 'cancel'
		}
	}
	, el: null
	, itemEls: null
	, pagintaionEls: null
	, tileName: 'Minitron'

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		this.itemEls = el.getElements('.minitronItem');
		this.pagintaionEls = el.getElements('.paginationItem');
		this.parent(el, options, tileEvents);
		this.setupPlayLinks();
	}

});


/**
 * Behavior for network tiles.
 */
Uverse.widgets.Tile.Network = new Class({
	Extends: Uverse.widgets.Tile.Interval

	, options: {
		interval: 5000,
		enableRotation: true,
		itemFx: {
			property: 'opacity',
			duration: 1000,
			transition: Fx.Transitions.Quad.easeOut,
			link: 'cancel'
		}
	}
	, el: null
	, itemEls: null
	, pagintaionEls: null
	, tileName: 'Network'

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		this.itemEls = el.getElements('.networkTileItem');
		this.pagintaionEls = el.getElements('.paginationItem');
		this.parent(el, options, tileEvents);
	}

});

/**
 * Behavior for promo tiles.
 */
Uverse.widgets.Tile.Promo = new Class({
	/* Extends, Implements */
	Extends: Uverse.widgets.Tile

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		this.parent(el, options, tileEvents);
	}
});

/**
 * Behavior for message tiles.
 */
Uverse.widgets.Tile.Message = new Class({
	/* Extends, Implements */
	Extends: Uverse.widgets.Tile

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		this.parent(el, options, tileEvents);
	}
});

/**
 * Behavior for static page tiles.
 */
Uverse.widgets.Tile.StaticPage = new Class({
	/* Extends, Implements */
	Extends: Uverse.widgets.Tile

	/* Constructor */
	, initialize: function(el, options, tileEvents) {
		this.parent(el, options, tileEvents);
	}
});/**
 * Class description
 */
Uverse.widgets.Tile.Drawer = new Class({
	Implements: [Callbacks]
	, callbacks: {
		closeDrawer: null
	}
	, el: null
	, overlays: {
		loading: null
		, message: null
		, generic: null
	}
	, fx: {
		cssSelector: 'transitions-tile-drawer-open'
	}

	/* Constructor */
	, initialize: function(el, callbacks) {
		this.el = $(el);
		this.setCallbacks(callbacks);
		this._setupOverlays();
		this._setupTransitions();
	}

	, _setupOverlays: function() {
		this.overlays.loading = new Uverse.utils.TileDrawerOverlayLoading(this.el);
		this.overlays.message = new Uverse.utils.TileDrawerOverlayMessage(this.el);
		this.overlays.generic = new Uverse.utils.TileDrawerOverlayGeneric(this.el);
	}

	, _setupTransitions: function() {
		this.el.set('morph');
	}

	/* Public methods */

	/**
	 * Returns true if the slider is currently open
	 */
	, isOpen: function() {
		return this.el.hasClass(this.fx.cssSelector);
	}

	/**
	 * Closes the slider
	 */
	, hideDrawer: function(iconName) {
		this.el.removeClassWithTransition(this.fx.cssSelector);
		this.el.get('morph').chain(this._onHideTransitionComplete.bind(this));
	}

	, _onHideTransitionComplete: function() {
		this.el.empty();
		var tile = this.el.getParent('.tile');
		if (tile) tile.removeClass('drawer-is-open');
	}

	/**
	 * Opens the slider
	 */
	, showDrawer: function(headElement, contents, options) {
		if(headElement) {
			headElement.inject(contents, 'top');
		}

		if(contents) {
			this._replaceContents(this._createEmptyContentElement().adopt(contents), options);
		}

		this._closeDrawer();
		this.el.addClassWithTransition(this.fx.cssSelector);
		var tile = this.el.getParent('.tile');
		if (tile) tile.addClass('drawer-is-open');
	}

	, _replaceContents: function(newContent, options) {
		var oldContent = this.el.getElement('.drawer-content');

		newContent.inject(this.el, 'top');

		this._transitionElements(newContent, oldContent, options);
	}

	, _isMarkedForTransition: function(oldContent, options) {
		return (oldContent
			&& (!options || (options.isAsync === false))
			&& !(Browser.ie8)
			) ? true : false;
	}

	, _transitionElements: function(newContent, oldContent, options) {
		if (newContent === oldContent) {
			newContent.setStyles({ 'position': null }).fade('show');
		} else if(this._isMarkedForTransition(oldContent, options)) {

			var tweenOpts = { link: 'cancel' };

			newContent.setStyles({ 'position': null }).set('tween', tweenOpts);
			newContent.fade('hide').fade('in');

			oldContent.setStyles({ 'position': 'absolute' ,'top': 0 }).set('tween', tweenOpts);
			oldContent.fade('show').fade('out').get('tween').chain(function(){ oldContent.destroy(); });

		} else if(oldContent) {
			oldContent.destroy();
		}

	}

	, _createEmptyContentElement: function() {
		return (new Element('div', { 'class': 'drawer-content' }));
	}

	, showLoading: function(overlayOptions) {
		this._openDrawerIfClosed();
		this.overlays.loading.showLoadingOverlay(overlayOptions);
	}

	, hideLoading: function() {
		this._closeDrawer();
		this.overlays.loading.hideLoadingOverlay();
	}

	, showMessage: function(message, overlayOptions) {
		if(this.isOpen()) {
			this.overlays.message.showMessageOverlay(message, overlayOptions);
		}
	}

	, hideMessage: function() {
		this.overlays.message.hideOverlay();
	}

	, showGenericOverlay: function(overlayContents, overlayOptions) {
		this.overlays.generic.showGenericOverlay(overlayContents, overlayOptions);
	}
	, hideGenericOverlay: function() {
		this.overlays.generic.hideOverlay();
	}

	, _openDrawerIfClosed: function() {
		if(!this.isOpen()) { this.showDrawer(); }
	}

	, _closeDrawer: function() {
		var close = this.el.getElement('.drawer-close');
		if (close) {
			close.addEvent('click', this._onDrawerCloseClick.bind(this));
		}
	}

	, _onDrawerCloseClick: function(ev) {
		ev.stopPropagation();
		Uverse.page.clickTrack(ev.target, { addAction: "Drawer Close" });

		this.callbacks.closeDrawer();
	}
});Uverse.widgets.Tile.Drawer.BaseItem = new Class({
	Implements: [ Options, Callbacks ]

	, icon: null
	, name: null
	, callbacks: {
		onIconClicked: null
		, onShowLoading: null
		, onHideLoading: null
		, onShowMessage: false
	}

	, initialize: function(icon, options, callbacks) {
		this.icon = icon;
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	, updateClickTrackingLabel: function(value) {
		Uverse.page.updateClickTrackAttribute(this.icon, Uverse.page.getConstant('clickTracking', 'attributeMap.names.label'), value);
	}

	, setSelected: function(isSelected) {
		this.icon.toggleClass('selected', isSelected);
	}
});Uverse.widgets.Tile.Drawer.FavoriteItem = new Class({
	Extends: Uverse.widgets.Tile.Drawer.BaseItem
	
	, favoriteIcon: null
	, drawerFavoriteSaver: null
	, name: 'favorite'

	, callbacks: {
		showGenericOverlay: null
		,hideGenericOverlay: null
	}

	, initialize: function(icon, options, callbacks) {
		this.parent(icon, options, callbacks);

		this.favoriteIcon = new Uverse.widgets.FavoriteIcon(
				icon
				, this.options.favoriteID
				, { 
					onClick: this._onFavoriteClicked.bind(this)
					, onOneClick: this._onFavoriteOneClick.bind(this)
					, onStateChange: this._onStateChange.bind(this) 
				}
		);
		this.state = this.favoriteIcon.getState();
		this.drawerFavoriteSaver = new Uverse.widgets.FavoriteSaver(
			this.options.favoriteID
			, this.options.favoriteType
    		, {
	        	showLoading: this.callbacks.onShowLoading.bind(this)
	        	, hideLoading: this.callbacks.onHideLoading.bind(this)
				, closeDrawer: this._onFavoriteClicked.bind(this)
				, showGenericOverlay: this.callbacks.showGenericOverlay
				, hideGenericOverlay: this.callbacks.hideGenericOverlay
	        });
	}

	, _onStateChange: function(state) {
		this.state = state;
	}

	, _onFavoriteClicked: function(ev) {
		this.callbacks.onIconClicked(this._onDrawerReady.bind(this), this);
	}
	, _onFavoriteOneClick: function() {
		this.drawerFavoriteSaver.addToFavorites();
		var isOneClick = true;
		this.callbacks.onIconClicked(this._onDrawerReady.bind(this), this, isOneClick);
	}
	
	, _onDrawerReady: function(headerElement, showDrawerCallback) {
		Uverse.console.log("[Tile.Drawer.FavoriteItem]", "Creating Favorites UI");
		showDrawerCallback(headerElement, this.drawerFavoriteSaver.getUI(this.state));
	}


});
Uverse.widgets.Tile.Drawer.NotificationItem = new Class({
	Extends: Uverse.widgets.Tile.Drawer.BaseItem
	
	, NotificationIcon: null
	, drawerNotificationCreator: null
	, name: 'notification'
	
	, initialize: function(icon, options, callbacks) {
		this.parent(icon, options, callbacks);
		
		this.notificationIcon = new Uverse.widgets.NotificationIcon(
				icon
				, this.options.categoryPath
				, { 
					onClick: this._onNotificationClicked.bind(this)
					, onStateChange: this._onStateChange.bind(this) 
				}
		);
		this.state = this.notificationIcon.getState();
		
		this.drawerNotificationCreator = new Uverse.widgets.NotificationCreator(
			this.options.categoryPath
    		, {
	        	showLoading: this.callbacks.onShowLoading.bind(this)
	        	, hideLoading: this.callbacks.onHideLoading.bind(this)
	        	, showMessage: this.callbacks.onShowMessage.bind(this)
	        });
	}

	, _onStateChange: function(state) {
		this.state = state;
	}

	, _onNotificationClicked: function(ev) {
		this.callbacks.onIconClicked(this._onDrawerReady.bind(this), this);
	}
	
	, _onDrawerReady: function(headElement, showDrawerCallback) {
		showDrawerCallback(headElement, this.drawerNotificationCreator.getUI(this.state));
	}
	
});
Uverse.widgets.Tile.Drawer.RecordingItem = new Class({
	Extends: Uverse.widgets.Tile.Drawer.BaseItem

	, recordingIcon: null
	, name: 'recording'
	, drawerRecorder: null
	, state: null
	, epgInfoObject: null
	, epgInfoData: null
	, options: {
		normalizedProgramTitle: ''
		, normalizedEpisodeTitle: ''
		, isCategory: false
		, type: null
	}
	
	, initialize: function(icon, options, callbacks) {
		this.parent(icon, options, callbacks);
		
		this.recordingIcon = new Uverse.widgets.RecordingIcon(
				icon
				, { 
					onClick: this._recordingClicked.bind(this)
					, onStateChange: this._onStateChange.bind(this) 
				}
				, this.options.normalizedProgramTitle
				, this.options.type
		);
        
        this.drawerRecorder = new Uverse.widgets.Recorder(
    		this.options.type
    		, {
	        	showLoading: this.callbacks.onShowLoading.bind(this)
	        	, hideLoading: this.callbacks.onHideLoading.bind(this)
	        	, showMessage: this.callbacks.onShowMessage.bind(this)
	        	, recordSuccess: this._onRecordSuccess.bind(this)
	        }
    	);
	}
	
	, _onStateChange: function(state) {
		this.state = state;
	}

	, _recordingClicked: function(ev) {
		this.callbacks.onIconClicked(this._onDrawerReady.bind(this), this);
	}
	
	, _onDrawerReady: function(headElement, showDrawerCallback) {
		if(!this.epgInfoData) {
			this.callbacks.onShowLoading();
			this._requestEpgInfo(headElement, showDrawerCallback, {
				isAsync: true
			});
		} else {
			showDrawerCallback(headElement, this.drawerRecorder.getUI(this.state, this.epgInfoData));
		}
	}
	
	, _requestEpgInfo: function(headElement, drawerOpenCallback, options) {
		this.epgInfoObject = new Uverse.utils.EpgInfo(
			{
				normalizedProgramTitle: this.options.normalizedProgramTitle
				, normalizedEpisodeTitle: this.options.normalizedEpisodeTitle
			}, {
				onEpgInfoRecieved: this._onEpgInfoRecieved.bind(this, headElement, drawerOpenCallback, options)
				, onEpgInfoFailed: this._onEpgInfoFailed.bind(this, headElement, drawerOpenCallback)
			}
		);
	}
		
	, _onEpgInfoRecieved: function(headElement, drawerOpenCallback, epgInfoData, options) {
		Uverse.page.addMemoryEvent('Dvr-dvrItems:once', this._processEpgInfo.bind(this, headElement, drawerOpenCallback, epgInfoData, options));
		Uverse.page.addMemoryEvent('Dvr-dvrItemsFailure:once', this._onEpgInfoFailed.bind(this, headElement, drawerOpenCallback));
	}

	, _onEpgInfoFailed: function (headElement, drawerOpenCallback) {
		drawerOpenCallback(headElement, this.drawerRecorder.getErrorStateUI());
	}
	
	, _processEpgInfo: function(headElement, drawerOpenCallback, options, epgInfoData) {
		if(this.state === Uverse.page.dvr.itemStates.UNKNOWN) {
			if(epgInfoData.canBeRecorded) {
				this.recordingIcon.setState(Uverse.page.dvr.itemStates.CAN_BE_RECORDED);
			} else if(!epgInfoData.canBeRecorded && epgInfoData.hasUpcomingEpisode) {
				this.recordingIcon.setState(Uverse.page.dvr.itemStates.CANNOT_BE_RECORDED_LOCAL);
			} else {
				this.recordingIcon.setState(Uverse.page.dvr.itemStates.CANNOT_BE_RECORDED);
			}
		}
		this.epgInfoData = epgInfoData;
		this.callbacks.onHideLoading();
		drawerOpenCallback(headElement, this.drawerRecorder.getUI(this.state, epgInfoData), options);
	}
	
	, _onRecordSuccess: function(epgInfoData) {
		Uverse.page.addDvrItem(epgInfoData);
	}
	
	, cancelOperations: function() {
		if(this.epgInfoObject) {
			this.epgInfoObject.cancelRequest();
		}
	}
});Uverse.widgets.TileExtensions = new Class({
	Implements: [ Callbacks ]

	, callbacks: {
		removeTile: null
	}
	, tileEvents: null

	, initialize: function(callbacks, tileEvents) {
		this.setCallbacks(callbacks);
		this.tileEvents = tileEvents;
	}
});

Uverse.widgets.TileExtensions.FavoriteTileRemover = new Class({
	Extends: Uverse.widgets.TileExtensions

	, transitions: {
		tileFade: { elements: { '.tileWrapper' : { props: ['opacity'] } } }
	}

	, initialize: function(callbacks, tileEvents) {
		this.parent(callbacks, tileEvents);
		this.tileEvents.addEvents({
			'FavoriteRemovePrompt': this._onFavoriteRemovePrompt.bind(this)
			,'FavoriteRemoveSubmit': this._onFavoriteRemoveSubmit.bind(this)
		});
	}

	, _onFavoriteRemovePrompt: function(tile, overlayOptions) {
		overlayOptions.detachOverlayFromTile = true;
		tile.addClassWithTransition('about-to-remove', this.transitions.tileFade);
	}
	, _onFavoriteRemoveSubmit: function(tile, overlayOptions) {
		if (overlayOptions.confirmationResult === true) {
			overlayOptions.preventDrawerFromCollapsing = true;

			tile.addClassWithTransition('removed', this.transitions.tileFade);
			tile.getElement('.tileWrapper').get('morph').chain(function(){
				this.callbacks.removeTile(tile);
			}.bind(this));
		} else {
			tile.removeClassWithTransition('about-to-remove', this.transitions.tileFade);
		}
	}
});/**
 * Tile Layout
 * Manages tiles and a series of columns, and 
 * distributes tiles evenly among the columns.
 */
Uverse.widgets.TileLayout = new Class({
	/* Extends, Implements */
	Implements: [
		Options
		,Callbacks
	]
	, Binds: ['_onPageWidthChanged']

	/* Instance members */
	, options: {}
	, callbacks: {
		/**
		 * Fires when new columns are created or removed.
		 * @param columns
		 */
		'columnsChanged': false
	}

	, spacerTemplate: null
	, columnContainer: null
	, columnTemplate: null

	, tiles: []

	/* Constructor */
	, initialize: function (columnContainer, options, callbacks) {
		this.columnContainer = $(columnContainer);
		this.setOptions(options);
		this.setCallbacks(callbacks);

		this._setupElements();
	}

	, _setupElements: function() {
		// Grab the column template that will be cloned, and remove it from the DOM:
		this.columnTemplate = this.columnContainer.getElement('.columnTemplate');
		this.columnTemplate.dispose().removeClass('columnTemplate');

		this.spacerTemplate = new Element('div', { 'class': 'spacer' });
		
		// spot-check
		Uverse.console.assert(this.columnContainer && this.columnTemplate, "Missing argument!");
	}
	
	/**
	 * Adds the tiles into the Fluid Layout.
	 * The tiles will automatically be inserted into the
	 * fluid columns.
	 */
	, addTiles: function (newTiles) {
		this.tiles.append(newTiles);
		var columns = this.columnContainer.getChildren('.column');
		this._insertTilesIntoColumns(newTiles, columns);
	}

	/**
	 * Removes the set of tiles, and reflows them into place.
	 */
	, reshuffleTiles: function(tiles) {
		this.tiles.exclude(tiles);
		tiles.each(function(tile){
			tile.dispose(); // Remove from DOM
		});

		this.addTiles(tiles);
	}
	, destroyTile: function(tile) {
		this.tiles.erase(tile);
	}

	, destroyLayout: function() {

	}
	
	/**
	 * Flows the tiles into the columns.
	 */
	, _insertTilesIntoColumns: function (newTiles, columns) {

		var columnHeights = columns.map(function (c) { return c.getHeight(); });

		for (var i = 0; i < newTiles.length; i++) {
			var tile = newTiles[i];

			// Determine which column:
			var columnSpan = this._getColumnSpan(tile);
			var columnIndex = this._determineNextColumnIndex(columnHeights, columnSpan);
			var column = columns[columnIndex];

			// Move the tile to the column:
			column.grab(tile);

			// Measure:
			var tileHeight = tile.getHeight();
			columnHeights[columnIndex] += tileHeight;

			// Add spacers if there's extra columns:
			for (var c = 1; c < columnSpan; c++) {
				var spacer = tile.retrieve('tile-spacer');
				if (!spacer) {
					spacer = this._createSpacer(tileHeight);
					tile.store('tile-spacer', spacer);
				}
				var nextColumn = columns[columnIndex + c];
				nextColumn.grab(spacer);
				columnHeights[columnIndex + c] += tileHeight;
			}

		}
	}



	, setColumns: function (newColumnCount, oldColumnCount) {

        // Add or remove our columns:
		var columns = this.columnContainer.getChildren('.column');
        while (columns.length < newColumnCount) {
            // Add new column:
            var column = this.columnTemplate.clone();
            this.columnContainer.grab(column);
            columns.push(column);
        }
        while (columns.length > newColumnCount) {
            // Remove column:
	        columns.pop().dispose();
        }

		if (this.callbacks['columnsChanged'])
			this.callbacks['columnsChanged'](columns);

        // Figure out how to re-layout the tiles:
        // Clear the tiles from all columns:
        columns.each(function(column){
            column.empty();
        });
        this._insertTilesIntoColumns(this.tiles, columns);
	}


	, _determineNextColumnIndex: function(columnHeights, columnSpan) {
		// find the "shortest" column:
        return columnHeights.minIndex(0, columnHeights.length - (columnSpan - 1), 1);
	}
	, _getColumnSpan: function (tile) {
		return tile.hasClass('three-column') ? 3 : tile.hasClass('two-column') ? 2 : 1;
	}
	, _createSpacer: function (tileHeight) {
		var spacer = this.spacerTemplate.clone().setStyle('height', tileHeight);
		return spacer;
	}

});

/**
 * Tile Loader
 * Fetches tiles via AJAX
 * and fires events when complete.
 */
Uverse.widgets.TileLoader = new Class({
	/* Extends, Implements */
	Implements: [
		Options
		, Callbacks
	]
	, Binds: ['_onRequestSuccess', '_onRequestFailure']

	/* Instance members */
	
	, options: {
		tilesUrl: '/tiles.html'
		, pathKey: 'path'
		, siteAreaKey: 'siteArea'
		, tileIndexKey: 'startTile'

		, siteArea: null // ie: '/uv'

		/**
		 * To disable auto-retry, set this to -1.
		 */
		, errorRetryInterval: 2000
		, connectionErrorStatusCodes: [
			0 // Unknown error (probably connection)
			,502 // Unreachable
			,503 // Unavailable
			,504 // Timeout
		]
	}
	, callbacks: {
		/**
		 * Fires when a tiles request starts, or a retry request starts.
		 */
		'tilesLoading': null
		/**
		 * Fires when new tiles are available
		 * @param {Elements} newTiles The newly retrieved tiles
		 */
		, 'tilesLoaded': null
		/**
		 * Fires when all new tiles are processed.
		 * @param {Number} tileCount
		 */
		, 'tilesLoadedDone': null
		/**
		 * Fires when an error occurs requesting tiles.
		 * A retry will happen automatically.
		 * @param {Request} request The request object that contains the error information.
		 */
		, 'tilesLoadingError': null
		/**
		 * Fires when all tiles for the section have finished loading
		 * (ie. the end of the page)
		 */
		, 'tilesFinished': null

		/**
		 * Fires when the filter changes, and the current tiles need to be reset.
		 */
		, 'tilesResetting': null

		/**
		 * Fires when a new tiles group should be created.
		 * @param {Element} tileGroupHeader The header for the new tile group.
		 */
		, 'newTileGroup': null
	}

	, request: null
	, retrying: false
	, retryCount: 0

	, filter: null
	, currentTileGroupKey: null

	, tileIndex: 0
	
	/* Constructor */
	, initialize: function (options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
		
		this._setupRequest();
	}
	, _setupRequest: function(){
		this.request = new Request({
			url: this.options.tilesUrl
			, method: 'get'
			, onSuccess: this._onRequestSuccess
			, onFailure: this._onRequestFailure
		});
	}

	/**
	 * Sets the filter, and starts retrieving the results.
	 */
	, updateFilter: function(filter) {
		Uverse.console.log("[TileLoader]", "Filter has been updated:", filter);

		// Deep-compare the filters (using toQueryString as a shortcut)
		var filterChanged = (Object.toQueryString(this.filter) !== Object.toQueryString(filter));
		if (filterChanged) {
			this.filter = filter;

			this._resetTileLoader();

			this.startOver();
		}
	}
	, _resetTileLoader: function() {
		if (this.isBusy()) {
			this.cancelRequest();
		}

		this.callbacks['tilesResetting']();


	}
	, startOver: function() {
		this.tileIndex = 0;
		this.currentTileGroupKey = null;

		this.getMoreTiles();
	}

	/**
	 * Sets the initial set of tiles, and fires the "tilesLoaded" callback.
	 * The TileLoader might need these tiles in the future for caching purposes.
	 * @param {Elements} initialTilesId The container holding the initial tiles
	 * @param {Object} [filter] An optional filter that describes the tiles. This could be used as a cache key.
	 */
	, setInitialTiles: function(initialTilesId, initialFilter) {
		var newElements = $(initialTilesId).getChildren();
		this.filter = String.parseQueryString(initialFilter);
		this._processNewElements(newElements);
	}

	/**
	 * Loads the next set of tiles asynchronously.
	 */
	, getMoreTiles: function () {
		if (this.isBusy()){
			Uverse.console.warn("[TileLoader]", "You should never try to get more tiles when a request is in progress.");
			return;
		}

		Uverse.console.log("[TileLoader]", "Getting more tiles (tile #", this.tileIndex, ", filter:", this.filter, ")");
		this._sendTilesRequest();
	}
	, _sendTilesRequest: function() {
		var data = {};
		data[this.options.pathKey] = Uverse.config.requestPath;
		data[this.options.siteAreaKey] = this.options.siteArea;
		data[this.options.tileIndexKey] = this.tileIndex;
		Object.merge(data, this.filter);

		this.request.send({ data: data });

		this.callbacks['tilesLoading']();
	}
	
	/**
	 * Returns the current status of the Tile Loader.
	 * @return {Boolean}
	 */
	, isBusy: function () {
		return this.request.isRunning() || this.retrying;
	}

	/**
	 * Cancels the currently running request.
	 */
	, cancelRequest: function() {
		this.request.cancel();
	}

	, _onRequestSuccess: function (html) {
		var result = Elements.from(html).filter('#initial-tiles')[0];
		if (!result) {
			Uverse.console.assert(result, "[TileLoader]", "Parsed the HTML, but could not find the tiles container!");
			this._onRequestFailure('noTiles');
			return;
		}

		var newElements = result.getChildren();

		var tilesFinished = result.hasClass('end-of-tiles');

		var noTiles = (newElements.length == 0);

		if (noTiles) {
			// Normally, noTiles should be an error,
			// and we should receive 'end-of-tiles' on the last page.
			// However, for now, we only receive 'end-of-tiles'
			// AFTER the last page.
			if (tilesFinished) {
				this._tilesFinished();
				return;
			}
			Uverse.console.error("[TileLoader]", "No tiles found in the response!");
			this._onRequestFailure('noTiles');
			return;
		}

		Uverse.console.log("[TileLoader]", "Tiles Loaded");

		this.retryCount = 0;

		this._processNewElements(newElements);

		if (tilesFinished) {
			this._tilesFinished();
		}
	}
	, _processNewElements: function(newElements) {
		// Process the tiles, looking for tile-group-headers:
		var tileCount = 0;
		var newTiles = [];
		newElements.each(function(tile){
			if (tile.hasClass('tile-group-header')) {
				var tileGroupKey = tile.get('text');
				var isNewGroup = (this.currentTileGroupKey !== tileGroupKey);
				if (isNewGroup) {
					this.currentTileGroupKey = tileGroupKey;
					if (newTiles.length) {
						this.callbacks['tilesLoaded'](newTiles);
					}
					this.callbacks['newTileGroup'](tile);
					newTiles = [];
				}
			} else if (tile.hasClass('tile')){
				tileCount++;
				newTiles.push(tile);
			} else {
				Uverse.console.error("[TileLoader]", "Unrecognized element found in response: ", tile);
			}
		}, this);

		this.tileIndex += tileCount;

		if (newTiles.length) {
			this.callbacks['tilesLoaded'](newTiles);
		}
		this.callbacks['tilesLoadedDone'](tileCount);
	}

	, _onRequestFailure: function (xhr) {
		Uverse.console.error("[TileLoader]", "Tiles loading error!");

		var shouldRetry = true;
		if (this.options.errorRetryInterval === -1
			|| xhr === 'noTiles'
			|| !this.options.connectionErrorStatusCodes.contains(xhr.status) ){
			shouldRetry = false;
		}

		// Retry:
		if (shouldRetry) {
			this.retryCount++;
			Uverse.console.warn("[TileLoader]", "Retrying (", this.retryCount, ")");
			var growingInterval = (this.options.errorRetryInterval * Math.min(10, this.retryCount));
			this.retrying = (function(){
				this.retrying = false;
				this._sendTilesRequest();
			}).delay(growingInterval, this);
		}

		this.callbacks['tilesLoadingError'](this.request);
	}

	, _tilesFinished: function() {
		Uverse.console.log("[TileLoader]", "Tiles have finished loading");
		this.callbacks['tilesFinished']();
	}

	, destroyTile: function(tile) {
		this.tileIndex--;
	}

});/**
* Behavior for panel of tiles that supports infinite scrolling, events, etc.
*/
Uverse.widgets.TileManager = new Class({
	Implements: [ Options ]
	, Binds: [
		'_onPageWidthChanging', '_onPageWidthChanged'
		, '_onTilesLoaded', '_onTilesLoading', '_onTilesLoadedDone', '_onTilesLoadingError', '_onTilesFinished', '_onTilesResetting', '_onNewTileGroup'
		, '_onFilterChanged'
		, '_onLayoutColumnsChanged'
		, '_onEndOfContainerReached'
	]
	
	, options: {
		initialTilesId: '' // {String} Element holding the initial tiles
		, tileLoaderOptions: null // {Object} Passed along to TileLoader
		, filterBarId: null // {Object} Passed along to FilterBar
		, ellipsifyOptions: {
			truncateTo: 'word'
			, cloneOriginal: true
			, ellipsis: new Element('span.ellipsis').set('text', '...')
		}
		, tileExtensions: null
	}

	, infiniteScroll: null
	, tileLayout: null
	, tileLayouts: []
	, tileController: null
	, tileLoader: null
	, filterBar: null
	, spinner: null
	, spinnerReloading: null

	, tileSection: null
	, tileGroups: null
	, tileGroupTemplate: null
	, tileGroup: null
	, allTiles: []
	, tilesResetting: false
	, disclaimerContainer: null


	, initialize: function(el, options) {
		this.tileSection = $(el);
		this.disclaimerContainer = $("mainDisclaimer");
		this.setOptions(options);

		this.tileGroups = this.tileSection.getElement('.tile-groups');
		this.tileGroupTemplate = this.tileSection.getElement('.tile-group').dispose().clone();

		this._setupTileEvents();
		this._setupTileExtensions();
		this._setupTileController();
		this._setupInfiniteScroll();
		this._setupTileLoader();
		this._setupFilterBar();
		this._setupSpinner();
		this._setupHero();

		this._setupEvents();

		this._initialized();
	}
	, _setupEvents: function() {
		Uverse.page.addMemoryEvent('PageWidth_columnsChanging', this._onPageWidthChanging);
		Uverse.page.addMemoryEvent('PageWidth_columnsChanged', this._onPageWidthChanged);
	}
	, _onPageWidthChanging: function (newColumnCount, oldColumnCount, newPageWidth) {
		this._storeScrollPosition('pct');
	}
	, _onPageWidthChanged: function (newColumnCount, oldColumnCount, newPageWidth) {
		this.tileLayouts.each(function(tileLayout){
			tileLayout.setColumns(newColumnCount, oldColumnCount);
		});
		if (oldColumnCount !== 0) {
			this._restoreScrollPosition('pct');
		}
	}

	, _setupTileController: function(){
		this.tileController = new Uverse.widgets.TileManager.Controller(this.tileSection, this.tileEvents);
	}

	, _setupTileEvents: function() {
		this.tileEvents = new Events();
	}
	, _tileStateChanged: function(tile, stateName, stateValue) {
		Uverse.console.log("[TileManager]", "Tile State Changed:", stateName, stateValue);
		if (this.tileExtensions) {
			this.tileExtensions.each(function(tileExtension) {
				tileExtension.tileStateChanged(tile, stateName, stateValue);
			});
		}
	}

	, _setupTileExtensions: function() {
		this.tileExtensions = [];
		var tileExtensions = this.options.tileExtensions;
		if (tileExtensions) {
			var tileExtensionCallbacks = {
				removeTile: this._removeTile.bind(this)
			};
			tileExtensions.each(function(tileExtensionName) {
				var tileExtensionConstructor = Uverse.widgets.TileExtensions[tileExtensionName];
				if (!tileExtensionConstructor) {
					Uverse.console.error("[TileManager]", "Could not find the following tileExtension: ", tileExtensionName);
				} else {
					var tileExtension = new tileExtensionConstructor(tileExtensionCallbacks, this.tileEvents);
					this.tileExtensions.push(tileExtension);
					Uverse.console.log("[TileManager]", "Loaded tileExtension: ", tileExtensionName);
				}
			}, this);
		}
	}
	, _removeTile: function(tile) {
		Uverse.console.log("[TileManager]", "Removing the Tile");

		// Destroy the tile:
		var tileIndex = this._destroyTile(tile);

		if (this.allTiles.length === 0) {
			// No more tiles!
			// Let's try to request the first page,
			// which should return a "no tiles" message:
			this.tileLoader.startOver();
		} else {
			// Reshuffle:
			var tilesToReshuffle = this.allTiles.slice(tileIndex);
			this.tileLayout.reshuffleTiles(tilesToReshuffle);
		}

		// Decrement the tile-section-total-count:
		var tileSectionTotalCount = this.tileSection.getElement('.tile-section-total-count'); //.set('text', this.allTiles.length);
		if (tileSectionTotalCount) {
			var totalCount = tileSectionTotalCount.get('text').toInt();
			totalCount--;
			tileSectionTotalCount.set('text', totalCount);
		}

	}


	, _newTileLayout: function() {
		if (this.tileLayout) {
			// Clean up the old one before creating a new one:
			var clearCallbacks = {
				'columnsChanged': false
			};
			this.tileLayout.setCallbacks(clearCallbacks);
		}


		var tileLayoutOptions = {};
		var tileLayoutCallbacks = {
			'columnsChanged': this._onLayoutColumnsChanged
		};
		var newTileLayout = new Uverse.widgets.TileLayout(this.tileGroup, tileLayoutOptions, tileLayoutCallbacks);
		this.tileLayout = newTileLayout;
		this.tileLayouts.push(newTileLayout);

		Uverse.page.addMemoryEvent('PageWidth_columnsChanged:once', function(newColumnCount, oldColumnCount, newPageWidth){
			newTileLayout.setColumns(newColumnCount, oldColumnCount);
		});
	}
	, _onLayoutColumnsChanged: function(columns) {
		this.infiniteScroll.updateColumns(columns);
	}

	, _storeScrollPosition: function (method) {
		var scrollParent = this.tileSection.getScrollParent();
		if (method == 'pct') {
			// Store the top position before we move things around!
			this.scrollPct = scrollParent.getScrollTop() / scrollParent.getScrollHeight();
		} else if (method == 'top') {
			this.scrollTop = scrollParent.getScrollTop();
		}
	}
	, _restoreScrollPosition: function (method) {
		var scrollParent = this.tileSection.getScrollParent();
		var newScrollTop;
		if (method == 'pct') {
			// Restore the scroll position:
			var scrollHeight = scrollParent.getScrollHeight();
			newScrollTop = this.scrollPct * scrollHeight;
		} else if (method == 'top') {
			newScrollTop = this.scrollTop;
		}
		scrollParent.scrollTo(0, newScrollTop);
	}


	, _setupInfiniteScroll: function() {
		var scrollOptions = {};
		var callbacks = {
			'endOfContainerReached': this._onEndOfContainerReached
		};
		this.infiniteScroll = new Uverse.widgets.InfiniteScroll(this.tileSection, scrollOptions, callbacks);
	}
	, _onEndOfContainerReached: function() {
		if (!this.tileLoader.isBusy()) {
			this.tileLoader.getMoreTiles();
		}
	}

	, _setupTileLoader: function() {
		var tileLoaderOptions = this.options.tileLoaderOptions;
		var tileLoaderCallbacks = {
			'tilesLoaded': this._onTilesLoaded
		  , 'tilesLoadedDone': this._onTilesLoadedDone
		  , 'tilesLoading': this._onTilesLoading
		  , 'tilesLoadingError': this._onTilesLoadingError
		  , 'tilesFinished': this._onTilesFinished
		  , 'tilesResetting': this._onTilesResetting
		  , 'newTileGroup': this._onNewTileGroup
		};
		this.tileLoader = new Uverse.widgets.TileLoader(tileLoaderOptions, tileLoaderCallbacks);
	}
	, _onTilesLoading: function() {
		this._updateSpinner('loading');
	}
	, _onTilesLoaded: function(newTiles) {
		Uverse.console.group("[TileManager]", "Loading tiles");
		Uverse.console.time("[TileManager] Total ");

		Uverse.console.time("[TileManager] Adding tiles took ");

		this._prepareUI();
		this._checkForTileGroup();

		this._addTiles(newTiles);

		Uverse.console.timeEnd("[TileManager] Adding tiles took ");

		Uverse.console.time("[TileManager] Ellipsifying elements took ");

		var ellipsify = new Uverse.utils.Ellipsify(this.options.ellipsifyOptions);
		newTiles.each(function(tile) {
			tile.getElements('.description').each( function(desc) {
				ellipsify.ellipsifyElement(desc);
			});
		});

		Uverse.console.timeEnd("[TileManager] Ellipsifying elements took ");

		Uverse.console.timeEnd("[TileManager] Total ");
		Uverse.console.groupEnd();
	}
	, _onTilesLoadedDone: function(tileCount) {
		this._updateSpinner('loaded');
		this._tilesAdded(tileCount);
	}
	, _onTilesLoadingError: function(request) {
		// The tile loader will auto-retry.
		// Todo: We might want to show an error message
		if (this.tilesResetting) {
			this.tilesResetting = false;

			this._clearTiles();

			this.tileGroups.removeClassWithTransition('transition-tile-groups-reloading');
		}

		this._updateSpinner('ERROR');
	}
	, _onTilesFinished: function() {
		this.infiniteScroll.disable();
		this._updateSpinner('finished');
		if (this.disclaimerContainer) {
			this.disclaimerContainer.removeClass('hidden');
		}
	}

	, _onTilesResetting: function() {
		// Begin the "reset" animation:

		this.tileGroups.addClassWithTransition('transition-tile-groups-reloading');
		this._updateSpinner('reloading');
		if (this.disclaimerContainer) {
			this.disclaimerContainer.addClass('hidden');
		}

		this.tilesResetting = true;
	}
	, _onNewTileGroup: function(tileGroupHeader) {
		this._prepareUI();
		this.tileGroups.grab(tileGroupHeader);
		this.tileGroup = null;
	}
	, _checkForTileGroup: function() {
		if (this.tileGroup)
			return;

		this.tileGroup = this.tileGroupTemplate.clone();

		this.tileGroups.grab(this.tileGroup);

		this._newTileLayout();
	}
	, _prepareUI: function() {
		if (this.tilesResetting) {
			this.tilesResetting = false;
			this._clearTiles();
			this.tileGroups.removeClassWithTransition('transition-tile-groups-reloading');
		}
	}



	, _setupFilterBar: function() {
		var filterBarId = this.options.filterBarId;
		if (!filterBarId) {
			// There's no filter bar needed.
			return;
		}
		var options = {};
		var callbacks = {
			'filterChanged': this._onFilterChanged
		};
		this.filterBar = new Uverse.widgets.FilterBar(filterBarId, options, callbacks);
	}
	, _onFilterChanged: function(filter) {
		Uverse.console.log("[TileManager]", "New filter selected: ", Object.toQueryString(filter));

		this.tileLoader.updateFilter(filter);
	}

	, _setupSpinner: function() {
		this.spinner = this.tileSection.getElement(".tiles-loading-container");
		this.spinnerReloading = this.tileSection.getElement(".tiles-reloading-container");
		this._updateSpinner('done');
	}
	, _updateSpinner: function(whichSpinner) {
		switch (whichSpinner) {
			case 'ERROR':
				this.spinner.addClass('hidden');
				this.spinnerReloading.addClass('hidden');
				break;
			case 'reloading':
				this.spinner.addClass('hidden');
				this.spinnerReloading.removeClass('hidden');
				break;
			case 'loading':
				if (!this.tilesResetting)
					this.spinner.removeClass('hidden');
				break;
			case 'loaded':
			case 'finished':
				this.spinner.addClass('hidden');
				this.spinnerReloading.addClass('hidden');
				break;
		}
	}

	, _initialized: function() {
		if (this.options.initialTilesId) {
			// Delegate the tiles along to the tileLoader,
			// just in case it decides to cache them or something.
			this.tileLoader.setInitialTiles(this.options.initialTilesId, this.options.initialFilter);
		}

		if (this.filterBar) {
			this.filterBar.checkInitialFilter();
		}
	}


	, _addTiles: function(newTiles){
		this.allTiles.append(newTiles);

		this.tileController.addTiles(newTiles);
		this.tileLayout.addTiles(newTiles);
	}
	, _tilesAdded: function(tileCount) {
		this.infiniteScroll.tilesAdded();
	}

	, _destroyTile: function(tile) {
		this.tileController.destroyTiles([tile]);

		this.tileLoader.destroyTile(tile);
		this.tileLayout.destroyTile(tile);

		var tileIndex = this.allTiles.indexOf(tile);
		this.allTiles.splice(tileIndex, 1);

		tile.dispose();

		return tileIndex;
	}

	, _clearTiles: function () {

		// Reset the widgets:
		this.tileLayout = null;
		this.tileLayouts.each(function(tileLayout){
			tileLayout.destroyLayout();
		}, this);
		this.tileLayouts.empty();

		this.tileController.destroyTiles(this.allTiles);

		this.infiniteScroll.enable();

		// Clear the tiles:
		this.tileGroup = null;
		this.tileGroups.empty();

		this.allTiles.empty();
	}
	
	, _setupHero: function() {
		this.heroContainer = this.tileSection.getElement('.hero');
		if (this.heroContainer) {
			var hero = new Uverse.widgets.HeroManager(this.heroContainer);
		}
	}
	
});

/**
* Main controller that creates the individual tiles.
*/
Uverse.widgets.TileManager.Controller = new Class({
	  el: null
	, controllers: {}
	
	, initialize: function(el, tileEvents) {
	    this.el = $(el);
		this.tileEvents = tileEvents;
	}
	
	, addTiles: function(newTiles) {
	    newTiles.each(function(tile) {
			var tileType = tile.get('data-tile-class');
	        var controller = this._fetchOrCreateTileController(tileType);
	        controller.addTile(tile);
	    }, this);
	}

	, _fetchOrCreateTileController: function(name) {
	    if(!this.controllers[name]) {
			var ctor = Uverse.widgets.TileManager.Controller[name];
	        this.controllers[name] = new ctor(this.tileEvents);
	    }
	
	    return this.controllers[name];
	}

	, destroyTiles: function(allTiles) {
		Object.each(this.controllers, function(controller) {
			if (controller.destroyTiles)
				controller.destroyTiles(allTiles);
		});
	}
});
    
/**
* Main controller that creates the individual tiles.
*/
Uverse.widgets.TileManager.Controller.BaseController = new Class({
	/* Instance members */
	tileCollection: []

	, initialize: function(tileEvents) {
		this.tileEvents = tileEvents;
	}
	
	/** Public */
	, addTile: function(tile) {
	    var tileObj = this.createTileWidget(tile);
	    this.tileCollection.push(tileObj);
	}
	
	/** Must Override */
	, createTileWidget: function(tile) {}
});

/**
* Main controller for category tiles.
*/
Uverse.widgets.TileManager.Controller.Category = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController

	, initialize: function(tileEvents) {
	    this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
		return new Uverse.widgets.Tile.Category(tile, null, this.tileEvents);
	}
});

/**
* Main controller for video tiles.
*/
Uverse.widgets.TileManager.Controller.Video = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController
	
	, initialize: function(tileEvents) {
		this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
		return new Uverse.widgets.Tile.Video(tile, null, this.tileEvents);
	}
});

/**
* Main controller for minitron tiles.
*/
Uverse.widgets.TileManager.Controller.Minitron = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController
	
	/* Constructor */
	, initialize: function(tileEvents) {
	    this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
	    return new Uverse.widgets.Tile.Minitron(tile, null, this.tileEvents);
	}
});


/**
* Main controller for promo tiles.
*/
Uverse.widgets.TileManager.Controller.Promo = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController
	
	/* Constructor */
	, initialize: function(tileEvents) {
	    this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
		return new Uverse.widgets.Tile.Promo(tile, null, this.tileEvents);
	}
});

/**
* Main controller for network tiles.
*/
Uverse.widgets.TileManager.Controller.Network = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController
	
	/* Constructor */
	, initialize: function(tileEvents) {
	    this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
		return new Uverse.widgets.Tile.Network(tile, null, this.tileEvents);
	}
});

/**
* Main controller for message and error tiles.
*/
Uverse.widgets.TileManager.Controller.Message = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController
	
	/* Constructor */
	, initialize: function(tileEvents) {
	    this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
		return new Uverse.widgets.Tile.Message(tile, null, this.tileEvents);
	}
});

/**
* Main controller for static page tiles.
*/
Uverse.widgets.TileManager.Controller.StaticPage = new Class({
	Extends: Uverse.widgets.TileManager.Controller.BaseController
	
	/* Constructor */
	, initialize: function(tileEvents) {
	    this.parent(tileEvents);
	}

	/** Overrides base */
	, createTileWidget: function(tile) {
		return new Uverse.widgets.Tile.StaticPage(tile, null, this.tileEvents);
	}
});
/**
* Behavior for panel of tiles that supports infinite scrolling, events, etc.
*/
Uverse.widgets.TileManagerPVP = new Class({
	Implements: [ Options, Uverse.utils.Loadable ]

	, options: { }

	, tileController: null
	, allTiles: []

	, initialize: function(el, options) {
		this.tileSection = $(el);
		this.setOptions(options);

		this._setupTileController();

		this._initialized();
	}

	, _setupTileController: function(){
		this.tileController = new Uverse.widgets.TileManager.Controller(this.tileSection);
	}


	, _initialized: function() {
		var initialTiles = this.tileSection.getChildren('.tile');
		initialTiles = Array.from(initialTiles);
		this._addTiles(initialTiles);
	}

	, _addTiles: function(newTiles){
		// tilesAdding:

		// addTiles:
		this.allTiles.append(newTiles);
		this.tileController.addTiles(newTiles);

		// tilesChanged:
	}

	, _clearTiles: function () {

		// Reset the widgets:

		this.tileController.destroyTiles(this.allTiles);

		// Clear the tiles:
		this.allTiles.empty();
	}

	/** Overrides Loadable */
	, destroy: function() {
		this._clearTiles();
	}
	
});

Uverse.widgets.LogInLinks = new Class({
	Implements: [ Options ]
	, el: null
	, hiddenClassName: 'hidden'
	, loggedInLinkSelector: '.current-user-gretting'
	, currentUserGreetingSelector: '.current-user-name'
	, logoutLinkSelector: '.logout-link'
	, loginLinkSelector: '.login-link'

	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);

		Uverse.page.addMemoryEvent('Personalization-userData',
			this._onUserData.bind(this));
	}
	, _onUserData: function(userData) {
		this._refresh(userData);
	}
	, _refresh: function(userData) {
		var greeting
			 , logoutLink
			 , loginLink
			 , userNameElement;


		if(userData.isLoggedIn()) {
			greeting = this.el.getElement(this.loggedInLinkSelector);
			userNameElement = greeting.getElement(this.currentUserGreetingSelector);
			logoutLink = this.el.getElement(this.logoutLinkSelector);

			// Add the user name
			userNameElement.set('text', userData.username);
			// Show the greeting and show the logout link
			greeting.removeClass(this.hiddenClassName);
			logoutLink.removeClass(this.hiddenClassName);
		} else {
			// Get the login link and show it.
			loginLink = this.el.getElement(this.loginLinkSelector);
			loginLink.removeClass(this.hiddenClassName);
		}
	}
});/*jshint laxcomma:true*/
/*global Uverse:true $:true Options:true Class:true */
Uverse.widgets.FixedHeader = new Class({
	Implements: [ Options ]
	, el: null
	, sectionsNavigationSelector: '.sections-navigation'
	, detachedClassName: 'detached'
	, _sectionsNavigation: null
	, _scrollParent: null
	, _onScrollHandler: function() {
		// If the scroll value is greater than the sectionsNavigation offset top
		// we should fix it. The reason to use > instead of === is that browsers
		// won't trigger this for every scrolled pixel.
		if(this._scrollParent.getScroll().y > this._sectionsNavigation.offsetTop) {
			// Before setting the class name, we should check if we haven't already
			// done that.
			if(!this.el.hasClass(this._detachedClassName))
				this.el.addClass(this.detachedClassName);
		} else {
			// If we are in a static safe zone, we can go ahead and return everything
			// to the normal state.
			this.el.removeClass(this.detachedClassName);
		}
	}
	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);
		// It seems that getScrollParent won't work in the old site because it uses
		// `DOMEvent` which happens to only be available in MooTools 1.4.5. If it
		// is not available, we'll catch the error and output to console.
		try {
			// Select the sections navigation...
			this._sectionsNavigation = this.el
				.getElement(this.sectionsNavigationSelector);
			this._scrollParent = this.el.getScrollParent();
			this._scrollParent.addEvent('scroll', this._onScrollHandler.bind(this));
		} catch(e) {
			Uverse.console.error('[FixedHeader]', 'getScrollParent is not defined for the old site.');
		}
	}
});/**
* Behavior for hero header section of tile sections.
*/
Uverse.widgets.HeroManager = new Class({
	Implements: [ Options ]
	, Binds: [ '_onHoverClose' ]
	, options: {
		moreEllipsifyOptions: {
			truncateTo: 'word'
			, cloneOriginal: false
			, ellipsis: (new Element('span.ellipsis').set('text', '... ')).grab(new Element('a').set({'class':'moreLink', 'href':'#', 'text': 'MORE>'}))
		}
		, heroFx: {
			property: 'opacity',
			duration: 1000,
			transition: Fx.Transitions.Quad.easeOut,
			link: 'cancel'
		}
		, interval: 5000
		, enableRotation: true
		, animateMore: (Browser.ie8 ? false : true)
	}
	, heroEl: null
	, descriptionHover: null
	, herosPlaying: false
	, currentHeroIndex: 0
	, lastHeroIndex: null
	
	, initialize: function(el, options) {
		this.heroEl = $(el);
		this.setOptions(options);

		this._setupDataBlock();
		this._initImageFader();
	}
	
	, _setupDataBlock: function () {
		var moreEllipsify = new Uverse.utils.Ellipsify(this.options.moreEllipsifyOptions);
		var description = this.heroEl.getElement('p.ellipsis.multiLine.more');
		if (description) {
			if (moreEllipsify.ellipsifyElement(description)) {
				description.addEvent('click', this._onMoreClicked.bind(this));

				this.descriptionHover = this.heroEl.getElement('.header-description-hover');
				this.descriptionHover.getElement('.header-description-hover-close').addEvent('click', this._onHoverClose);
			}
		}
	}
	, _onMoreClicked: function(ev) {
		ev.preventDefault();
		if (this.options.animateMore) {
			this.descriptionHover.fade('hide').removeClass('hidden').fade('in');
		} else {
			this.descriptionHover.removeClass('hidden');
		}
		if (!this.descriptionHoverScroll) {
			var description = this.descriptionHover.getElement('.description');
			var scrollBarOptions = {
				addClass: 'header-description-hover-scrollbar'
				, direction: 'vertical'
			};
			this.descriptionHoverScroll = Uverse.controls.ScrollBar.attachScrollBarTo(description, scrollBarOptions);
		}
		document.addEvent('keydown:keys(esc)', this._onHoverClose);
	}
	, _onHoverClose: function(ev) {
		ev.preventDefault();
		document.removeEvent('keydown:keys(esc)', this._onHoverClose);

		if (this.options.animateMore) {
			this.descriptionHover.fade('show').fade('out');
		} else {
			this.descriptionHover.addClass('hidden');
		}
	}
	
	,_initImageFader: function() {
		this.heroImages = this.heroEl.getElements(".heroImage");
		if (this.heroImages && this.heroImages.length > 1) {
			this.heroImages.each(function(el, i) {
				if (i == 0) {
					el.setStyle('z-index', 2);
					el.setStyle('visibility', 'visible');
				} else {
					el.setStyle('z-index', 1);
					el.setStyle('visibility', 'hidden');	
				}
			}, this);
			this.heroTweens = new Array();
			for (var i = 0, iM = this.heroImages.length; i < iM; i++) {
				this.heroTweens[i] = new Fx.Tween(this.heroImages[i], this.options.heroFx);
			}
			this._preloadHeroImages();
		}
	}
	
	, _preloadHeroImages: function(){
		var srcs = [];
		this.heroImages.each(function(item){
			srcs.push(item.get('src'));
		});
		
		this.heroTimeout = this._onHerosTimeout.delay(20000, this);
		this.heros = new Asset.images(srcs, {
			onComplete: function(){
				this._onHerosLoaded();
			}.bind(this)
		});
	}
	
	, _onHerosTimeout: function(){
		this._onHerosLoaded();
	}
	
	, _onHerosLoaded: function(){
		clearTimeout(this.heroTimeout);
		this._startHeros();
	}
	
	, _startHeros: function() {
		if (this.herosPlaying) { return; }
		this.heroPeriodical = this._nextHero.periodical(this.options.interval, this);
		this.playing = true;
	}
	
	, _nextHero: function () {
		this._changeHero(this.currentHeroIndex+1);
	}
	
	, _changeHero: function (to) {
		if (to >= this.heroImages.length) {to = 0;}
		if (this.currentHeroIndex == to) {return;}
		if (to == undefined) {throw 'Invalid item index specified';}
		var current = this.currentHeroIndex;
		if (this.lastHeroIndex != undefined) {
			this.heroTweens[this.lastHeroIndex].cancel();
			this.heroTweens[this.lastHeroIndex].set(0);
			this.heroImages[this.lastHeroIndex].setStyle('z-index', 1);
			this.heroImages[this.lastHeroIndex].setStyle('visibility', 'hidden');
		}
		this.heroImages[current].setStyle('z-index', 2);
		this.heroImages[to].setStyle('z-index', 1);
		this.heroImages[current].removeClass('active');
		this.heroImages[to].setStyle('visibility', 'visible');
		this.heroTweens[to].set(1);
		this.heroTweens[current].start(1, 0).chain(
			function() {
				this.heroImages[current].setStyle('z-index', 0);
			}.bind(this)
		);
		this.lastHeroIndex = current;
		this.currentHeroIndex = to;
	}
});Uverse.players.Player = new Class({
	Implements : [Options, Events]
	, scriptLoaded: false
	, options : {
		swfWidth : 880
		, swfHeight : 495
		, large : false
		, playerConfig: null
	}

	, AD_CLASS_LARGE : 'large'
	, AD_CLASS_SMALL : 'small'
	, playerSizes: {
		height: 496
		, smallWidth: 560
		, largeWidth: 880
	}
	
	, swfObject : null
	, videoPlaying : false
	, adPlaying : false
	, ready : false
	, contentStarted : false
	
	, initialize: function(el, options) {
		this.el = $(el);
		this.setOptions(options);

		if (this.options.large) this.el.addClass('large');
		
		this.swiffOptions = {
			width : this.options.swfWidth
			, height : this.options.swfHeight
			, vars : this.options.vars || {}
			, params : {allowFullscreen : true, bgColor : '#000000'}
			, callBacks: { onInit: this.onPlayerReady.bind(this) }
		};
		
		this.adComponent = this.options.companionAdEl;
	}
	
	, getEnvironmentConfigValue: function(key) {
		if(this.options.playerConfig) {
			return this.options.playerConfig[key];
		}
		return null;
	}
	
	, mergeEnvironmentConfigWithObject: function(obj) {
		Object.merge(obj, this.options.playerConfig);
	}
	
	, _addIDToCompanionAdEl: function() {
		if(this.companionAdID) { this.adComponent.set('id', this.companionAdID); }
	}
	
	/**
	 * builds the 
	 */
	, build: function(swfPath) {
		this.buildContainer();
		var assetsBuilt = false;
		
		if (this.options.swf) { 
			this.buildSwf(swfPath);
			assetsBuilt = true;
		}
		
		if (this.options.ignoreScript) {
			assetsBuilt = true;
		} else if (this.options.script) { 
			this.buildScript();
			assetsBuilt = true;
		}

		if(!assetsBuilt) { throw new Error('Invalid asset'); }

		this.updatePlayer('loading');
	}
	
	, buildContainer: function() {
		if(!this.container) {
			this.container = new Element('div', {id : this.options.containerId}).inject(this.el);
			this.swiffOptions.container = this.container;
		}
	}
	
	/**
	 * build the script object and injects into the head
	 */
	, buildScript: function() {
		this.onFlashLoading();
		Asset.javascript(this.options.script, {
			id : this.options.scriptId
			, onload : this.onScriptLoadedProtected.bind(this)
		});
	}
	
	/**
	 * builds and injects the SWF 
	 * 
	 * @param string swfPath path to the players directory
	 */
	, buildSwf: function(swfPath) {
		this.onFlashLoading();
		var swiff = new Swiff((swfPath + this.options.swf), this.swiffOptions);
		this.swfObject = document.id(swiff); //returns a handle on the <object> or <embed> to make Flash calls into
		this.onSwfObjectLoaded(this.swfObject);
	}
	/** Protected */
	, onFlashLoading: function() {
		// IE has an issue: when loading any SWF:
		// the window's title will be replaced with the page's current hash!
		// Here's our workaround:
		if (Browser.ie) {
			this.windowTitle = document.title;
		}
	}
	/** Protected */
	, onFlashLoaded: function() {
		if (Browser.ie && this.windowTitle) {
			document.title = this.windowTitle;
		}
	}
	
	, onFocus: function() {
		if (this.windowTitle) {
			document.title = this.windowTitle;
		}
	}
	
	, onSwfObjectLoaded: function(swfObject) {
		swfObject = swfObject || this.swfObject;
		if (Browser.ie) {
			swfObject.onfocus = this.onFocus.bind(this);
		}
	}

	/**
	 * Determine if the player is ready for playback
	 * @return {Boolean}
	 */
	, isPlayerReady: function() {
		return this.ready || false;
	}
	
	/**
	 * callback from player ready events from SWF players
	 */
	, onPlayerReady: function() {
		this.ready = true;
		this.fireEvent('ready');
		this.onFlashLoaded();
	}
	
	/**
	 * Determine if the content has actually started playing
	 */
	, hasContentStarted: function() {
		return this.contentStarted;
	}
	
	/**
	 * event handler for a player script loading completion
	 */
	, onScriptLoaded: function() {
		//implement in concrete classes
	}
	
	/**
	 * IE9 Hack to prevent double execution
	 */
	, onScriptLoadedProtected: function() {
		if (!this.scriptLoaded){
			this.scriptLoaded = true;
			this.onScriptLoaded();
		}
	}
	
	, onPlayerError: function(message) {
		Uverse.console.warn("[Player]", "PLayer had an error: ", message);
		this.fireEvent('playerError', message);
	}

	/** Protected
	 * Sets the ad's position to "absolute", so that it doesn't take up any space in the "smallAd" area.
	 */
	, setAdStyleNeverSmall: function() {
		this.adComponent.setStyle('position', 'absolute');
	}

	/** Must override
	 * @param {String} state - Can be 'loading', 'content', 'ad', or 'finished'.
	 */
	, updatePlayer: function(state) { }

	, largePlayer: function() {
		var embed = this.container.getElement('object,embed');
		if (embed) {
			var margin = ((this.container.getSize().x - this.playerSizes.largeWidth) / 2);
			var styles = {
				'margin-left' : margin
				, 'width' : this.playerSizes.largeWidth

			};
			if (Browser.ie8 || Browser.ie7) {
				// MooTools does not extend IE8's object/embed nodes,
				// so here's the best we can do:
				Object.each(styles, function (value, key) {
					Element.setStyle(embed, key, value);
				});
				this.onLargePlayerStart();
				this.onLargePlayerComplete();
			} else {
				Object.merge(styles, {
					'start': this.onLargePlayerStart.bind(this)
					, 'complete': this.onLargePlayerComplete.bind(this)
				});
				embed.set('morph', { transition: 'quint:in' }).morph(styles);
			}
		}

	}
	, smallPlayer: function() {
		var embed = this.container.getElement('object,embed');
		if (embed) {
			var styles = {
				'margin-left' : 0
				, 'width' : this.playerSizes.smallWidth
			};

			if (Browser.ie8 || Browser.ie7) {
				// MooTools does not extend IE8's object/embed nodes,
				// so here's the best we can do:
				Object.each(styles, function (value, key) {
					Element.setStyle(embed, key, value);
				});
				this.onSmallPlayerStart();
				this.onSmallPlayerComplete();
			} else {
				Object.merge(styles, {
					'start': this.onSmallPlayerStart.bind(this)
					, 'complete': this.onSmallPlayerComplete.bind(this)
				});
				embed.set('morph', { transition: 'quint:out' }).morph(styles);
			}
		}
	}

	, largeAd: function() {
		if (!this.adComponent.hasClass('large-ad')) {
			this.adComponent.fade('hide');
			
			this._setTopValueForAdComponent();
			this.adComponent.addClass('large-ad').removeClass('hidden');
			
			this.adComponent.set('tween', { transition: 'quint:in' }).fade('in');
		} else {
			this.adComponent.removeClass('hidden');
		}
	}
	
	, smallAd: function() {
		if (this.adComponent.hasClass('large-ad')) {
			this.adComponent.fade('hide');
			this.adComponent.removeClass('large-ad').setStyles({ 'top': null }).removeClass('hidden');
			this.adComponent.set('tween', { transition: 'quint:in' }).fade('in');
		} else {
			this.adComponent.removeClass('hidden');
		}
	}
	
	, noAd: function() {
		this.adComponent.addClass('hidden');
	}
	
	, _setTopValueForAdComponent: function() {
		this.adComponent.setStyle('top', 0);
		var adTop = this.el.getPosition().y - this.adComponent.getPosition().y;
		this.adComponent.setStyle('top', adTop);
	}
	
	, onLargePlayerStart: function() {}
	, onLargePlayerComplete: function() {}
	, onSmallPlayerStart: function() {}
	, onSmallPlayerComplete: function() {}

	// API
	
	/**
	 * Fires when content begins playing
	 */
	, onContentStart: function() {
		Uverse.console.log("[Player]", "Content Start");
		this.videoPlaying = true;
		this.contentStarted = true;	
		this.fireEvent('contentStart');
		this.updatePlayer('content');
	}
	
	/**
	 * Fires when content ends
	 */
	, onContentEnd: function() {
		Uverse.console.log("[Player]", "Content End");
		this.videoPlaying = false;
		this.fireEvent('contentEnd');
	}
	
	/**
	 * Fires when an ad begins playing
	 */
	, onAdStart: function() {
		Uverse.console.log("[Player]", "Ad Start");
		this.adPlaying = true;
		this.fireEvent('adStart');
		this.updatePlayer('ad');
	}
	
	/**
	 * Fires when an ad stops playing
	 */
	, onAdEnd: function() {
		Uverse.console.log("[Player]", "Ad End");
		this.adPlaying = false;
		this.fireEvent('adEnd');
		this.updatePlayer('content');
	}
	
	/**
	 * Fires when the content (or pre-roll ad) starts
	 */
	, onVideoStart: function() {
		Uverse.console.log("[Player]", "Video Start");
		this.fireEvent('videoStart');
	}
	
	/**
	 * Fires when all content has finished playing
	 */
	, onVideoEnd: function() {
		Uverse.console.log('[Player]', 'Video End');
		this.fireEvent('videoEnd');
		this.updatePlayer('finished');
	}
	
	/**
	 * Fires when the playstate changes.
	 * 
	 * Note: Not all players provide all possible states.
	 * 
	 * @param {String} state The playstate as a string - loading, buffering, playing, stopped, paused
	 */
	, onStateChange: function(state) {
		this.fireEvent('stateChange', state);
		switch (state) {
			case 'playing':
				this.videoPlaying = true;
				break;
			default:
				this.videoPlaying = false;
		}
	}
	
	/**
	 * Fires when the playback bitrate changes for a dynamic stream
	 */	
	, onBitrateChanged: function(currentBitrate, maximumBitrate) {
		this.fireEvent('bitrateChange', [currentBitrate, maximumBitrate]);
	}
	
	/**
	 * returns whether video is playing
	 * returns null if not supported
	 */
	, isVideoPlaying: function() {
		return this.videoPlaying;
	}
	
	/**
	 * returns the seek head position in seconds.
	 * Returns null if not supported.
	 */
	, getPosition: function() {
		return null;
	}
	
	/**
	 * Returns the total video duration or null if not supported.
	 */
	, getDuration: function() {
		return null;
	}
	
	/**
	 * Returns whether the player supports bitrate change events
	 */
	, supportsBitrateEvents: function() {
		return false;
	}

	/** Overridable */
	, destroyPlayer: function() {
		this._destroyScript();
		// specifically use innerHTML as workaround for ie bug
		this.el.innerHTML = '';
	}

	, _destroyScript: function() {
		var scriptTag = $(this.options.scriptId);
		if (scriptTag) {
			scriptTag.destroy();
		}
	}

	/**
	 * gets the play token from the player, defaults to null when not supported
	 */
	, getPlayToken: function() {
		return null;
	}
	
	/**
	 * gets the stream token from the player, defaults to null when not supported
	 */
	, getStreamToken: function() {
		return null;
	}


	// API to be implemented in subclasses
	, load: function() {}
	, replay: function() {}
	, pause: function() {}
	, resume: function() {}
	, seek: function(to) {}
	, stop: function() {}

});
Uverse.players.BigTen = new Class({
	Extends : Uverse.players.Player
	
	, playerContainerID: 'btn2goplayerdiv'
		
	, playerProps: {
		flashVars: {
			server: 'http://www.btn2go.com/btn2go/'
			, mvpd: 'att'
			, epgrange: '3'
			, bgcolor: '002B55'
			, fgcolor: '00b4ED'
		}

		, attributes: {
			id: this.playerContainerID
			, name: this.playerContainerID
			, align: 'middle'
		}
		
		, params: {
			quality: 'high'
			, bgcolor: '#000000'
			, allowScriptAccess: 'always'
			, allowFullScreen: 'true'
			, wmode: 'direct'
		}
	}

	, initialize: function(el, options) {
		window.iptvReadyCallback = this._iptvReadyCallback.bind(this);
		
		this.parent(el, Object.merge({
			script : 'http://e1.cdnl3.neulion.com/fox/player/btn2go/scripts/swfobject.js'
			, scriptId : 'BigTen'
			, containerId : this.playerContainerID
			, large : true
		}
		, options));
		
		this.mergeEnvironmentConfigWithObject(this.playerProps.flashVars);
		
		this._addIDToCompanionAdEl();
	}

	, onScriptLoaded: function() {
		swfobject.embedSWF(
			'http://e1.cdnl3.neulion.com/fox/player/btn2go/mvpd.swf'
			, this.playerContainerID
			, '100%'
			, '496'
			, '10.2.0'
			, 'http://e1.cdnl3.neulion.com/fox/player/btn2go/scripts/expressInstall.swf'
			, this.playerProps.flashVars
			, this.playerProps.params
			, this.playerProps.attributes
		);

	}

	, onContentStart: function() {
		this.parent();
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.noAd();
				break;
			case 'finished':
				break;
		}
	}

	, _iptvReadyCallback: function() {
		$(this.playerContainerID).playChannel();
		this.fireEvent('ready');
	}

	, _setupTokenHandler: function() {
		var callbacks = {
			tokenError: this.onPlayerError.bind(this)
			,tokenRetrieved: this._tokenRetrieved.bind(this)
		};
		this.tokenHandler = new Uverse.utils.TokenHandler(callbacks);
		this.tokenHandler.sendAuthenticationRequest(this.itemID);
	}

	, _tokenRetrieved: function(playToken, streamTokenText) {
		this.streamToken = streamTokenText;
		this.onContentStart();
	}



	// API:

	, load: function(key, itemId) {
		this.key = key;
		this.itemID = itemId;

		this._setupTokenHandler();
		this.onSwfObjectLoaded($(this.playerContainerID));
	}
	, getStreamToken: function() {
		return this.streamToken;
	}
});Uverse.players.Cbs = new Class({
	Extends : Uverse.players.Player
	
	, AD_IMAGE_DETECTION : {
		CLASSNAME : 'image'
		, SMALL_HEIGHT : 60
	}
	
	, CBS_ADINFO_ARRAY_INDEXES: {
		assetUrl: 0
		, clickThruURL: 1
		, adType: 2
		, impressionArray: 3
		, clipID: 4
	}
	
	, impressionContainerEl: null
	
	, initialize: function(el, options) {
		this.parent(el, Object.merge({
			swf : 'AttPlayer.swf'
			, swfWidth : 880
			, swfHeight : 495
			, containerId : 'cbsPlayer'
			, large : true
		}
		, options));
	}
	
	, onPlayerReady: function() {
		this.parent();
		
		//event listeners
		Uverse.config.players.callbacks.cbs[this.swfObject.id] = {
			adStart : this._onAdStart.bind(this)
			, adEnd : this._onAdEnd.bind(this)
			, videoStart : this.onVideoStart.bind(this)
			, videoEnd : this.onVideoEnd.bind(this)
			, contentStart : this.onContentStart.bind(this)
			, contentEnd : this.onContentEnd.bind(this)
			, stateChange : this.onStateChange.bind(this)
		};
		
		this.swfObject.addListener('videoStart', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.videoStart');
		this.swfObject.addListener('videoEnd', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.videoEnd');
		this.swfObject.addListener('adStart', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.adStart');
		this.swfObject.addListener('adEnd', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.adEnd');
		this.swfObject.addListener('contentStart', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.contentStart');
		this.swfObject.addListener('contentEnd', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.contentEnd');
		this.swfObject.addListener('stateChange', 'Uverse.config.players.callbacks.cbs.' + this.swfObject.id + '.stateChange');
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.smallAd();
				break;
			case 'finished':
				break;
		}
	}


	, _onAdStart: function(adInfo) {
		this._insertAdAndShowIfSmall(adInfo[0]);
		this._addImpressionImage(adInfo[0]);
		this.onAdStart();
	}
	
	, _onAdEnd: function(adInfo) {
		this._insertAdAndShowIfSmall(adInfo[0]);
		this._addImpressionImage(adInfo[0]);
		this.onAdEnd();
	}
	
	, _insertAdAndShowIfSmall: function(adInfo) {
		this._hideAd();
		
		var adImage = Asset.image(adInfo[this.CBS_ADINFO_ARRAY_INDEXES.assetUrl], {
			'class': this.AD_IMAGE_DETECTION.CLASSNAME
			,onLoad: function () {
				var link = new Element('a', {href : adInfo[this.CBS_ADINFO_ARRAY_INDEXES.clickThruURL]}).adopt(adImage);
				link.addEvent('click', this._onAdClicked);
				this.adComponent.empty().adopt(link);
				this._getAdHeightAndDisplayIfSmall();
			}.bind(this)
		});
	}
	
	, _hideAd: function() {
		this.adComponent.setStyle('visibility', 'hidden');
	}
	
	, _showAd: function() {
		this.adComponent.setStyle('visibility', 'visible');
	}
	
	, _onAdClicked: function(ev) {
		window.open(this.href);
		ev.stop();
	}
	
	, _getAdHeightAndDisplayIfSmall: function() {
		this._adHeightRetreived(this.adComponent.getElement('.' + this.AD_IMAGE_DETECTION.CLASSNAME).getSize().y.toInt());
	}
	
	, _adHeightRetreived: function(adHeight) {
		if(adHeight <= this.AD_IMAGE_DETECTION.SMALL_HEIGHT) { 
			this._showAd(); 
		}
	}
	
	, _addImpressionImage: function(adInfo) {
		this._clearImpressionContainerIfExists();
		
		if(adInfo[this.CBS_ADINFO_ARRAY_INDEXES.impressionArray]) {
			adInfo[this.CBS_ADINFO_ARRAY_INDEXES.impressionArray].each(function(impressionUrl) {
				this._createTrackingContainerIfDoesntExist();
				this._addTrackingUrlToPage(impressionUrl);
			}, this);
		}
	}
	
	, _clearImpressionContainerIfExists: function() {
		if(this.impressionContainerEl) { this.impressionContainerEl.empty(); }
	}
	
	, _createTrackingContainerIfDoesntExist: function() {
		if(!this.impressionContainerEl) {
			this.impressionContainerEl = new Element('span', { 'class': 'impressionTrackingContainer' });
			this.el.adopt(this.impressionContainerEl);
		} 
	}
	
	, _addTrackingUrlToPage: function(impressionUrl) {
		new Element('img', {
			src: impressionUrl
		}).inject(this.impressionContainerEl);
	}
	
	//API
	
	, load : function(key) { 
		this.key = key;
		this.swfObject.loadVideoById(key);
	}
	, replay : function() { this.swfObject.loadVideoById(this.key); }
	, pause : function() { this.swfObject.pauseVideo(); }
	, stop : function() { this.swfObject.loadVideoById(''); }
	, resume : function() { this.swfObject.resumeVideo(); }
	, isVideoPlaying : function() { return this.swfObject.isVideoPlaying(); }
	, getDuration : function() { return this.swfObject.getDuration(); }
	, getPosition : function() { return this.swfObject.getPosition(); }
	, seek : function(position) { 
		this.swfObject.pauseVideo(); // Prevents the video from continuing if seekTo gets delayed 
		this.swfObject.seekTo(position); 
	}
});
Uverse.players.Extend = new Class({
	Extends : Uverse.players.Player
	
	, options : {
		swf : 'AttExtendPlayer.swf'
		, swfWidth : 880
		, swfHeight : 496
		, large : false
		, vars: {
			remoteUrl: null
			, layoutStandard: null
			, playerLocation: null
			, videoKey: null
			, videoNetwork: null
		}
	}
	
	, videoStartFired : false
	, contentEndFired : false
	
	, initialize: function(el, options) {
		
		this.setOptions(options);
		
		//remove the final forward slash from the remoteUrl, if present
		if (this.options.vars.remoteUrl && (this.options.vars.remoteUrl.charAt(this.options.vars.remoteUrl.length - 1) == '/')) {
			this.options.vars.remoteUrl = this.options.vars.remoteUrl.substr(0, this.options.vars.remoteUrl.length - 1);
		}
		//add the layoutStandard var for the Extend player
		this.options.vars.layoutStandard = this.options.swfWidth + 'x' + this.options.swfHeight;
		
		/*
		this.options.vars.playerLocation = this.options.playerLocation;
		this.options.vars.videoKey = this.options.videoKey;
		this.options.vars.videoNetwork = this.options.videoNetwork;
		this.options.vars.additionalContentCategoryPath = this.options.additionalContentCategoryPath;
		*/
		
		this.parent(el, this.options);
	}
	
	, onPlayerReady: function() {
		this.parent();
		
		Uverse.config.players.callbacks.extend[this.swfObject.id] = {
			playlistEnd : this._onPlaylistEnd.bind(this)
			, stateChange : this._onStateChange.bind(this)
			, playlistItemStart : this._onPlaylistItemStart.bind(this)
			, playlistItemEnd : this._onPlaylistItemEnd.bind(this)
			, videoError : this._onVideoError.bind(this)
		};
		
		this.swfObject.registerEvent('StateChange', 'Uverse.config.players.callbacks.extend.' + this.swfObject.id + '.stateChange');
		this.swfObject.registerEvent('PlaylistItemStartEvent', 'Uverse.config.players.callbacks.extend.' + this.swfObject.id + '.playlistItemStart');
		this.swfObject.registerEvent('PlaylistItemEndEvent', 'Uverse.config.players.callbacks.extend.' + this.swfObject.id + '.playlistItemEnd');
		this.swfObject.registerEvent('PlaylistEnd', 'Uverse.config.players.callbacks.extend.' + this.swfObject.id + '.playlistEnd');
		this.swfObject.registerEvent('VideoError', 'Uverse.config.players.callbacks.extend.' + this.swfObject.id + '.videoError');
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.noAd();
				break;
			case 'finished':
				break;
		}
	}

	, _onStateChange : function(state) {
		if (!this.videoStartFired && (state == 'playing')) {
			this.onVideoStart();
			this.videoStartFired = true;
		}
		if (state=='opening' && this.hasContentStarted()) {
			this.contentStarted=false;
		}
		// The stopped event is being called when there is a token error in the player
		if (state == 'stopped' && this.getDuration() == 0) {
			this.onStateChange('killed');
		}
		this.onStateChange(state);
	}
	
	, _onPlaylistItemStart : function(event) {
		var adSlot = event[0].Options.AdSlot;
		if (adSlot > 0) {
			this.onAdStart();
		} else {
			if (!this.hasContentStarted()) {
				this.contentEndFired=false;
				this.onContentStart();
			}
		}
	}
	
	, _onPlaylistItemEnd : function(event) {
		var adSlot = event[0].Options.AdSlot;
		if (adSlot > 0) {
			this.onAdEnd();
		} else if(Math.abs(this.getDuration()-this.getPosition()) < 5) {
			if (!this.contentEndFired) {
				this.contentEndFired=true;
				this.onContentEnd();
			}
		}
	}
	
	, _onPlaylistEnd: function() {
		this.onVideoEnd();
	}
	
	, onContentStart: function() {
		this.parent();
	}

	, onContentEnd: function() {
		this.parent();
	}

	, _onVideoError: function(errorText) {
		this.onPlayerError(errorText);
	}
	
	//API
	
	, load : function(key, fullKey) {
		this.fullKey = fullKey;
		this.swfObject.LoadVideo(fullKey);
	}
	, replay : function() { this.swfObject.LoadVideo(this.fullKey); }
	, pause : function() { this.swfObject.Pause(); }
	, stop : function() { this.swfObject.PlayerStop(); }
	, resume : function() { this.swfObject.PlayerPlay(); }
	, isVideoPlaying : function() { return this.swfObject.IsVideoPlaying(); }
	, getPosition : function() { return Math.round(this.swfObject.GetPlaybackPosition() / 1000); }
	, getDuration : function() { return this.swfObject.GetPlaybackDuration(); }
	, seek : function(position) { this.swfObject.Seek(position * 1000); }
	, getPlayToken: function() { return this.swfObject.GetPlayToken(); }
	, getStreamToken: function() { return this.swfObject.GetStreamToken(); }
	
});Uverse.players.ExtendAds = new Class({
	Extends : Uverse.players.Extend
	
	, companionAdID: 'adComponent'
	
	, options: {
		large: false
	}
	
	, initialize: function(el, options) {
		this.parent(el, options);
		this._addIDToCompanionAdEl();

		this._createAdHtml();

	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				this.largePlayer();
				this.smallAd();
				break;
			case 'ad':
				this.smallPlayer();
				this.largeAd();
				break;
			case 'loading':
				this.smallAd();
				break;
			case 'finished':
				this.smallAd();
				break;
		}
	}

	, largePlayer: function() {
		this.parent();
		this._setSize(this.playerSizes.largeWidth, this.playerSizes.height);
	}
	, smallPlayer: function() {
		this.parent();
		this._setSize(this.playerSizes.smallWidth, this.playerSizes.height);
	}

	, largeAd: function() {
		this.parent();
		if (this._hasBannerAd()) {
			this.adWrapper.removeClass('hidden');
			this.bannerWrapper.addClass('hidden');
		}
	}
	
	, smallAd: function() {
		this.parent();
		if (this._hasBannerAd()) {
			this.adWrapper.addClass('hidden');
			this.bannerWrapper.removeClass('hidden');
		}
	}

	/**
	 * Resizes the player, ensuring the size is set internally to the player.
	 */
	, _setSize: function(w, h) {
		if (!this.swfObject)
			return;
		this.swfObject.width = w;
		this.swfObject.height = h;
		this.swfObject.SetSize(w, h);
	}
	
	/**
	 * determines if a banner ad (300x60) is present
	 */
	, _hasBannerAd: function() {
		return !!this.bannerWrapper;
	}
	
	/**
	 * Builds and injects the required FW ad slot HTML
	 * 
	 * <span name="external_sidebar" id="external_sidebar" class="_fwph">
	 *	 <form id="_fw_form_external_sidebar" style="display:none">
	 *	   <input type="hidden" name="_fw_input_external_sidebar" id="_fw_input_external_sidebar" value="w=300&h=250&ptgt=p">
	 *	 </form>
	 *   <span id="_fw_container_external_sidebar" class="_fwac"></span>
	 * </span>
	 * 
	 * <span name="external_banner" id="external_banner" class="_fwph">
	 *   <form id="_fw_form_external_banner" style="display:none">
	 *	   <input type="hidden" name="_fw_input_external_banner" id="_fw_input_external_banner" value="w=300&h=60&ptgt=p">
	 *	  </form>
	 *	  <span id="_fw_container_external_banner" class="_fwac"></span>
	 * </span>
	 */
	, _createAdHtml: function() {
	 	
		var slotId = 'external_sidebar';
		
		this.adWrapper = new Element('div', {'class' : 'adWrapper'}).inject(this.adComponent);
		
		this.adWrapper.adopt(
			new Element('span', {id : slotId, name : slotId, 'class' : '_fwph'}).adopt(
				new Element('form', {id : '_fw_form_' + slotId, styles : {display : 'none'}}).adopt(
					new Element('input', {type : 'hidden', name : '_fw_input_' + slotId, id : '_fw_input_' + slotId, value : 'w=300&h=250&ptgt=p'})
				)
				, new Element('span', {id : '_fw_container_' + slotId, 'class' : '_fwac'})
			)
		);
		

		var bannerSlotId = 'external_banner';

		this.bannerWrapper = new Element('div', {'class' : 'bannerWrapper'}).inject(this.adComponent);

		this.bannerWrapper.adopt(
			new Element('span', {id : bannerSlotId, name : bannerSlotId, 'class' : '_fwph'}).adopt(
				new Element('form', {id : '_fw_form_' + bannerSlotId, styles : {display : 'none'}}).adopt(
					new Element('input', {type : 'hidden', name : '_fw_input_' + bannerSlotId, id : '_fw_input_' + bannerSlotId, value : 'w=300&h=60&ptgt=p'})
				)
				, new Element('span', {id : '_fw_container_' + bannerSlotId, 'class' : '_fwac'})
			)
		);

	}
	
});Uverse.players.FoxLive = new Class({
	Extends : Uverse.players.Player

	, options: {
		playerApi: null
	}

	, el : null
	, playerID: 'videoPlayerComponent'
	, key: null
	, remoteUrl: null
	, itemId: null
	, iframe: {
		markup: '<iframe id="video-player" src="http://video.foxnews.com/v/video-embed.html?{parameters}{location}" width="{width}" height="{height}" marginwidth="0" marginheight="0" frameborder="0" scrolling="no"></iframe>'
		, parameters: {
			video_id: '{key}'
			, w: '{width}'
			, h: '{height}'
			, autoplay: 'true'
			, token_service: null
			, share: 'false'
			, email: 'false'
		}
	}
	
	, initialize: function(el, options) {
		this.el = el;
		
		this.parent(this.el, Object.merge({
			containerId: this.playerID
		}, options));

		this.iframe.parameters.token_service = Uverse.config.token.urls.tokenFoxLive;
	}
	
	, build: function() {
		this.buildContainer();
		this.onPlayerReady();
	}

	, load: function(key, itemId) {
		this.key = key;
		this.itemId = itemId;
		if(!this.hasContentStarted()) { this._executeFoxScriptManually(); }
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.noAd();
				break;
			case 'finished':
				break;
		}
	}


	, _executeFoxScriptManually: function() {
		/** written by fox, modified by mgage **/
		var location_path;
		location_path = document.location.hostname;

		if(typeof window.top.location != "undefined"){
			try {
				location_path = window.top.location.hostname;
			} catch(e) {
			}
		}

		location_path = location_path.replace("www.","");
		
		$('videoPlayerComponent').set('html', this._getVhtml(location_path));
		
		this._injectFoxScript();

		this.onContentStart();
	}
	
	, _getVhtml: function(location_path) {
		var vhtml = this.iframe.markup.substitute({
			parameters: this._toQueryString(this.iframe.parameters)
			, height: this.playerSizes.height
			, width: this.playerSizes.largeWidth
		});
		
		return vhtml.substitute({
			key: this.key
			, itemId: this.options.itemId
			, remoteUrl: this.options.remoteUrl
			, height: this.playerSizes.height
			, width: this.playerSizes.largeWidth
			, location: '&amp;loc='+location_path
		});
	}
	
	, _toQueryString: function(parameters) {
		var list = [];
		$H(parameters).each(function(value, key) {
			list.push(key + '=' + value);
		});
		return list.join('&');
	}
	
	, _injectFoxScript: function() {
		Asset.javascript(this.options.playerApi);
	}
	
});Uverse.players.Hbo = new Class({
	Extends : Uverse.players.Player
	
	, envConfigName: 'hbo'

	, activeVideoKey: null
	
	/**
	 * @constructor
	 * @param {Element} el
	 * @param {Object} options
	 */
	, initialize: function(el, options) {
		this.parent(el, Object.merge({
			scriptId : 'Hbo'
			, containerId : 'videoPlayerComponent'
			, large : true
		}, options));
		this.options.script = this.getEnvironmentConfigValue('playerApi');
	}
	
	, onScriptLoaded: function() {
		Uverse.console.log('[Hbo]', 'Player scripts are ready...');
		var containerId = this.options.containerId;

		// event listeners
		Uverse.config.players.callbacks.hbo[containerId] = {
			videoStart: this.onVideoStart.bind(this)
			, videoEnd: this.onVideoEnd.bind(this)
			, contentStart: this.onContentStart.bind(this)
			, contentEnd: this.onContentEnd.bind(this)
		};

		// init events for the player
		var eventListeners = {
			'videoStart': 'Uverse.config.players.callbacks.hbo.' + containerId + '.videoStart'
			, 'videoEnd': 'Uverse.config.players.callbacks.hbo.' + containerId + '.videoEnd'
			, 'contentStart': 'Uverse.config.players.callbacks.hbo.' + containerId + '.contentStart'
			, 'contentEnd': 'Uverse.config.players.callbacks.hbo.' + containerId + '.contentEnd'
		};
		
		// HBO replaces container
		var player = new Element('div', {id : this.options.containerId + '_hbo'}).inject(this.container);
		hbogo.initializeVideo(
			player.id
			, null
			, eventListeners
			, this.onPlayerReady.bind(this)
			, this.playerSizes.largeWidth
			, this.playerSizes.height
		);
	}
		
	// Player events
	, onPlayerReady: function() {
		Uverse.console.log('[Hbo]', 'Player is ready');
		this.parent();
	}

	/**
	 * @note Not implemented by this player
	 */
	, onStateChange: function(sender, args) {
		throw "Uverse.players.Hbo#onStateChange: Not Implemented";
	}
	, onContentStart: function() {
		Uverse.console.log('[Hbo]', 'onContentStart');
		this.videoPlaying = true;
		this.contentStarted = true;
		this.fireEvent.delay(5000, this, 'contentStart');
	}
	, onContentEnd: function() {
		Uverse.console.log('[Hbo]', 'onContentEnd');
		this.parent();
	}
	, onVideoStart: function() {
		Uverse.console.log('[Hbo]', 'onVideoStart');
		this.parent();
	}
	, onVideoEnd: function() {
		Uverse.console.log('[Hbo]', 'onVideoEnd');
		this.parent();
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.noAd();
				break;
			case 'finished':
				break;
		}
	}


	// API

	/**
	 * Load the video specific by key
	 * @param {String} key
	 */
	, load: function(key) {
		this.activeVideoKey = key;
		hbogo.loadVideo(key);
		
		// TODO: calling play in JS shows the play sign briefly
		hbogo.play();
	}
	, replay: function() {
		Uverse.console.log('[Hbo]', 'Replay hit');
		if (this.activeVideoKey)
			this.load(this.activeVideoKey);
		else
			Uverse.console.log('[Hbo]', 'Replay failed, no active video key');
	}
	, pause: function() {
		hbogo.pause();
	}
	, resume: function() {
		hbogo.resume();
	}
	, stop: function() {
		hbogo.stop();
	}
	
	/**
	 * @return {int}
	 */
	, getPosition: function() {
		return Math.round(hbogo.getPosition());
	}
	
	/**
	 * @return {int}
	 */
	, getDuration: function() {
		return Math.round(hbogo.getDuration());
	}
	
	/**
	 * This is a custom seek function that was built as a 
	 * workaround to the onContentStart event being fired
	 * before the video is ready to stream.
	 */
	, seek: function(to) {
		Uverse.console.log('[Hbo]', 'Seeking to');
		// Seek function is delayed by 500ms to allow the HBO CDN to start streaming.
		hbogo.seek.delay(500,this,to);
		
		// 2 seconds later, this function checks the position of the video against
		// the bookmark location to make sure the delayed event was executed.
		(function(){
			var currentPos = this.getPosition();
			
			// If the current position is more than 3 seconds out of sync with
			// the bookmark position it is safe to assume that the seek event
			// never fires so we fire it again. If this fails there is another
			// bigger problem so we drop the seek.
			if ((currentPos < to - 3) || ((currentPos > to + 3))){
				Uverse.console.log('[Hbo]', 'Seek failed. Seeking again to');
				hbogo.seek(to);
			}
		}).delay(2000,this,to);
	}
	
});Uverse.players.Hulu = new Class({
	Extends : Uverse.players.Player
	
	, advertPlayed : false
	, anythingPlayed : false
	, companionAdID: 'adComponent'

	, options: {
		script: null
		,scriptTemplate : 'http://config.hulu.com/js/hulu_global.js?guid=0B1CEA04-DCCB-40cf-AD0E-5222EF66D519&partner=ATT&width={smallWidth}&height={height}&wmode=transparent'
		,scriptId : 'NS_GUID_JS'
		,containerId : 'videoPlayerComponent'
	}
	
	, initialize: function(el, options) {
		this.parent(el, options);

		this.options.script = String.substitute(this.options.scriptTemplate, {
			smallWidth: this.playerSizes.smallWidth
			, height: this.playerSizes.height
		});

		// Reset Hulu's global NewSite object:
		if (typeof NewSite !== 'undefined') {
			NewSite = undefined;
		}

		this._addIDToCompanionAdEl();
	}

	, onScriptLoaded: function() {
		//Hulu's addListener method needs to be passed an object containing keys that match the event name
		var Bridge = {
			'newsiteReady' : this.onPlayerReady.bind(this)
			, 'videoAdBegin' : this.onAdStart.bind(this)
			, 'videoAdEnd' : this.onAdEnd.bind(this)
			, 'videoStart' : this._onContentStart.bind(this)
			, 'videoComplete' : this._onContentEnd.bind(this)
			, 'theEnd' : this.onVideoEnd.bind(this)
			, 'videoStateChange' : this.onStateChange.bind(this)
		};
		NewSite.addListener('newsiteReady', Bridge);
		NewSite.addListener('videoAdBegin', Bridge);
		NewSite.addListener('videoAdEnd', Bridge);
		NewSite.addListener('videoStart', Bridge);
		NewSite.addListener('videoComplete', Bridge);
		NewSite.addListener('theEnd', Bridge);
		NewSite.addListener('videoStateChange', Bridge);
	}
	
	// resizing logic

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				this.largePlayer();
				this.smallAd();
				break;
			case 'ad':
				this.smallPlayer();
				this.largeAd();
				break;
			case 'loading':
				this.smallAd();
				break;
			case 'finished':
				this.smallAd();
				break;
		}
	}

	, onAdStart: function() {
		this.parent();
		this.advertPlayed = true;
	}

	, onAdEnd: function() {
		this.parent();
	}

	, onLargePlayerStart: function() {
		NewSite.videoPlayerComponent.setSize(this.playerSizes.largeWidth, this.playerSizes.height);
	}

	, onSmallPlayerComplete: function() {
		NewSite.videoPlayerComponent.setSize(this.playerSizes.smallWidth, this.playerSizes.height);
	}
	
	// overridden content start and end so we can ignore ads and fire start event

	, _onContentStart: function(assetType) {
		this.videoPlaying = true;
		
		if (!this.anythingPlayed) {
			this.onVideoStart();
			this.anythingPlayed = true;
		}


		var isContent = (assetType === 'clip');
		if (isContent) {
			//ensure that the player is large, in case there were not adverts
//			if (!this.advertPlayed) {
//				this.largePlayer();
//			}
			this.onContentStart();
		}
	}

	, _onContentEnd: function(assetType) {
		var isContent = (assetType === 'clip');
		if (isContent) {
			this.onContentEnd();
		}
	}


	// API

	, load: function(key) {
		this.key = key;
		NewSite.videoPlayerComponent.playVideo(key);
		this.onSwfObjectLoaded(NewSite.videoPlayerComponent.getInstance());
	}
	
	, replay: function() {
		NewSite.videoPlayerComponent.playVideo(this.key);
	}
	
	, pause : function() {
		this.videoPlaying = false;
		NewSite.videoPlayerComponent.pauseVideo();
	}
	
	, resume : function() {
		this.videoPlaying = true;
		NewSite.videoPlayerComponent.resumeVideo();
	}
	
	, seek : function(to) {
		NewSite.videoPlayerComponent.seek(to);
	}
	
	, stop : function() {
		this.videoPlaying = false;
		NewSite.videoPlayerComponent.stopVideo();
	}
	
	, getPosition : function() {
		return Math.round(NewSite.videoPlayerComponent.getCurrentTime());
	}
	
	, getDuration : function() {
		return Math.round(NewSite.videoPlayerComponent.getProperty('duration'));
	}
	
});
Uverse.players.Mtv = new Class({
	Extends : Uverse.players.Player

	, playStates: [ 'playing', 'playstates.playing' ]
	, duration : 0
	
	, initialize: function(el, options) {
		this.parent(el, Object.merge({
			containerId : 'mtvPlayer'
			, large : true
			, swfWidth : 880
			, swfHeight : 495
			, vars : {
				autoPlay : 'true'
				, orig : 'att'
			}
		}, options));
		
		window.mtvnPlayerLoaded = function() {
			
			//event listeners
			Uverse.config.players.callbacks.mtv[this.swfObject.id] = {
				onMetadata : this._onMetadata.bind(this)
				, onPlaylistComplete : this.onVideoEnd.bind(this)
				, onStateChange : this._onStateChange.bind(this)
				, onMediaEnded : this.onContentEnd.bind(this)
			};
			
			this.swfObject.addEventListener('METADATA', 'Uverse.config.players.callbacks.mtv.' + this.swfObject.id + '.onMetadata');
			this.swfObject.addEventListener('PLAYLIST_COMPLETE', 'Uverse.config.players.callbacks.mtv.' + this.swfObject.id + '.onPlaylistComplete');
			this.swfObject.addEventListener('STATE_CHANGE', 'Uverse.config.players.callbacks.mtv.' + this.swfObject.id + '.onStateChange');
			this.swfObject.addEventListener('MEDIA_ENDED', 'Uverse.config.players.callbacks.mtv.' + this.swfObject.id + '.onMediaEnded');
			
		}.bind(this);
	}
	
	, build: function() {
		this.buildContainer();
		this.updatePlayer('loading');
		this.onPlayerReady();
	}
	
	, _onMetadata: function(metadata) {
		if (metadata.duration && (metadata.duration > 0))
			this.duration = Math.round(metadata.duration);
	}
	
	, onVideoStart: function() {
		this.parent();
	}
	
	, _onStateChange: function(state) {
		if (!this.contentStarted && this.playStates.contains(state) && (this.duration > 0)) {
			this.onVideoStart();
			this.onContentStart();
		}
		this.onStateChange(state);
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.noAd();
				break;
			case 'finished':
				break;
		}
	}

	//API
	
	, load : function(key) {
		this.key = key;
		var path = 'http://media.mtvnservices.com/' + key;
		var swiff = new Swiff(path, Object.merge({container : this.container}, this.swiffOptions));
		this.swfObject = $(swiff); //returns a handle on the <object> or <embed> to make Flash calls into
	}
	, replay: function() { this.load(this.key); }
	, pause : function() { this.swfObject.pause(); }
	, stop : function() { this.swfObject.stopPlayer(); }
	, resume : function() { this.swfObject.unpause(); }
	, getDuration : function() { return this.duration; }
	, getPosition : function() { return Math.round(this.swfObject.getPlayheadTime()); }
	, seek : function(position) { this.swfObject.setPlayheadTime(position); }
});
Uverse.players.Silverlight = new Class({
	Extends : Uverse.players.Player
	
	, attPlayerBridge: null
	, smfPlayerBridge: null
	, silverlightElID: null
	, xapLocation: 'AttSilverlightPlayer.xap'
	, remoteUrl: null
	, disableControls: null
	, additionalContentCategoryPath: null
	, noSilverlightPanelClass: "no-silverlight-wrapper"
	, noSilverlightClass: "noSilverlight"
	, hasError: false
	
	, initialize: function(el, options) {
		this.parent(el, Object.merge({
			large : options.large != undefined ? options.large : true
			, script: Uverse.config.jsLibPath + 'silverlight/silverlight.js'
			, scriptId : 'silverlight'
			, containerId : 'videoPlayerComponent'
		}, options));
		
		this.xapLocation = options.playerLocation + this.xapLocation;
		this.silverlightElID = 'silverlightPlayer_' + options.uid;
		this.remoteUrl = options.remoteUrl;
		this.disableControls = options.disableControls || false;
		this.additionalContentCategoryPath = options.additionalContentCategoryPath;
	}
	
	, onScriptLoaded: function() {
		Silverlight.createObjectEx({
			source: this.xapLocation
			, parentElement: this.container
			, id: this.silverlightElID
			, properties: {
				width: this.playerSizes.largeWidth
				, height: this.playerSizes.height
				, background: 'black'
				, enableHtmlAccess : 'true'
				, windowless : 'true'
				, alt: this.getNoFlashContainerHTML()
			}
			, events: {
				onError: this.silverlightPlayerError.bind(this)
				, onLoad: this.silverlightPlayerReady.bind(this) 
			}
			, initParams: 'remoteUrl=' + this.remoteUrl + ',disableControls=' + this.disableControls  + ',additionalContentCategoryPath=' + this.additionalContentCategoryPath
		});
	}
	
	, getNoFlashContainerHTML: function() {
		var noFlashMessage = $$('.' + this.noSilverlightPanelClass)[0].clone();
		noFlashMessage.getFirst().removeClass('hidden');
		
		return noFlashMessage.get('html');
	}
	
	, silverlightPlayerReady: function() {
		var silverlightEl = $(this.silverlightElID);
		this.attPlayerBridge = silverlightEl.Content.AttPlayer;
		this.smfPlayerBridge = silverlightEl.Content.SmfPlayer;
		
		this.smfPlayerBridge.PlayStateChanged = this.onStateChange.bind(this);		
		this.smfPlayerBridge.MediaOpened = this.onContentStart.bind(this);
		this.smfPlayerBridge.MediaEnded = this.onContentEnd.bind(this);
		
		this.attPlayerBridge.BitrateChanged = this.onBitrateChanged.bind(this);
		
		this.onPlayerReady();
	}
	
	, silverlightPlayerError: function(sender, args) {
		var errorType = args.ErrorType;
		if (errorType == "ManagedRuntimeError") {
			this.onPlayerError(args.ErrorMessage);
		} else {
			this.onPlayerError(args);
		}
	}
	
	//Events
	
	, onStateChange: function(sender, args) {
		if(!this.hasError) {
			Uverse.console.log('[Silverlight]', 'State Changed: ' + args.Result.toLowerCase());
			if(args.Result.toLowerCase() == 'stopped') { this.hasError = true; }
		}
		this.parent(args.Result.toLowerCase());
	}
	
	, onBitrateChanged: function(sender, args) {
		this.parent(args.CurrentBitrate, args.MaximumBitrate);
	}

	, onContentEnd: function() {
		Uverse.console.log('[Silverlight]', 'On Content End');
		this.onVideoEnd();
		this.parent();
	}
	
	, onContentStart: function() {
		Uverse.console.log('[Silverlight]', 'On Content Start');
		this.onVideoStart();
		this.parent();
	}
	
	, supportsBitrateEvents: function() {
		return true;
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.largePlayer();
				this.noAd();
				break;
			case 'finished':
				break;
		}
	}


	//API
	
	, load: function(key, itemId) { 
		this.itemId = itemId;
		this.attPlayerBridge.LoadVideo(itemId);
	}
	
	, replay: function() {
		this.attPlayerBridge.LoadVideo(this.itemId);
	}
	
	, pause : function() {
		this.smfPlayerBridge.Pause();
	}
	
	, resume : function() {
		this.smfPlayerBridge.Play();
	}
	
	, stop : function() {
		this.smfPlayerBridge.Stop();
	}
	
	, getPosition : function() {
		return Math.round(this.smfPlayerBridge.PlaybackPositionSeconds);
	}
	
	, getDuration: function() {
		return Math.round(this.smfPlayerBridge.EndPositionSeconds);
	}
	
	, seek: function(to) {
		this.smfPlayerBridge.SeekToPosition(to);
	}
	
	, getPlayToken: function() {
		return this.attPlayerBridge.GetPlayToken();
	}
	
	, getStreamToken: function() {
		return this.getPlayToken();
	}

});Uverse.players.Turner = new Class({
	Extends : Uverse.players.Player
	
	, playerID : 'videoPlayerComponent'
	, companionAdID: 'adComponent'
	, cvpCallbacks : {}
	, cvpInstance : null
	, key : null
	, itemID : null
	, metaDataExists : false
	, envConfigName: 'turner'
	, tokenHandler: null

	// turner specific options
	, provider : null
	, environment : null
	, sid: null
	, callbackUrl: null
	, x: null
	, t: null


	, initialize: function(el, options) {
		this.cvpCallbacks = {
			onPlayerReady : this.onPlayerReady.bind(this)
			, onContentBegin: this.onVideoStart.bind(this)
			, onContentComplete: this.onVideoEnd.bind(this)
			, onContentPlay : this._onContentStart.bind(this)
			, onContentEnd : this.onContentEnd.bind(this)
			, onAdPlay : this.onAdStart.bind(this)
			, onAdEnd : this.onAdEnd.bind(this)
			, onContentMetadata : this.onContentMetaData.bind(this)
			, onContentPause : this._onStateChange.bind(this)
		};
		
		this.parent(el, Object.merge({
			script : options.playerApi
			, scriptId : this.provider
			, containerId : this.playerID
			, large : false
		}, options));
		
		this.provider = this._getTurnerNetworkNameFromNetwork(options.videoNetwork);
		this.environment = this.getEnvironmentConfigValue('env');

		this._addIDToCompanionAdEl();

		if (typeof CVPPartner !== 'undefined') {
			this.options.ignoreScript = true;
			this.onScriptLoaded();
		} else {
			this._consoleWorkaroundSave();
		}
	}

	, _consoleWorkaroundSave: function() {
		if (Browser.ie8 && window.console) {
			// IE8's console cannot be BOUND (using MooTools),
			// but the Turner player JS binds the console anyway.
			// Here's a workaround:
			this.consoleWorkaround = window.console;
			window.console = undefined;
		}
	}
	, _consoleWorkaroundRestore: function() {
		if (Browser.ie8 && this.consoleWorkaround) {
			window.console = this.consoleWorkaround;
			this.consoleWorkaround = null;
		}
	}

	, onScriptLoaded: function() {
		this._consoleWorkaroundRestore();
		CVPPartner.init(this._cvpInitSuccess.bind(this), this._cvpInitFailure.bind(this), true);
	}
	
	, _cvpInitSuccess: function() {
		this.cvpInstance = CVPPartner.createTVEInstance(
				this.playerSizes.smallWidth
				, this.playerSizes.height
				, this.playerID
				, this.cvpCallbacks
				, this.provider
				, new Array({ 
					adWidth: 300
					, adHeight: 250 
					, adDomID: this.companionAdID
				}) 
				, { wmode : 'opaque' }
				, this.environment
		);
	}
	
	, _cvpInitFailure: function() {
		Uverse.console.error('[Turner]', 'CVP Init Failure');
		this.onPlayerError('CVP Init Failure');
	}
	
	, _getTurnerNetworkNameFromNetwork: function(network) {
		var provider = String(network).toLowerCase();
		switch (provider) {
		
			// publisher workarounds
			case 'tru':
				return 'trutv';
			case 'ctn':
				return 'cartoonnetwork';
			case 'as':
				return 'adultswim';
			case 'cartoonnetwork':
			case 'adultswim':
			case 'trutv':
			case 'tnt':
			case 'tbs':
			case 'cnn':
				return provider;
			default:
				throw new Error('Invalid network provider specified: ' + provider);
		}
	}

	, _setupTokenHandler: function() {
		var callbacks = {
			tokenError: this.onPlayerError.bind(this)
			,tokenRetrieved: this._tokenRetrieved.bind(this)
		};
		this.tokenHandler = new Uverse.utils.TokenHandler(callbacks);
		this.tokenHandler.sendAuthenticationRequest(this.itemID);
	}

	, _tokenRetrieved: function(playToken, streamTokenText) {
		this._playVideoWithToken(playToken.tokenString);
		this.streamToken = streamTokenText;
	}
	
	, _playVideoWithToken: function(token) {
		this.cvpInstance.resize(this.playerSizes.smallWidth, this.playerSizes.height);
		this.cvpInstance.play(this.key, { accessToken: token });
		this.videoPlaying = true;
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				this.largePlayer();
				this.noAd();
				break;
			case 'ad':
				this.smallPlayer();
				this.largeAd();
				break;
			case 'loading':
				this.setAdStyleNeverSmall();
				this.noAd();
				break;
			case 'finished':
				this.noAd();
				break;
		}
	}

	, onAdStart: function() {
		this.parent();
	}
	
	, onAdEnd: function() {
		this.parent();
	}
	
	, onLargePlayerStart: function() {
	}
	
	, onLargePlayerComplete: function() {
		this.cvpInstance.resize(this.playerSizes.largeWidth, this.playerSizes.height);
	}

	, onSmallPlayerComplete: function() {
		this.cvpInstance.resize(this.playerSizes.smallWidth, this.playerSizes.height);
	}
	
	//Events
	
	, _onStateChange: function(sender, args) {
		var state = (args ? 'paused' : 'playing');
		this.onStateChange(state);
	}

	, onVideoEnd: function() {
		this.parent();
	}

	, onVideoStart: function() {
		this.parent();
	}

	, _onContentStart: function() {
		this.onVideoStart();
		this.onContentStart();
	}
	
	, onContentMetaData: function(id, duration) {
		this.metaDataExists = true;
	}

	//API
	
	, load: function(key, itemId) { 
		this.key = key;
		this.itemID = itemId;

		this._setupTokenHandler();
		this.onSwfObjectLoaded(this.cvpInstance.getDOMPlayer());
	}

	, replay: function() {
		this.load(this.key, this.itemID);
	}
	
	, pause : function() {
		this.cvpInstance.pause();
		this.videoPlaying = false;
	}
	
	, resume : function() {
		this.cvpInstance.resume();
		this.videoPlaying = true;
	}
	
	, stop : function() {
		this.cvpInstance.pause();
		this.cvpInstance.seek(0);
		this.videoPlaying = false;
	}
	
	, getPosition : function() {
		return Math.round(this.cvpInstance.getPlayhead());
	}
	
	, getDuration: function() {
		return this.metaDataExists ? this.cvpInstance.getDuration() : 0;
	}
	
	, seek: function(to) {
		this.cvpInstance.seek(to);
		this.videoPlaying = true;
	}

	, getStreamToken: function(){
		return this.streamToken;
	}
});
Uverse.players.Vevo = new Class({
	Extends : Uverse.players.Player
	
	, playerContainerID: 'videoPlayerComponent'
	, vevoEmbedDirectory: ''
	, envConfigName: 'vevo'
		
	, vevoObjectParms: {
		flashVars: {
			playerType: 'embedded'
			, videoId: null
			, playlist: 'false'
			, enableDomScan: 'true'
			, siteSection: 'ATandT_ATandT.com'
			, playerId: '62FF0A5C-0D9E-4AC1-AF04-1D9E97EE3961'
			, autoplay: '1'
			, endScreen:'play'
			, cc: 'US'
			, cultureName: 'en-US'
			, cultureIsRTL: 'False'
			, sbId: '05c1ca10-5260-4799-b332-eb23ee59fc59'
		}
		, parms: {
			bgcolor: '#000000'
			, allowFullScreen: 'true'
			, allowScriptAccess: 'always'
			, wmode: 'transparent'
		}
		, attributes: {
			id: 'vevoPlayer' 
		}
	}
	
	, initialize: function(el, options) {
		this.parent(el, Object.merge({
			script : options.playerApi
			, scriptId : 'vevoJS'
			, containerId : this.playerContainerID
			, large : false
		}, options));
		
		this._addIDToCompanionAdEl();
		
		this.vevoEmbedDirectory = this.getEnvironmentConfigValue('swfLocation');
		
	}
	
	, onScriptLoaded: function() {
		this.onPlayerReady();
	}

	, updatePlayer: function(state) {
		switch (state) {
			case 'content':
				break;
			case 'ad':
				break;
			case 'loading':
				this.setAdStyleNeverSmall();
				this.smallPlayer();
				this.largeAd();
				break;
			case 'finished':
				this.noAd();
				break;
		}
	}


	, _generateSWFAndPlay: function() {
		swfobject.embedSWF(this.vevoEmbedDirectory
				, this.playerContainerID
				, this.playerSizes.smallWidth
				, this.playerSizes.height
				, '10.1.53'
				, false
				, this.vevoObjectParms.flashVars
				, this.vevoObjectParms.parms
				, this.vevoObjectParms.attributes
		); 
		
		window.vevoVideoComplete = this._vevoVideoComplete.bind(this);
		
		this.adComponent.set('html', this._getVevoAdHTML());

		this.onContentStart();
	}

	, _vevoVideoComplete: function() {
		this.onVideoEnd();
	}
	
	, _getVevoAdHTML: function() {
		return '<span id="comp_300x250" class="_fwph">' +
				'<form id="_fw_form_comp_300x250" style="display:none" >' +
					'<input type="hidden" name="_fw_input_comp_300x250" id="_fw_input_comp_300x250" value="ptgt=p&envp=g_iframe_js&slau=300x250_Companion1|300x60_Companion1|300x250|300x60&slid=comp_300x250&cd=300,250|300,60&flag=+fcai+niic" />' +
				'</form>' +
				'<span id="_fw_container_comp_300x250" class="_fwac"></span>' +
			'</span>';
	}
	
	, _addKeyToFlashVars: function() {
		this.vevoObjectParms.flashVars.videoId = this.key;
	}

	//API
	
	, load: function(key) {
		this.key = key;
		this._addKeyToFlashVars();
		this._generateSWFAndPlay();
		this.onSwfObjectLoaded(swfobject.getObjectById("vevoPlayer"));
	}
	
	, pause : function() {
		this.videoPlaying = false;
		swfobject.getObjectById("vevoPlayer")._pause(); 
	}
	
	, resume : function() {
		this.videoPlaying = true;
		swfobject.getObjectById("vevoPlayer")._play(); 
	}
	
});
Uverse.playerExtensions.ExtensionManager = new Class({
	Implements: [ Options ]
	             
	, extensions: []
	, loadPlayerCallback: null
	, options: {
		displayPanelClassName: '.extensionPanels'
	}
	, currentActiveIndexes: {
		init: -1
	}
	, extensionCallbacks: null
	, initializedExtensions: []
	, extensionPanels: null
	, player: null
	
	, initialize: function(el, extensions, loadPlayerCallback, options) {
		this.setOptions(options);
		this.extensions = extensions;
		this.loadPlayerCallback = loadPlayerCallback;
		
		this.extensionPanels = el.getElement(this.options.displayPanelClassName);
	}
	
	, runPlayerLoading: function() {
		this._runNextPlayerLoading();
	}
	
	, _runNextPlayerLoading: function() {
		var extensionObj = this.extensions[++this.currentActiveIndexes.init];
		
		if(extensionObj) {
			var extensionName = extensionObj.name;
			var extensionOptions = extensionObj.options;
			if (!this.extensionCallbacks) {
				this.extensionCallbacks = {
					'complete': this._runNextPlayerLoading.bind(this)
				};
			}
			var extensionCtor = Uverse.playerExtensions[extensionName];
			if (!extensionCtor) {
				Uverse.console.error("[ExtensionManager]", "Could not find '", extensionName, "'");
				this._runNextPlayerLoading();
			} else {
				var extension = new extensionCtor(extensionOptions, this.extensionCallbacks);

				this.initializedExtensions.push(extension);
				extension.playerLoading(this.extensionPanels);
			}
		} else {
			this.loadPlayerCallback();
		}
	}

	, runPlayerLoaded: function(player, playerContainer) {
		this.initializedExtensions.each(function(extension) {
			extension.playerLoaded(player, playerContainer);
		});
	}

	, runPlayerFinished: function() {
		this.initializedExtensions.each(function(extension) {
			extension.playerFinished();
		});
	}

	, destroyExtensions: function() {
		this.initializedExtensions.each(function(extension) {
			try {
				extension.destroyExtension();
			} catch (ex) {
				Uverse.console.error("[ExtensionManager]", "Error destroying the extension:", extension, ex);
				Uverse.console.throwAway(ex);
			}
		});
	}
});Uverse.playerExtensions.ExtensionAware = new Class({
	Implements: [Options, Callbacks]
	, options: { }
	, callbacks: {
		complete: null
	}

	/** Overridable */
	, playerLoading: function(extensionPanels) {
		this.callbacks.complete();
	}

	/** Overridable */
	, playerLoaded: function(player, playerContainer) { }

	/** Overridable */
	, playerFinished: function() { }

	/** Overridable */
	, destroyExtension: function() { }

	, updatePanelTitle: function(panel, html) {
		panel.getElement('.player-extension-title').set('html', html);
	}
});
Uverse.playerExtensions.AgeRestrictionExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		var isUserLoggedIn = Uverse.page.isUserLoggedIn();

		if (isUserLoggedIn) {
			this.callbacks.complete();
		} else {
			var ageRestrictionPanel = extensionPanels.getElement('.ageRestriction-extension');
			ageRestrictionPanel.removeClass('hidden');
		}
	}
});Uverse.playerExtensions.DeviceManagementExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware
	
	, options: {
		swfPath: null
		, deviceType: null
		, swfMaxAttempts: 100
		, swfAttempt: 0
	}
	
	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		this.template = extensionPanels.getElement('.deviceManagement-extension');
		Uverse.page.addMemoryEvent('Personalization-uverseData:once', this._onUserData.bind(this));
	}
	
	, _onUserData: function(personalizationUverseData) {
		if(Uverse.page.isUserLoggedIn() && !personalizationUverseData.isDeviceRetreived()) {
			Uverse.console.log('[DeviceManagementExtension]', 'Device ID SWF Loading...');
			this._createSWF();
		} else {
			Uverse.console.log('[DeviceManagementExtension]', 'Device ID Retrieved');
			this.template.destroy();
			this.callbacks.complete();
		}
	}
	
	, _createSWF: function() {
		//the SWF expects certain methods on window
		window.onSwfContentLoaded = this._onSwfContentLoaded.bind(this);
		window.deviceRegistrationStatus = this._deviceRegistrationStatus.bind(this);
		
		this.swf = new Swiff(this.options.swfPath, { container : this.template });
	}
	
	, _onSwfContentLoaded: function() {
		// it is possible (mainly in IE) that the SWF loads before this.swf is set
		if (this.options.swfAttempt < this.options.swfMaxAttempts) {
		var swiffer = $(this.swf);
			if (this.swf && swiffer.registerDevice) {
				Uverse.console.log('[DeviceManagementExtension]', 'Device ID SWF loaded');
				swiffer.registerDevice();
			} else {
				Uverse.console.log('[DeviceManagementExtension]', 'SWF loaded but not yet part of DOM...');
				this.options.swfAttempt++;
				this._onSwfContentLoaded.delay(100, this);
			}
		} else {
			Uverse.console.error('[DeviceManagementExtension]', 'SWF did not load after ' + this.options.swfAttempt + ' attempts.');
		}
	}
	
	, _deviceRegistrationStatus: function(response) {
		if (response.deviceRegistration == 'success') {
			Uverse.console.log('[DeviceManagementExtension]', 'Device ID registration successful');
			this.template.destroy();
			this.swf = null;
			
			// combination of the device ID component and Silverlight DRM has
			// a horrible crashing side effect in IE so we have to refresh :(
			var hasCrashingBug = ( (this.options.deviceType.toUpperCase() == 'SILVERLIGHT') && Browser.ie && !Browser.ie9);
			if (hasCrashingBug) {
				Uverse.console.log("[DeviceManagementExtension]", "Workaround for DeviceId + Silverlight bug");
				window.location.reload(); // Refresh the entire page; DeepLink will take care of the rest!
			} else {
				this.callbacks.complete();
			}
		}
	}
});Uverse.playerExtensions.EntitlementExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, options: {
		upgradeMessage: null
	}

	, entitlementHelper: new Uverse.utils.Entitlement()
	               
	, extensionPanel: null
	             
	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		var entitlementResult = this.entitlementHelper.compareEntitlement(this.options.entitlement);
		
		if(entitlementResult == 'allowed') {
			this.callbacks.complete();
			return;
		}
		
		this.extensionPanel = extensionPanels.getElement('.entitlement-extension');
		this._showButton(entitlementResult);
		this._displayEntitlementMessage();
	}
	
	, _displayEntitlementMessage: function() {
		this.extensionPanel.getElement('.player-extension-title').set('text', this.options.upgradeMessage);
		this.extensionPanel.removeClass('hidden');
	}
	
	, _showButton: function(type) {
		this.extensionPanel.getElement('.' + type + '-button').removeClass('hidden');
	}
});Uverse.playerExtensions.FlashCheckExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, options: {
		minVersion : null
	}

	, template: null
	               
	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		this.template = extensionPanels.getElement('.flashCheck-extension');
		
		//unfortunately, MooTools' Browser.Plugins.Flash doesn't include minor versions
		//so this is modified version of their detection method to include it
		var versionParts = (Function.attempt(function(){
			return navigator.plugins['Shockwave Flash'].description;
		}, function(){
			return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
		}) || '0 r0').match(/\d+/g);
		
		var version = parseFloat(versionParts[0] || 0) + '.' + (versionParts[1] || 0);
		
		if (version < this.options.minVersion) {
			var type;
			if (version > 0) { type = 'upgrade'; }
			else { type = 'install'; }
			
			this.updatePanelTitle(this.template, this.template.getElement('.flashTitleTemplate .' + type).get('html'));
			this._ifUpgradeWriteVersionNumberToMessage(type);
			this.template.getElement('.flashMessage .' + type).removeClass('hidden');
			this.template.removeClass('hidden');
			
		} else {
			this.callbacks.complete();
		}
	}
	
	, _ifUpgradeWriteVersionNumberToMessage: function(type) {
		if(type == 'upgrade') {
			this.template.getElement('.versionNumber').set('html', this.options.minVersion);
		}
	}
});Uverse.playerExtensions.GoogleAnalyticsExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		Uverse.console.log('[GoogleAnalyticsExtension]', 'Tracked Play Page Impression');
		Uverse.page.googleAnalyticsPush('_trackEvent', [ this.options.tracking_category, 'Play page impression', this.options.tracking_label ]);
		Uverse.page.googleAnalyticsPush('_trackPageview', [this.options.fullUrl]);
		this.callbacks.complete();
	}
	
	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		Uverse.console.log('[GoogleAnalyticsExtension]', 'Tracked Video Player Impression');
		Uverse.page.googleAnalyticsPush('_trackEvent', [ this.options.tracking_category, 'Video player impression', this.options.tracking_label ]);
	}
});Uverse.playerExtensions.LogViewImpressionExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware
	,Binds: [ '_logViewImpression' ]
	, options: {
		impressionUrl: null
	}

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		this.player = player;
		this.player.addEvent('videoStart', this._logViewImpression);
		this.player.addEvent('contentStart', this._logViewImpression);
	}

	, _logViewImpression: function() {
		Uverse.console.log("[LogViewImpressionExtension]", "Logging View Impression");

		this.player.removeEvent('videoStart', this._logViewImpression);
		this.player.removeEvent('contentStart', this._logViewImpression);

		new Request({
			method: 'post'
			,url: this.options.impressionUrl
			,noCache: true
		}).send();
	}

});Uverse.playerExtensions.MetadataExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, options : {
		liveMetadataUrl: null
		, initialDelay: 5000
		, retryMax: 3
		, retryDelay: 60000
	}
	
	, metadataContainer: null
	, liveMetadata: {
		request: null
		/**
		 * Array of {timestamp, contents}
		 */
		,results: null
		,retryCount: 0
		,timerRequest: null
		,timerNext: null
	}

	/**
	 * Offset between "client time" and "server time" (in milliseconds)
	 */
	, clientTimeOffset: 0

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	, _setupLiveMetadata: function() {

		this.liveMetadata.request = new Request({
			method: 'get'
			, url: this.options.liveMetadataUrl
			, onSuccess: this._liveMetadataRequestSuccess.bind(this)
			, onFailure: this._liveMetadataRequestRetry.bind(this)
		});

		// Get the next video details (after a short delay)...
		this.liveMetadata.timerRequest = this.liveMetadata.request.send.delay(this.options.initialDelay, this.liveMetadata.request);
	}

	/**
	 * Returns the current "server time"
	 */
	, _getNow: function(){
		return new Date(new Date().getTime() - this.clientTimeOffset);
	}

	, _liveMetadataRequestRetry: function(){
		// If we fail, we don't want to just die; let's try again:
		if (this.liveMetadata.retryCount >= this.options.retryMax) {
			// This will exit forever:
			return;
		}
		this.liveMetadata.retryCount++;
		this.liveMetadata.timerRequest = this.liveMetadata.request.send.delay(this.options.retryDelay, this.liveMetadata.request);
	}

	, _liveMetadataRequestSuccess: function(responseHTML){
		var responseTree = Elements.from(responseHTML);

		// Loop through all elements, and extract the timestamp and the contents:
		this.liveMetadata.results = responseTree.filter('.live-metadata-container').map(function(el){
			return {
				timestamp: new Date(Number(el.get('data-timestamp')))
				, contents: el.getElement('.modal-player-meta')
			};
		});
		
		// Make sure we have at least one result:
		if (this.liveMetadata.results.length == 0) {
			this._liveMetadataRequestRetry();
			return;
		}

		Uverse.console.log("[MetadataExtension]", "Retrieved ", this.liveMetadata.results.length, " metadata results");
		
		this.liveMetadata.retryCount = 0;
		this._loadCurrentLiveMetadata();
	}

	/**
	 * Loads the most current metadata, based on the timestamp,
	 * and sets a timer to load the next one.
	 */
	, _loadCurrentLiveMetadata: function(){
		// Find the first item with an up-to-date timestamp:
		var now = this._getNow();
		var panels = this.liveMetadata.results;
		
		var currentIndex = 0; // default to the first item
		// Search for the item with the next timestamp:
		var delta = 3000; // When comparing timestamps, we should use a delta.
		panels.each(function(vd, ix){
			if (vd.timestamp.getTime() < (now.getTime() + delta)){
				currentIndex = ix;
			}
		});
		
		// Load the current contents
		var newContents = panels[currentIndex].contents;
		var oldContents = this.metadataContainer;
		newContents.replaces(oldContents);
		this.metadataContainer = newContents;

		Uverse.console.log("[MetadataExtension]", "Updated Metadata");

		// Figure out how long until the next item:
		var nextDuration = 0;
		if (currentIndex < panels.length - 1){
			nextDuration = panels[currentIndex + 1].timestamp - now;
		}
		
		
		// If we're almost out of items, start loading more:
		if (currentIndex >= panels.length - 2){
			// Let's create a random delay between (now + 5) and (next - 5),
			// so that we spread out the server load:
			var delay = 5000 + (Math.random() * Math.max(0, nextDuration - 10000));
			this.liveMetadata.timerRequest = this.liveMetadata.request.send.delay(delay, this.liveMetadata.request);
			return;
		}
		
		

		// Set a timer for the next item to display:
		this.liveMetadata.timerNext = this._loadCurrentLiveMetadata.delay(nextDuration, this);
		
	}


	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		if (this.options.liveMetadataUrl) {
			this.metadataContainer = playerContainer.getElement('.modal-player-meta');

			this._setupLiveMetadata();
		}
	}


	/** Overrides base */
	, destroyExtension: function() {
		if (this.liveMetadata.timerRequest) {
			clearTimeout(this.liveMetadata.timerRequest);
		}
		if (this.liveMetadata.timerNext) {
			clearTimeout(this.liveMetadata.timerNext);
		}
		if (this.liveMetadata.request) {
			this.liveMetadata.request.cancel();
		}
	}

});
Uverse.playerExtensions.NextVideoExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, options : {
		/**
		 * @param {String} nextVideoUrl
		 */
		nextVideoUrl: null

		/**
		 * @param {Object} nextVideoInfo
		 */
		, nextVideoInfo: null

		/**
		 * @param {Array} nextVideoHistory
		 */
		, nextVideoHistory: null
	}

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerFinished: function() {
		// Play the next video automatically:
		Uverse.console.log("[NextVideoExtension]", "Playing the next video:", this.options.nextVideoInfo);
		var historyOptions = {
			replaceHistory: true
			,windowTitle: this.options.nextVideoInfo.videoTitle
		};
		Uverse.page.loadDeepLink(this.options.nextVideoUrl, this.options.nextVideoInfo, historyOptions);
	}

	/** Overrides base */
	, destroyExtension: function() {

	}


});
Uverse.playerExtensions.ParentalControlsExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		this.template = extensionPanels.getElement('.parental-controls-extension');
		if (this.template) {
			// Show the extension
			this.template.removeClass('hidden');
			
			// Initiate all elements
			this.pcForm = this.template.getElement('form#parentalControlChallengeForm');
			this.pinInputs = this.pcForm.getElements('input.parentalControlPinEntry');
			this.submitButton = this.pcForm.getElement('button.submit');
			
			this.forgetLink = this.template.getElement(".forgotPinLink");
			
			this.messageEl = this.template.getElement(".player-extension-message");
			this.messageContainer = this.messageEl.getElement("p");
			this.messageCloseEl = this.messageEl.getElement("a.close");
			
			// Form Validation
			this.pinInputs.each(function(inputEl) {
				inputEl.addEvent('keydown', this._bindMovementKeys.bind(this));
				inputEl.addEvent('keyup', this._validateInput.bind(this));
			}.bind(this));
			
			// Form Submit
			this.pcForm.addEvent("submit", this._submitPIN.bind(this));

			// Forgot PIN Link
			this.forgetLink.addEvent('click', this._requestPIN.bind(this));
			
			// Close message link
			this.messageCloseEl.addEvent('click', this._hideMessage.bind(this));
		}
	}
	
	, _bindMovementKeys: function(ev) {
		var el = $(ev.target);
		if (ev.key == 'left') {
			this._moveLeft(el);
			ev.preventDefault();
		} else if ((ev.key == 'right')) {
			this._moveRight(el);
			ev.preventDefault();
		} else if (ev.code === 8) {
			if (!el.value.length) this._moveLeft(el);
		} else {
			// Check input
		}
	}
	
	, _validateInput: function(ev) {
		if (!(ev.key == 'left' || ev.key == 'right'  || ev.code == 8)) {
			var el = $(ev.target);
			if (el.value && el.value.length > 0) {
				if (!isNaN(el.value)) {
					this._moveRight(el);
				} else {
					el.value = "";
				}
			}
		}
	}
	
	, _moveLeft: function(el) {
		var prev = el.getPrevious('input.parentalControlPinEntry');
		if (prev) {
			prev.focus();
			prev.selectRange(0, prev.value.length + 1);
		}
	}
	
	, _moveRight: function(el) {
		var next = el.getNext('input.parentalControlPinEntry');
		if (next) {
			next.focus();
			next.selectRange(0, next.value.length + 1);
		}
	}
	
	, _requestPIN: function(ev) {
		ev.preventDefault();
		this.pinRequest = new Request.JSON({
			url: '/parentalControls/reminder.json'
			, headers: {'X-Requires-Authentication': 'true'} 
			, onSuccess: function(responseJSON, responseText) {
				this.messageContainer.set('text', responseJSON.message);
				if (responseJSON.success) { 
					this.messageEl.removeClass('error'); 
				} else {
					this.messageEl.addClass('error');
				}
				this.messageEl.removeClass('hidden');
			}.bind(this)
			, onFailure: function(xhr) {
				// TODO: Move to messages_en.properties:
				this.messageContainer.set('text', 'ERROR: Could not email the PIN reminder. Please try again soon.');
				this.messageEl.addClass('error');
				this.messageEl.removeClass('hidden');
			}.bind(this)
		}).get();
	}
	
	, _submitPIN: function(ev) {
		ev.preventDefault();
		var validInput=true;
		this.pinInputs.each(function(inputEl) {
			if (inputEl.value.length==0 || isNaN(inputEl.value)) {
				validInput=false;
			}
		}, this);
		if (validInput) { 
			this.pinValidation = new Request.JSON({
				url: this.pcForm.get('action')
				, data: this.pcForm.toQueryString()
				, onSuccess: function(responseJSON, responseText) {
					if (responseJSON.success) {
						this.messageEl.addClass('hidden');
						this._isValidPIN();
					} else {
						this._clearPIN();
						this.messageContainer.set('text', responseJSON.message);
						this.messageEl.addClass('error');
						this.messageEl.removeClass('hidden');
					}
				}.bind(this)
				, onFailure: function(xhr) {
					// TODO: Move to messages_en.properties:
					this.messageContainer.set('text', 'ERROR: Could not verify your PIN. Please try again soon.');
					this.messageEl.addClass('error');
					this.messageEl.removeClass('hidden');
				}.bind(this)
			});
			this.pinValidation.get();
		}
	}
	
	, _hideMessage: function(e) {
		e.preventDefault();
		this.messageContainer.set('text', "");
		this.messageEl.removeClass('error');
		this.messageEl.addClass('hidden');
	}
	
	, _clearPIN: function() {
		this.pinInputs.each(function(inputEl) {
			inputEl.value='';
		}, this);
		this.pinInputs[0].focus();
	}
	
	, _isValidPIN: function() {
		this.template.hide();
		this.callbacks.complete();
	}
});Uverse.playerExtensions.PlayDurationExtension= new Class({
	Extends: Uverse.playerExtensions.ExtensionAware
	,Binds: [ '_onWindowUnload' ]

	, options: {
		videoKey: null
		,useAsyncOnModalClosed: true
	}

	, userDuration : 0
	, videoDuration : 0
	, interval : 30000
	, remainingUpdates : 1
	, guid : null
	, startTime: null
	
	, player : null
	, updateTimer : null
	, eventMappings : null
	, playerState : null
	, currentState : null

	, firstTime : true
	, playDurationReportingComplete : true
	
	, initialRequest : null
	, updateRequest : null
	, finalRequest : null

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
		
		this.playerState = new Hash({
			playing : 'playing'
			, paused : 'paused'
			, killed : 'killed'
		});
		
		this.eventMappings = new Hash({
			'contentStart' : this._onContentStart.bind(this)
			, 'contentEnd' : this._onContentEnd.bind(this)
			, 'videoEnd' : this._onVideoEnd.bind(this)
			, 'adStart' : this._pauseCounting.bind(this)
			, 'adEnd' : this._startCounting.bind(this)
		});
		
		this.initialRequest = new Request({
			url: '/handleInitialPlay.html'
			, onSuccess: this._onInitialRequestSuccess.bind(this)
		});
		
		this.updateRequest = new Request({
			url: '/handleUpdatePlay.html'
		});
		
	}
	
	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		this.player = player;
		
		if (this.player) {
			
			this.eventMappings.each(function(eventTarget, eventName) {
				this.player.addEvent(eventName, eventTarget);
			}, this);
			
			if (this.options.videoKey) {
				this._initPlayDuration(this.options.videoKey);
			} else {
				Uverse.console.error("[PlayDurationExtension]", "No token found with player!");
			}
		}
	}
	
	/** Overrides base */
	, destroyExtension: function() {
		var async = this.options.useAsyncOnModalClosed;
		this._reportFinalDuration(async);
		this._cleanupEvents();
	}
	
	, _initPlayDuration: function(videoKey) {
		this.guid = this._guidGenerator();
		
		this.initialRequest.post({
			'guid' : this.guid
			,'videoKey' : videoKey
		});
		
		window.addEvent('unload', this._onWindowUnload);
	}
	, _onWindowUnload: function() {
		this._reportFinalDuration(false);
	}
	
	, _onInitialRequestSuccess: function(response) {
		Uverse.console.log("[PlayDurationExtension]", "Initialized Play Count Reporting");
		this.playDurationReportingComplete = false;
	}
	
	, _onContentStart: function() {
		Uverse.console.log("[PlayDurationExtension]", "Content started");
		if(this.firstTime) {
			this.updateTimer = this._reportUpdateDuration.periodical(this.interval, this);
			this._startCounting();
			this.player.addEvent('stateChange', this._onStateChange.bind(this));
			this.firstTime = false;
			
			Uverse.console.log("[PlayDurationExtension]", 'Timer Started (interval: ' + this.interval + 'ms)');
			this._setVideoDuration.delay(500, this); //added an initial delay to grab the video length
		}
	}
	
	, _onContentEnd: function() {
		this._pauseCounting();
	}
	
	, _onVideoEnd: function() {
		var async = this.options.useAsyncOnModalClosed;
		this._reportFinalDuration(async);
		this._cleanupEvents();
	}
	
	, _pauseCounting: function() {
		if(this.currentState != this.playerState.paused){
			this.currentState = this.playerState.paused;
			this._updateDuration();
			this.startTime = null;
			Uverse.console.log("[PlayDurationExtension]", 'Paused Counting');
		}
	}
	
	, _startCounting: function() {
		if(this.currentState != this.playerState.playing){
			this.currentState = this.playerState.playing;
			this.startTime = new Date().getTime();
			Uverse.console.log("[PlayDurationExtension]", 'Started Counting, Start Time => ' + this.startTime);
		}
	}
	
	, _onStateChange: function(state) {
		this.remainingUpdates = 1;
		switch (state) {
			case this.playerState.playing:
				if (!this.player.adPlaying) {
					this._startCounting();
				}
				break;
			case this.playerState.paused:
				this._pauseCounting();
				break;
			case this.playerState.killed:
				Uverse.console.log("[PlayDurationExtension]", 'Player sent out kill state.');
				this._cleanupEvents();
		}
	}
	
	, _updateDuration: function() {
		if (this.startTime != null) {
			var now = new Date().getTime();
			this.userDuration += (now - this.startTime);
			this.startTime = now;
			Uverse.console.log("[PlayDurationExtension]", 'Play duration now ' + this.userDuration);
		}
		if (this.userDuration > this.videoDuration) {
			this._setVideoDuration();
		}
	}
	
	, _reportUpdateDuration : function() {
		Uverse.console.log("[PlayDurationExtension]", 'Updating Duration!!!');
		this._updateDuration();

		// only request if currently playing or once after paused
		if (this.guid != null && this.remainingUpdates > 0) {
			Uverse.console.log("[PlayDurationExtension]", 'Updating Request!!!');
			if(this.currentState == this.playerState.paused) { this.remainingUpdates--; }
			this.updateRequest.post({
				guid : this.guid
				,duration : this.userDuration
				,assetlength : this.videoDuration
			});
		} else {
			Uverse.console.log("[PlayDurationExtension]", 'NOT Updating Request!!! GUID: ' + this.guid + ' | remainingUpdates: ' + this.remainingUpdates);
		}
	}
	
	, _getFinalDuration: function() {
		Uverse.console.log("[PlayDurationExtension]", 'Get Final Duration');
		this._pauseCounting();
		this._updateDuration();
		this.remainingUpdates = 0;
	}
	
	, _reportFinalDuration: function(async) {
		if(!this.playDurationReportingComplete && this.guid) {
			Uverse.console.log("[PlayDurationExtension]", 'Report Final Duration', (async ? "(asynchronously)" : ""));
			this.playDurationReportingComplete = true;
			this._getFinalDuration();

			if (!async) Uverse.console.time("[PlayDurationExtension] Report Final Duration took");

			this.finalRequest = new Request({
				url: '/handleFinalPlay.html'
				, async: async
			});
			this.finalRequest.post({
				"PlayDurationReporting-guid" : this.guid
				,"PlayDurationReporting-duration" : this.userDuration
				,"PlayDurationReporting-assetLength" : this.videoDuration
			});

			if (!async) Uverse.console.timeEnd("[PlayDurationExtension] Report Final Duration took");

		}
	}
	
	, _setVideoDuration: function() {
		var newVideoDuration = this.player.getDuration() * 1000; //convert to ms
		if (newVideoDuration > this.videoDuration) { //update duration only if its greater than the stored value
			this.videoDuration = newVideoDuration;
			Uverse.console.log("[PlayDurationExtension]", 'Video Duration Set (' + this.videoDuration + 'ms)');
		}
	}
	
	, _cleanupEvents: function() {
		clearInterval(this.updateTimer);
		
		window.removeEvent('unload', this._onWindowUnload);
		
		if(this.player) {
			this.eventMappings.each(function(eventTarget, eventName) {
				this.player.removeEvent(eventName, eventTarget);
			}, this);
		}
		this.userDuration=0;
		this.playDurationReportingComplete=true;
	}

	,_guidGenerator: function() {
		var S4 = function() {
			return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
		};
		return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
	}
	
});Uverse.playerExtensions.PlayerErrorExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, errorTemplate: null
	             
	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		this.errorTemplate = extensionPanels.getElement('.playerError-extension');
		this.callbacks.complete();
	}

	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		player.addEvent('playerError', this._onPlayerError.bind(this));
		this.playerContainer = playerContainer;
	}

	, _onPlayerError: function(message) {
		this.errorTemplate.getElement('.playerError-extension-details').set('text', message);
		this.errorTemplate.removeClass('hidden');
	}

	/** Overrides base */
	, destroyExtension: function() {
		this.errorTemplate.destroy();
	}

});Uverse.playerExtensions.PostVideoPromotionsExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	,template: null
	,requestTimer: null
	,request: null

	,options: {
		videoKey: null
		,safeVideoKey: null
		,categoryPath: null

		,requestDelay: 5000
		, urls: {
			getPVP: '/getPVP.html'
		}
	}

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		// Queue our ajax, and always allow the player to continue:
		this.template = extensionPanels.getElement('.post-video-promotions-extension');
		this._startRequest();

		this.callbacks.complete();
	}
	, _startRequest: function() {
		this.request = new Request.HTMLDeferred({
			url: this.options.urls.getPVP
			,data: {
				videoId: this.options.videoKey
				, categoryPath: this.options.categoryPath
			}
			,update: this.template.getElement('.post-video-promotions-extension-contents')
			,onSuccess: this._onRequestSuccess.bind(this)
			,onFailure: this._onRequestFailure.bind(this)
		});
		this.request.deferResults(true);

		// Delay the request:
		this.requestTimer = (function() {
			this.request.send();
		}).delay(this.options.requestDelay, this);
	}
	, _onRequestFailure: function(xhr) {
		Uverse.console.error("[PostVideoPromotionExtension]", "Request error");
	}

	/** Overrides base */
	, playerFinished: function() {
		// Disable the deferred results:
		// (this will fire _onRequestSuccess)
		this.request.deferResults(false);
	}


	, _onRequestSuccess: function(tree, elements, html, js) {
		this.template.removeClass('hidden');

		this.loadedWidgets = Uverse.loader.processQueue({ preventLazyLoad: true});

		this.loadedWidgets.load();

		this._setupReplay();
		this._setupPaging();
	}
	, _setupReplay: function() {
		var replay = this.template.getElement('.control-button-replay');
		replay.addEvent('click:button(left)', this._onReplayClick.bindAndPassThis(this));
	}
	, _onReplayClick: function(replay, ev) {
		ev.preventDefault();

		Uverse.page.reloadCurrentUrl();
	}
	, _setupPaging: function(){
		var left = this.template.getElement('.post-video-promotions-page-left')
			,right = this.template.getElement('.post-video-promotions-page-right');
		left.addEvent('click', function(ev){ this.pager.movePage(-1); }.bind(this));
		right.addEvent('click', function(ev){ this.pager.movePage(1); }.bind(this));
		var bullets = null;

		var tilesContainer = this.template.getElement('.post-video-promotions-tiles');
		var options = {};
		var pagerCallbacks = {
			'pageChanged': function(index, lastIndex) {
				(index == 0) ? left.hide() : left.show();
				(index == lastIndex) ? right.hide() : right.show();

				bullets.removeClass('bullet-active');
				bullets[index].addClass('bullet-active');
			}
		};
		this.pager = new Uverse.playerExtensions.PostVideoPromotionsExtension.Pager(tilesContainer, options, pagerCallbacks);

		// Set up the bullets:
		var bulletContainer = this.template.getElement('.post-video-promotions-page-bullets-container');
		var bulletTemplate = this.template.getElement('.post-video-promotions-page-bullet');
		for (var i = 1; i < this.pager.pageCount; i++) {
			bulletContainer.adopt(bulletTemplate.clone());
			bulletContainer.appendText(' '); // Add spacing between bullets (because they're display: inline-block;)
		}
		bullets = bulletContainer.getChildren();
		bullets.addEvent('click', function(bullet, ev) {
			this.pager.setPage(bullets.indexOf(bullet));
		}.bindAndPassThis(this));

		if (this.pager.pageCount <= 1) {
			bulletContainer.addClass('hidden');
		}

		this.pager.setPage(0);


	}

	/** Overrides base */
	, destroyExtension: function() {
		// Cancel running requests:
		if (this.requestTimer) {
			clearInterval(this.requestTimer);
			this.requestTimer = null;
		}
		if (this.request) {
			this.request.cancel();
			this.request = null;
		}

		// Destroy widgets:
		if (this.loadedWidgets) {
			this.loadedWidgets.unload();
			this.loadedWidgets.destroy();
			this.loadedWidgets = null;
		}
	}
});

// Temporary namespace for this mostly reusable Pager class:
// TODO: Move Pager to Uverse.utils.Pager:
Uverse.playerExtensions.PostVideoPromotionsExtension.Pager = new Class({
	Implements: [ Options, Callbacks ]

	, options: {
		scrollingOptions: {
			wheelStops: false
		}
	}
	, callbacks: {
		/**
		 * @param pageCount
		 */
		'pageCountChanged': false
		,
		/**
		 *
		 * @param index
		 * @param lastIndex
		 */
		'pageChanged': false

	}
	, el: null
	, scroller: null
	, currentIndex: -1
	, pageCount: null
	, pageWidth: null



	, initialize: function(el, options, callbacks) {
		this.el = el;
		this.setOptions(options);
		this.setCallbacks(callbacks);

		this._setupScroller();
	}
	, movePage: function(direction) {
		this.setPage(this.currentIndex + direction);
	}
	, setPage: function(index) {
		index = Math.min(Math.max(0, index), this.pageCount - 1);
		if (this.currentIndex === index){
			return;
		}
		this.currentIndex = index;
		var scrollLeft = this.currentIndex * this.pageWidth;
		this.scroller.start(scrollLeft, 0);

		if (this.callbacks['pageChanged']) {
			this.callbacks['pageChanged'](this.currentIndex, this.pageCount - 1);
		}
	}

	, _setupScroller: function() {
		var scrollOptions = this.options.scrollingOptions;
		this.scroller = new Fx.Scroll(this.el, scrollOptions);
		//var size = this.el.getComputedSize({mode:'horizontal'});
		this.pageWidth = this.el.getWidth(); // size['width'];
		var totalWidth = this.el.getScrollSize().x;
		this.pageCount = Math.ceil(totalWidth / this.pageWidth);

		var alignmentTweak = 15; // Hacky :(
		this.pageWidth -= alignmentTweak;

		if (this.callbacks['pageCountChanged']) {
			this.callbacks['pageCountChanged'](this.pageCount);
		}
	}

});Uverse.playerExtensions.StreamNotifierExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, Binds: [ '_onWindowUnload' ]

	, options : {
		videoKey : null
		,releaseUrl: '/releaseStream.html'
	}
	, player: null
	, token : null

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		this.player = player;
		this.player.addEvent('contentStart', this._obtainToken.bind(this));
	}

	, _obtainToken: function() {
		if (this.token == null) {
			this.token = this.player.getStreamToken();
			if (this.token != null) {
				Uverse.console.log('[StreamNotifierExtension]', 'Obtained Stream Token: ', this.token);
				window.addEvent('unload', this._onWindowUnload);
			}
		}
	}

	/** Overrides base */
	, destroyExtension: function() {
		if (this.token !== null) {
			window.removeEvent('unload', this._onWindowUnload);
			this._releaseStream(true);
		}
	}

	, _onWindowUnload: function() {
		this._releaseStream(false);
	}

	, _releaseStream: function(async) {
		Uverse.console.log('[StreamNotifierExtension]', 'Releasing Stream', (async ? ' (asynchronously)' : ""));

		if (!async) Uverse.console.time('[StreamNotifierExtension] Releasing Stream took');

		var request = new Request({
			url: this.options.releaseUrl
			, async: async
		});
		request.post({
			token : this.token
			, videoKey : this.options.videoKey
		});

		if (!async) Uverse.console.timeEnd('[StreamNotifierExtension] Releasing Stream took');
	}
	
});
Uverse.playerExtensions.VideoBookmarksExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware
	,Binds: [ '_onWindowBeforeUnload', '_onBookmarksReady' ]

	,enabled : true
	,player : null

	,startPosition: -1

	,template: null
	,removeRequest:null
	,setRequest:null
	,setRequestAsync:null
	,setWhenClosed: false


	,options: {
		videoKey: null
		,safeVideoKey: null
		, urls: {
			setBookmark: '/bookmarks/set.html'
			,removeBookmark: '/bookmarks/remove.html'
		}
		,dontBookmarkWithin: {
			initialSeconds: 10
			,finalSeconds: 10
		}
	}

	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		this.enabled = Uverse.page.isUserLoggedIn();

		if (!this.enabled) {
			this.callbacks.complete();
			return;
		}

		this.template = extensionPanels.getElement('.video-bookmarks-extension');

		this._setupRequests();
		Uverse.page.addMemoryEvent('Bookmarks-ready:once', this._onBookmarksReady);
	}
	, _onBookmarksReady: function() {
		var bookmark = Uverse.page.getVideoBookmark(this.options.safeVideoKey);

		if (!bookmark) {
			this.callbacks.complete();
			return;
		}

		var autoResume = window.location.hash.contains('resume')
			,autoRestart = window.location.hash.contains('restart');
		if (autoResume) {
			this._chooseResume(bookmark);
		} else if (autoRestart) {
			this._chooseRestart();
		} else {
			// Show the "resume/restart" ui:
			this._displayBookmark(bookmark);
		}

	}

	/**
	 * @param {Object} bookmark
	 * @param {Number} bookmark.position
	 * @param {Number} bookmark.totalTime
	 * @param {Number} bookmark.dateWatched
	 */
	, _displayBookmark: function(bookmark) {

		this._setupForm(bookmark);
		this._updateTemplate(bookmark);

		this.template.removeClass('hidden');
	}
	, _setupForm: function(bookmark) {
		var formCallbacks = {
			'submit': function(ev,formValues){ this._onButtonClicked(ev, formValues, bookmark); }.bind(this)
		};
		var formEl = this.template.getElement('form');
		this.formWidget = new Uverse.controls.Form(formEl, formCallbacks);
	}
	, _updateTemplate: function(bookmark) {
		var data = {
			percent: (100 * (bookmark.position / bookmark.totalTime)).toFixed(0)
			, position: this._formatDuration(bookmark.position)
			, totalTime: this._formatDuration(bookmark.totalTime)
			, dateWatched: new Date(bookmark.dateWatched)
		};

		var titleEl = this.template.getElement('.player-extension-title');
		var progressEl = this.template.getElement('.video-bookmarks-progress-text');
		var progressBarComplete = this.template.getElement('.progress-bar-complete');

		titleEl.set('html', data.dateWatched.format(titleEl.get('html')));
		progressEl.set('html', progressEl.get('html').substitute(data));

		progressBarComplete.setStyle('width', data.percent + '%');
	}

	, _onButtonClicked: function(ev, formValues, bookmark) {
		if (formValues.resume) {
			this._chooseResume(bookmark);
		} else if (formValues.restart) {
			this._chooseRestart();
		}

		this.template.addClass('hidden');
	}

	, _chooseResume: function(bookmark) {
		this.startPosition = bookmark.position;
		this.callbacks.complete();
	}
	, _chooseRestart: function() {
		this._removeBookmark();
		this.callbacks.complete();
	}


















	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {

		if (!this.enabled) {
			return;
		}

		this._setupPlayer(player);
		this._setupEvents();
		this.setWhenClosed = true;
	}

	, _setupRequests: function() {
		this.setRequest = new Request({
			url: this.options.urls.setBookmark
			,async: false
		});
		this.setRequestAsync = new Request({
			url: this.options.urls.setBookmark
			,async: true
		});
		this.removeRequest = new Request({
			url: this.options.urls.removeBookmark
		});
	}
	, _setupPlayer: function(player) {
		this.player = player;

		this.player.addEvent('stateChange', this._onPlayerStateChange.bind(this));
		this.player.addEvent('contentStart', this._onContentStart.bind(this));
		this.player.addEvent('contentEnd', this._onContentEnd.bind(this));
		this.player.addEvent('videoEnd', this._onVideoEnd.bind(this));
	}

	,_setupEvents: function(){
		window.addEvent('beforeunload', this._onWindowBeforeUnload);
	}

	,_teardownEvents: function(){
		window.removeEvent('beforeunload', this._onWindowBeforeUnload);
	}
	,_onWindowBeforeUnload: function(){
		var async = false;
		this._setBookmark(async);
	}

	/**
	 * Formats a duration as a timecode. Hours are ommited if not > 60 mins.
	 *
	 * E.g. 106 => 1:45:01
	 *
	 * @param {Integer} seconds Duration in seconds
	 */
	,_formatDuration: function(seconds) {
		var h = Math.floor(seconds / 3600);
		var m = Math.floor((seconds % 3600) / 60);
		var s = Math.floor((seconds % 3600) % 60);

		return (h == 0 ? '' : (h.toString() + ':')) +
			((m < 10 && h > 0) ? '0' + m.toString() : m.toString()) + ':' +
			(s < 10 ? '0' + s.toString() : s.toString());
	}

	,_onContentStart: function(){
		this._removeBookmark();
		if (this.startPosition > 0) {
			var startPosition = this.startPosition;
			this.startPosition = -1;
			this.player.seek(startPosition);
			this.player.videoPlaying = true;
		}
	}

	,_onContentEnd: function(){
		this._removeBookmark();
	}

	,_onVideoEnd: function(){
		this._removeBookmark();
		this._teardownEvents();
		this.setWhenClosed = false;
	}

	,_onPlayerStateChange: function(state) {
		if (state == 'paused') {
			var async = true;
			this._setBookmark(async);
		}
	}

	/**
	 * Sets a bookmark if the player is available.
	 */
	,_setBookmark: function(async) {
		if (this.player.hasContentStarted()) {

			var position = this.player.getPosition();
			var totalTime = this.player.getDuration();

			var dontBookmarkWithin = (position < this.options.dontBookmarkWithin.initialSeconds)
				|| (position > (totalTime - this.options.dontBookmarkWithin.finalSeconds));
			if (dontBookmarkWithin) {
				this._removeBookmark();
			} else {
				var videoKey = this.options.videoKey;
				Uverse.console.log("[VideoBookmarksExtension]", "Setting the bookmark for", videoKey, " at ", position, (async ? "(asynchronously)" : ""));

				if (!async) Uverse.console.time("[VideoBookmarksExtension] Setting bookmark took");

				var request = (async ? this.setRequestAsync : this.setRequest);
				request.get({
					videoKey: videoKey
					,position: position
					,totalTime: totalTime
				});
				var bookmark = {
					position: position
					,totalTime: totalTime
					,dateWatched: new Date()
				};
				Uverse.page.setVideoBookmark(this.options.safeVideoKey, bookmark);

				if (!async) Uverse.console.timeEnd("[VideoBookmarksExtension] Setting bookmark took");
			}
		}

	}

	,_removeBookmark: function() {
		var videoKey = this.options.videoKey;
		Uverse.console.log("[VideoBookmarksExtension]", "Removing the bookmark for ", videoKey);
		this.removeRequest.get({videoKey : videoKey});
		Uverse.page.setVideoBookmark(this.options.safeVideoKey, null);
	}

	/** Overrides base */
	, destroyExtension: function() {
		if (this.setWhenClosed) {
			this.setWhenClosed = false;
			var async = true;
			this._setBookmark(async);
		}
		this._teardownEvents();
	}

});Uverse.playerExtensions.WebtrendsExtension = new Class({
	Extends: Uverse.playerExtensions.ExtensionAware

	, options: {
		videoCategory: null
		, parentTitle: null
		, pageImpression: null
		, playerImpression: null
	}
	, initialize: function(options, callbacks) {
		this.setOptions(options);
		this.setCallbacks(callbacks);
	}

	/** Overrides base */
	, playerLoading: function(extensionPanels) {
		var Webtrends = window.Webtrends;
		if(Webtrends) {
			Webtrends.multiTrack({
				args: {
					"WT.dl": this.options.dl
					, "WT.clip_ev": this.options.eventName
					, "WT.clip_n": this.options.title
					, "WT.clip_id": this.options.videoId
					, "WT.z_Clip_Category": this.options.videoCategory
					, "WT.z_Clip_Series": this.options.parentTitle
					, "WT.z_pageImpression": this.options.pageImpression
				}
			});
			Uverse.console.log('[WebtrendsExtension]', 'MultiTracked page impression');
			Webtrends.multiTrack({
				args: { 
					"WT.z_modalPageView": this.options.title
				}
			});
			Uverse.console.log('[WebtrendsExtension]', 'MultiTracked page view');
		}
		this.callbacks.complete();
	}
	
	/** Overrides base */
	, playerLoaded: function(player, playerContainer) {
		var Webtrends = window.Webtrends;
		if(Webtrends) {
			Webtrends.multiTrack({
				args: {
					"WT.dl": this.options.dl
					, "WT.clip_ev": this.options.eventName
					, "WT.clip_n": this.options.title
					, "WT.clip_id": this.options.videoId
					, "WT.z_Clip_Category": this.options.videoCategory
					, "WT.z_Clip_Series": this.options.parentTitle
					, "WT.z_playerImpression": this.options.playerImpression
				}
			});
			Uverse.console.log('[WebtrendsExtension]', 'MultiTracked player impression');
		}
	}
});